# 15 단일 연산 변수와 넌블로킹 동기화
- Semaphore, ConcurrentLinkedQueue와 같이 java.util.concurrent 패키지에 들어 있는 다수의 클래스는 단순하게 synchronized 구문으로 동기화를 맞춰 사용하는 것에 비교하면 속도도 빠르게 확장성도 좋다.
- 15장에서는 이와 같은 클래스의 성능이 좋아진 원인이라고 볼 수 있는 단일 연산 변수와 대기 상태에 들어가지 않는 넌블로킹 동기화 기법을 살펴봄
- 병렬 알고리즘과 관련한 최근의 연구 결과를 보면 대부분의 넌블로킹 알고리즘, 즉 여러 스레드가 동작하는 환경에서 데이터의 안전성을 보장하는 방법으로 락을 사용하는 대신 저 수준의 하드웨어에서 제공하는 비교 후 교환 등의 명령을 사용하는 알고리즘을 다루고 있다.
- 넌블로킹 알고리즘은 운영체제나 JVM에서 프로세스나 스레드를 스케쥴링 하거나 가비지 컬렉션 작업, 그리고 락이나 기타 병렬 자료 구조를 구현하는 부분에서 굉장히 많이 사용하고 있다.
- 넌블로킹 알고리즘은 훨씬 세밀한 수준에서 동작하며, 여러 스레드가 동일한 자료를 놓고 경쟁하는 과정에서 대기 상태에 들어가는 일이 없기 떄문에 스케쥴링 부하를 대폭 줄여준다.
- 더군다나 데드락이나 기타 활동성 문제가 발생할 위험도 없다.
- 넌블로킹 알고리즘을 사용하는 경우에는 개별 스레드에서 발생하는 오류에 의해 영향을 받는 일이 없다.
- 자바 5.0부터는 AtomicInteger나 AtomicReference 등의 단일 연산 변수를 사용해 넌블로킹 알고리즘을 효율적으로 구현할 수 있게 됐다
- 단일 연산 변수는 본격적인 넌블로킹 알고리즘을 구현하는 일이 아니라 해도 '더 나은 volatile 변수' 의 역할만으로 사용할 수도 있다.
- 단일 연산 변수는 volatile 변수와 동일한 메모리 유형을 갖고 있으며 이에 덧붙여 단일 연산으로 값을 변경할 수 있는 기능을 갖고 있다.
- 이런 특성을 사용해 숫자 카운터, 일련 번호 생성기, 통계 수치 추출기 등으로 활용하면 락 기반의 구조에 비해 높은 확장성을 얻을 수 있다.

## 15.1 락의 단점
- 최근 사용하는 JVM은 스레드 간의 경쟁이 없는 상태에서 락을 확보하는 부분을 최적화하는 기능을 갖고 있으며 락을 해제하는 부분도 굉장히 효율적이다.
- 하지만 락 확보 경쟁이 벌어지는 상황에서 JVM 역시 운영체제의 도움을 받는다.
- 이런 경우 락을 확보하지 못한 스레드는 실행을 멈춰야 하며 나중에 조건이 충족되면 다시 실행시켜야 한다.
- 실행을 잠시 멈추고 있던 스레드가 다시 실행하게 됐다 해도 실제 CPU를 할당 받기 전에 이미 CPU를 사용하고 있는 다른 스레드가 CPU 할당량을 모두 사용하고 CPU 스케쥴을 넘겨줄때까지 대기해야 할 수도 있다.
- 락을 기반으로 세밀한 작업을 주로 하도록 구현돼 있는 클래스는 락에 대한 경쟁이 심해질수록 실제로 필요한 작업을 처리하는 시간 대비 동기화 작업에 필요한 시간의 비율이 상당한 수치로 높아질 가능성이 있다.
- volatile 변수는 락과 비교해 봤을 때 컨텍스트 스위칭이나 스레드 스케쥴링과 아무런 연관이 없기 때문에 락보다 훨씬 가벼운 동기화 방법이라고 볼 수 있다. 
- 반면 volatile 변수는 락과 비교할 때 가시성 측면에서는 비슷한 수준을 보장하긴 하지만, 복합 연산을 하나의 단일 연산으로 처리할 수 있게 해주는 기능은 전혀 갖고 있지 않다.
- 따라서 하나의 변수가 다른 변수와 관련된 상태로 사용해야 하거나, 하나의 변수라도 해당 변수의 새로운 값이 이전 값과 연관이 잇다면 volatile 변수를 사용할 수가 없다.
- 이런 특성 때문에 volatile 변수로는 카운터나 뮤텍스 를 구현할 수 없으며 따라서 전체적으로 volatile 변수를 사용할 수 있는 부분이 상당히 제한된다.
- ex : ++i의 경우 단일 연산인 것처럼 보이지만 1) 변수의 현재 값을 읽어오고, 2) 읽어온 값에 1을 더하고, 3) 더해진 값을 변수에 다시 설정하는 세 가지 연산의 조합으로 구현 돼 있다.
- 여러 스레드가 동작하는 과정에서 값을 제대로 변경하려면 읽고 변경하고 쓰는 세 가지 작업 전체가 하나의 단일 연산으로 동작해야 한다(이런 경우는 lock을 써야 한다.)
- 그러나 락 기반으로 사용하게 되면 락을 짧은 시간만 사용하므로 컨텍스트 스위칭 부하와, 스케쥴링 관련 지연 현상이 발생하는 단점 발생
- 또한 스레드가 락을 확보하기 위해 대기하고 있는 상태에서 대기중인 스레드는 다른 작업을 전혀 못한다.
- 이런 상태에서 락을 확보하고 있는 스레드의 작업이 지연되면 해당 락을 확보하기 위해 대기하고 있는 모든 스레드의 작업이 전부 지연되고 락을 확보하고 지연되는 스레드의 우선 순위가 떨어지고 대기 상태에 있는 스레드의 우선 순위가 높다면 프로그램 성능에 심각한 영향을 미치는 순위 역선 현상 발생
- 카운터 값을 증가시키는 등의 세밀한 작업은 연산을 동기화하기에는 락이 너무 무겁다.
- 그러면 volatile변수와 같이 가벼운 다른 방법은 없을까? 대부분의 프로세서는 그와 같은 방법을 제공하고 있다.

## 15.2 병렬 연산을 위한 하드웨어적인 지원
- 배타적인 락 방법은 보수적인 동기화 기멉이다.(락 확보시 다른 스레드 간섭 없음)
- 세밀하고 단순한 작업을 처리하는 경우에는 일반적으로 훨씬 효율적으로 동작할 수 있는 낙관적인 방법이 있는데, 일단 값을 변경하고 다른 스레드의 간섭 없이 값이 제대로 변경되는 방법이다.
- 충돌검출 방법을 사용해 값을 변경하는 동안 다른 스레드에서 간섭이 있었는지를 확인할 수 있으며, 간섭이 있었다면 해당 연산이 실패하게 되고 이후에 재시도하거나 아예 재시도조차 하지 않기도 한다.(허락을 받기보다 용서를 구하는게 쉽다 ㅋㅋ)
- 멀티 프로세서 연산을 염두에 두고 만들어진 프로세서는 공유된 변수를 놓고 동시에 여러 작업을 해야 한는 상황을 간단하게 고나리할 수 있도록 명령어 제공
    - 확인하고 값 설정
    - 값을 읽어와서 증가
    - 치환
- 위 연산을 기반으로 복잡한 병렬 클래스를 쉽게 만드는데 도움이 되는 뮤텍스를 충분히 구현 함
- 거의 모든 프로세서에서 읽고-변경하고-쓰는 단일 연산을 제공
- ex : 비교하고 치환, LL(load-linked)/SC(store-conditional)등의 연산

### 15.2.1 비교 후 치환
- IA32나 Sparc와 같은 프로세서에서 채택하고 있는 방법은 비교 후 치환(CAS) 명령을 제공하는 방법이다.
- CAS 연산에는 3개의 인자를 넘겨주는게, 작업할 대상 메모리의 위치인 V, 예상하는 기존 값인 A, 새로 설정할 값인 B
- CAS 연산은 V 위치에 있는 값이 A와 같은 경우에 B로 변경하는 단일 연산이다.
- 만약 이전 값이 A와 달랐다면 아무런 동작도 하지 않는다.
- 그리고 값을 B로 변경했던 못했던 간에 V를 리턴한다.
- 즉 CAS 연산의 동작하는 모습은 V에 들어있는 값이 A라고 생각되며, 만약 실제로 V의 값이 A라면 B라는 값으로 바꿔 넣어라, V가 A가 아니라면 아무 작업도 하지 말로 V의 값이 무엇인지를 알려달라
- CAS 연산은 성공적으로 치환할 수 있을것이라고 희망하는 상태에서 연산을 실행해보고, 값을 마지막으로 확인한 이후에 다른 스레드가 해당하는 값을 변경했다면 그런 사실이 있는지를 확인이나 하자는 의미
- 예제 15.1의 SimulatedCAS 클래스를 보면 CAS가 동작하는 내부 구조를 볼 수 있다.
- 만약 여러 스레드가 동시에 CAS 연산을 사용해 한 변수의 값을 변경하려고 한다면, 스레드 가운데 하나만 성공적으로 값을 변경할 것이고, 다른 나머지 스레드는 모두 실패한다.
- 대신 값을 변경하지 못했다고 해서 락을 확보하는 것처럼 대기 상태에 들어가는 대신 값을 변경하지 못했지만 다시 시도할 수 있다고 통보를 받는 셈이다(경쟁조건이면 어떻게 되지..?)
- CAS 연산에 실패한 스레드도 대기 상태에 들어가지 않기 때문에 스레드마다 CAS 연산을 다시 시도할 것인지, 아니면 다른 방법을 취할 것인지, 아니면 아무 조치도 취하지 않을 것인지 결정할 수 있다.
- 유연성때문에 활동성 문제를 미연에 방지할 수 있다.
- 예제 15.1 CAS 연산을 그대로 구현한 코드
~~~java
@ThreadSafe
public class SimulatedCAS {
    @GuardedBy("this") private int value;
    
    public synchronized int get() {return  value;}
    
    public synchronized int compareAndSwap(int expectedValue, int newValue) {
        int oldValue = value;
        if(oldValue == expectedValue) {
            value = newValue;
        }
        return oldValue;
    }
    
    public synchronized boolean compareAndSet(int expectedValue, int newValue) {
        return (expectedValue == compareAndSwap(expectedValue, newValue));
    }
}
~~~
- CAS를 활용하는 일반적인 방법은 먼저 V에 들어있는 값 A를 읽어내고 A 값을 바탕으로 새로운 값 B를 만들어내고, CAS 연산을 사용해 V에 들어있는 A값을 B값으로 변경하도록 시도한다.
- 그러면 다른 스레드에서 그 사이에 V의 값을 A가 아닌 다른 값으로 변경하지 않는 한 CAS연산은 성공하게 된다.

### 15.2.2 넌블로킹 카운터