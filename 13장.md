# 13 명시적인 락
- 자바에서 스레드가 접근하려 할 때 조율할 수 있는 synchronized 블록과 volitile외의 방법 : ReentrantLock
- ReentrantLock이 암묵적인 락의 대용품정도가 아니라 암묵적인 락으로 할 수 없는 일도 처리할 수 있도록 여러 고급 기능을 갖고 있다

## 13.1 Lock과 ReentrantLock
- 예제 13.1에서 볼 수 있는 Lock 인터페이스에는 여러 가지 락 관련 기능에 대한 추상 메소드를 정의하고 있다. Lock 인터페이스는 암묵적인 락과 달리 조건 없는 락, 폴링 락, 타임아웃이 있는 락, 락 확보 대기 상태에 인터럽트를 걸 수 있는 방법등이 포함돼 있으며, 락을 확보하고 헤제하는 모든 작업이 명시적이다.
- Lock을 구현하는 클래스는 항상 암묵적인 락과 비교해서 동일한 메모리 가시성을 제공해야 하지만 락을 거는 의미나 스케쥴링 알고리즘, 순서를 지켜주는 기능, 성능 등의 측면에서 다른 면모를 갖고 있다.
- 예제 13.1 Lock 인터페이스
~~~java
public interface Lock {

    /**
     * Acquires the lock.
     *
     * <p>If the lock is not available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until the
     * lock has been acquired.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>A {@code Lock} implementation may be able to detect erroneous use
     * of the lock, such as an invocation that would cause deadlock, and
     * may throw an (unchecked) exception in such circumstances.  The
     * circumstances and the exception type must be documented by that
     * {@code Lock} implementation.
     */
    void lock();

    /**
     * Acquires the lock unless the current thread is
     * {@linkplain Thread#interrupt interrupted}.
     *
     * <p>Acquires the lock if it is available and returns immediately.
     *
     * <p>If the lock is not available then the current thread becomes
     * disabled for thread scheduling purposes and lies dormant until
     * one of two things happens:
     *
     * <ul>
     * <li>The lock is acquired by the current thread; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of lock acquisition is supported.
     * </ul>
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring the
     * lock, and interruption of lock acquisition is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The ability to interrupt a lock acquisition in some
     * implementations may not be possible, and if possible may be an
     * expensive operation.  The programmer should be aware that this
     * may be the case. An implementation should document when this is
     * the case.
     *
     * <p>An implementation can favor responding to an interrupt over
     * normal method return.
     *
     * <p>A {@code Lock} implementation may be able to detect
     * erroneous use of the lock, such as an invocation that would
     * cause deadlock, and may throw an (unchecked) exception in such
     * circumstances.  The circumstances and the exception type must
     * be documented by that {@code Lock} implementation.
     *
     * @throws InterruptedException if the current thread is
     *         interrupted while acquiring the lock (and interruption
     *         of lock acquisition is supported)
     */
    void lockInterruptibly() throws InterruptedException;

    /**
     * Acquires the lock only if it is free at the time of invocation.
     *
     * <p>Acquires the lock if it is available and returns immediately
     * with the value {@code true}.
     * If the lock is not available then this method will return
     * immediately with the value {@code false}.
     *
     * <p>A typical usage idiom for this method would be:
     *  <pre> {@code
     * Lock lock = ...;
     * if (lock.tryLock()) {
     *   try {
     *     // manipulate protected state
     *   } finally {
     *     lock.unlock();
     *   }
     * } else {
     *   // perform alternative actions
     * }}</pre>
     *
     * This usage ensures that the lock is unlocked if it was acquired, and
     * doesn't try to unlock if the lock was not acquired.
     *
     * @return {@code true} if the lock was acquired and
     *         {@code false} otherwise
     */
    boolean tryLock();

    /**
     * Acquires the lock if it is free within the given waiting time and the
     * current thread has not been {@linkplain Thread#interrupt interrupted}.
     *
     * <p>If the lock is available this method returns immediately
     * with the value {@code true}.
     * If the lock is not available then
     * the current thread becomes disabled for thread scheduling
     * purposes and lies dormant until one of three things happens:
     * <ul>
     * <li>The lock is acquired by the current thread; or
     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the
     * current thread, and interruption of lock acquisition is supported; or
     * <li>The specified waiting time elapses
     * </ul>
     *
     * <p>If the lock is acquired then the value {@code true} is returned.
     *
     * <p>If the current thread:
     * <ul>
     * <li>has its interrupted status set on entry to this method; or
     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring
     * the lock, and interruption of lock acquisition is supported,
     * </ul>
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * <p>If the specified waiting time elapses then the value {@code false}
     * is returned.
     * If the time is
     * less than or equal to zero, the method will not wait at all.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The ability to interrupt a lock acquisition in some implementations
     * may not be possible, and if possible may
     * be an expensive operation.
     * The programmer should be aware that this may be the case. An
     * implementation should document when this is the case.
     *
     * <p>An implementation can favor responding to an interrupt over normal
     * method return, or reporting a timeout.
     *
     * <p>A {@code Lock} implementation may be able to detect
     * erroneous use of the lock, such as an invocation that would cause
     * deadlock, and may throw an (unchecked) exception in such circumstances.
     * The circumstances and the exception type must be documented by that
     * {@code Lock} implementation.
     *
     * @param time the maximum time to wait for the lock
     * @param unit the time unit of the {@code time} argument
     * @return {@code true} if the lock was acquired and {@code false}
     *         if the waiting time elapsed before the lock was acquired
     *
     * @throws InterruptedException if the current thread is interrupted
     *         while acquiring the lock (and interruption of lock
     *         acquisition is supported)
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    /**
     * Releases the lock.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>A {@code Lock} implementation will usually impose
     * restrictions on which thread can release a lock (typically only the
     * holder of the lock can release it) and may throw
     * an (unchecked) exception if the restriction is violated.
     * Any restrictions and the exception
     * type must be documented by that {@code Lock} implementation.
     */
    void unlock();

    /**
     * Returns a new {@link Condition} instance that is bound to this
     * {@code Lock} instance.
     *
     * <p>Before waiting on the condition the lock must be held by the
     * current thread.
     * A call to {@link Condition#await()} will atomically release the lock
     * before waiting and re-acquire the lock before the wait returns.
     *
     * <p><b>Implementation Considerations</b>
     *
     * <p>The exact operation of the {@link Condition} instance depends on
     * the {@code Lock} implementation and must be documented by that
     * implementation.
     *
     * @return A new {@link Condition} instance for this {@code Lock} instance
     * @throws UnsupportedOperationException if this {@code Lock}
     *         implementation does not support conditions
     */
    Condition newCondition();
}
~~~
- ReentrantLock 클래스 역시 Lock 인터페이스를 구현, synchronized 구문과 동일한 메모리 가시성과 상호 배제 기능을 제공
- ReentrantLock을 확보한다는 것은 synchronized블록에 진입하는 것과 동일한 효과를 갖고 있고, ReentrantLock을 해제한다는 것은 synchronized 블록에서 빠져나가는 것과 동일한 효과를 갖는다.
- ReentrantLock역시 synchronized 키워드와 동일하게 재진입이 가능하도록 허용.
- ReentrantLock은 Lock에 정의돼 있는 락 확보 방법 모두지원
- 락을 제대로 확보하기 어려운 시점에 synchronized 블록을 사용할 때보다 훨씬 능동적으로 대처가 가능하다
- 암묵적인 락만 사용해도 대부분의 경우에 별 문제 없이 사용할 수 있지만 기능적으로 제한되는 경우가 간혹 발생한다.
    - ex : 락을 확보하고자 대기하고 있는 상태의 스레드에는 인터럽트를 거는 일이 불가능하고, 대기 상태에 들어가지 않으면서 락을 확보하는 방법 등이 꼭 필요한 상황이 있기 때문
- 암묵적인 락은 또한 synchronized 블록이 끝나는 시점에 해제되는데, 이런 구조는 코딩하기에 간편하고 예외 처리 루틴과 잘 맞아 떨어지는 구조이긴 하지만 블록의 구조를 갖추지 않은 상황에서 락을 걸어야 하는 경우 적용 불가.
- 일부 상황에서는 성능과 활동성을 높이기 위해 synchronized 구문보다 유연성이 높은 락 방법이 필요하다.
- 예제 13.2를 보면 Lock을 사용하는 가장 기본적인 방법이 나타나있다.
- 사용할 때 꼭 지켜야 하는 synchronized 를 사용하는 암묵적인 락보다 좀 더 복잡한 규칙이 있는데 finally 블록에서 반드시 락을 해제해야 한다는 점이다.
- 락을 finally 블록에서 해제하지 않으면 try 구문 내부에서 예외가 발생했을 때 락이 해제되지 않는 경우가 발생한다.
- 락을 해제하는 기능을 finally 구문에 넣어두지 않은 코드는 언제 터질지 모르는 시한폭탄과 같다.
- synchronized 구문을 제거하는 대신 기계적으로 ReentrantLock으로 대치하는 작업을 하지 말아야 하는 이유는 바로 이것이다.
- 예제 13.2 ReentrantLock을 사용한 객체 동기화
~~~java
public class Example13_2 {
    
    void example() {
        Lock lock = new ReentrantLock();
        // ...
        lock.lock();
        try {
            //객체 내부 값을 사용
            // 예외가 발생한 경우, 적절하게 내 부값을 복원해야 할 수도 있음
        } finally {
            lock.unlock();
        }
    }
}
~~~
### 13.1.1 폴링과 시간 제한이 있는 락 확보 방법
- tryLock 메소드가 지우너하는 폴링 락 확보 방법이나 시간 제한이 있는 락 확보 방법은 오류가 발생했을 때 무조건적으로 락을 확보하는 방법보다 오류를 잡아내기에 훨씬 깔끔한 방법
- 암묵적인 락을 사용할 때에는 데드락이 발생하면 프로그램이 멈춰버리고 치명저인 상황에 이른다.
- 멈춘 프로그램을 동작시키는 방법은 종료하고 다시 실행시키는 방법뿐이고, 프로그램이 멈추지 않도록 하려면 올바르지 않은 락 순서를 맞춰 데드락이 발생하지 않도록 하는 수밖에 없다.
- 그런데 락을 확보할 때 시간 제한을 두거나 폴링을 하도록 하면 다른 방법 즉 확률적으로 데드락을 회피할 수 있는 방법을 사용할 수 있다.
- 락을 확보할 때 시간 제한을 두거나 폴링 방법을 사용하면 락을 확보하지 못하는 상황에도 통제권을 다시 얻을 수 있으며, 그러면 미리 확보하고 있던 락을 해제하는 등의 작업을 처리한 이후 다시 락을 재시도 할 수 있다.
- 10.1.2절에서 소개했던 동적인 락 정렬 문제로 인해 데드락이 발생했을 때 이런 상황을 피해갈 수 있는 방법이 예제 13.3에 소개돼 앴다.
- 예제 13.3 tryLock 메소드로 락 정렬 문제 해결
~~~java
public class Example13_3 {
    public boolean transferMoney(Account fromAcct, Account toAcct, DollarAmount amount, long timeout, TimeUnit unit) throws InsufficientFundsException, InterruptedException {
        long fixedDelay = getFixedDelayComponentNanos(timeout, unit);
        long randMod = getRandomDelayModulusNanos(timeout, unit);
        long stopTime = System.nanoTime() + unit.toNanos(timeout);
        
        while (true) {
            if(fromAcct.lock.tryLock()) {
                try {
                    if(toAcct.lock.tryLock()) {
                        try {
                            if(fromAcct.getBalance().compareTo(amount) < 0) {
                                throw new InsufficientFundsException();
                            } else {
                                fromAcct.debit(amount);
                                toAcct.credit(amount);
                                return true;
                            }
                        } finally {
                            toAcct.lock.unlock();
                        }
                    }
                } finally {
                    fromAcct.lock.unlock();
                }
            }
            
            if(System.nanoTime() >= stopTime) {
                return false;
            }
            NANOSECONDS.sleep(fixedDelay + rnd.nextLock() % randMod);
        }
    }
}
~~~
- 먼저 tryLock 메소드로 양쪽 락을 모두 확보하도록 돼 있지만 만약 양쪽 모두 확보할 수 없다면 잠시 대기했다가 재시도하도록 돼 있다.
- 대기하는 시간 간격은 라이브락이 발생할 확률을 최대한 줄일수 있도록 고정된 시간 또는 임의의 시간만큼 대기한다. 
- 만약 지정된 시간 이내에 락을 확보하지 못했다면 transferMoney 메소드는 오류가 발생했다는 정보를 리턴해주고 적절한 통제하에서 오류를 처리할 수 있다.
- 일정한 시간을 두고 객체를 관리하는 기능을 구현할 때 시간 제한이 있는 락을 적용하면 유용하다.
- 일정 시간 이내에 실행해야 하는 코드에서 대기 상태에 들어갈 수 있는 블로킹 메소드를 호출해야 한다면 지정된 시간에서 현재 남아있는 시간만큼을 타임아웃으로 지정할 수 있겠다.
- 그러면 지정된 시간 이내에 결과를 내지 못하는 상황이 되면 알아서 기능을 멈추고 종료되도록 만들 수 있다.
- 반면 암묵적인 락을 사용했다면 일단 락을 확보하고자 시도를 계속하므로 멈출수 없어서 정해진 시간 안에 처리해야 하는 작업을 맡기기엔 위험도 가 높다.
- 예제 6.17의 여행정보 포털 예제를 보면 각 렌터카 업체별 입찰 정보를 수집해 올 때 각 업체별로 독립적인 작업을 실행시키도록 돼 있었다.
- 입찰 정보를 수집하는 작업은 필수적으로 웹서비스와 같은 네트워크 통신을 통해 자료를 가져올 수 밖에 없다. 반면 입찰 정보를 수집할 때 충분히 확보하지 못한 자원을 사용해야 할 수도 있는데, 예를 들어 특정 업체와 전용 통신선으로 연결돼 있을 경우도 있다.
- 9.5절에서 특정 자원에 대해 순찾거으로 접근하도록 작업 과정을 직렬화하는 방법을 살펴봤다.
- 바로 단일 스레드로 동작하는 Executor 이다. 단일 스레드로 동작하는 Executor 외에 독점적인 락을 사용해 특정 자원을 동시에 사용하지 못하도록 막는 방법도 있다.
- 예제 13.4의 코드를 보면 Lock으로 막혀 있는 공유된 통신 자원을 통해 메시지를 전송하는 방법이 소개돼 있다.
- 또한 일정 시간 내에 작업을 처리하지 못하면 무리없이 적절한 방법으로 오류를 처리한다. tryLock 메소드에 타임아웃을 지정해 사용하면 시간이 제한된 작업 구조에 락을 함꼐 적용해 활용하기 좋다.
- 예제 13.4 일정 시간 이내에 락을 확보하는 모습
~~~java
public class Example13_4 {
    
    Lock lock = new ReentrantLock();
    
    public boolean trySendOnSharedLine(String message, long timeout, TimeUnit unit) throws InterruptedException {
        long nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);
        if(!lock.tryLock(nanosToLock, TimeUnit.NANOSECONDS)) {
            return false;
        }
        
        try {
            return sendOnSharedLine(message);
        } finally {
            lock.unlock();
        }
    }

    private boolean sendOnSharedLine(String message) {
        boolean result = false;
        //...
        return result;
    }

    private long estimatedNanosToSend(String message) {
        long result = 0L;
        //...
        return result;
    }
}
~~~

### 13.1.3 블록을 벗어나는 구조의 락
ㅎ
  
 