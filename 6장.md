# 06. 작업실행
- 작업은 추상적이면서 명확하게 구분된 업무의 단위.
- 애플리케이션이 해야 할 일을 작업 단위로 분할하면 구조 간결, 트랜잭션 범위 지정으로 인한 오류 대응, 병렬성 극대화

## 6.1 스레드에서 작업 실행
-  작업은 완전히 독십적인 동작(다른 작업의 상태, 결과, 부수 효과등에 영향을 받지 않음)
- 애플리케이션에 부하가 가해지는 상황에서 그냥 죽어버려서는 안되고, 부하에 따라 성능이 점진적으로 떨어지도록 설계돼 있어야 한다.
- 작업 실행정책을 변밀하게 구성할 필요가 있다.
- 6.1.1 작업을 순차적으로 진행
    - 가장 간단한 방법. 
    - 예제 6.1 순차적으로 처리하는 웹서버
~~~java
    import java.net.ServerSocket;import java.net.Socket;class SingleThreadWebServer {
        public static void main(String[] args) throws IOException {
            ServerSocket serverSocket = new ServerSocket(80);
            while(true) {
                Socket connection = serverSocket.accept();
                handlerRequest(connection);
            }
        }
    }
~~~
-
    - 한 번에 하나의 요청만을 처리할 수 있기 때문에 성능이 떨어짐.
    - 웹서버에 대한 클라이언트 요청을 처리하는 과정에는 대부분 약간의 연산 + I/O 연산
    - 한 번에 하나의 요청만을 처리하므로 작업 도중에 파일을 읽거나 쓰거나, 데이터 베이스에 서버 요청을 날리는 게 모두 대기 상태로 들어갈 수 있다.
- 6.1.2 작업마다 스레드를 직접 생성
    - 예제 6.2 요청이 들어올 때마다 스레드를 생성하는 웹서버
~~~java
    class ThreadPerTaskWebServer {
        public static void main(String[] args) throws IOException{
          ServerSocket serverSocket = new ServerSocket(80);
            while (true) {
                final Socket connection = serverSocket.accept();
                Runnable task = new Runnable() {@Override public void run()  {
                        handlerRequest(connection);
                    }
                };
                new Thread(task).start();
            }
        }
    }
~~~
-
    - 클라이언트 접속을 대기하다가 요청이 들어오면 적절하게 처리하는 과정을 반복.
    - 클라이언트의 요청 내용을 메인 스레드에서 직접 처리하지 않고, 클라이언트가 접속할 때마다 반복문에서 해당 클라이언트의 요청 처리를 담당하는 새로운 스레드를 매번 생성 이 경우 세가지 결과를 얻음
        - 1. 작업을 처리하는 기능이 메인 스레드에서 떨어지므로 서버의 응답 속도를 높여준다.
        - 2. 동시에 여러 작업을 병렬로 처리할 수 있으므로 두 개 이상의 요청을 받아 동시에 처리할 수 있다.
        - 3. 여러 클라이언트가 접속하므로 동시에 동작하기 때문에 스레드 안정성을 확보해야 한다.
    - 작업별로 스레드 생성시 웬만한 부하도 견디며 순차적인 실행 방법에 비해 속도 향상
    - 다만 클라이언트가 접속해 요청을 전송하는 속도해 비해 요청을 처리해 응답을 넘겨주는 속도가 빨라야 한다.
- 6.1.3 스레드를 많이 생성할 때의 문제점
    - 스레드 라이프 사이클 문제 : 스레드를 생성하고 제거하는 작업에도 자원이 소모. 간단하면서 자주 발생 시 작업에 많은 자원이 차지됨
    - 자원 낭비 : 실행중인 스레드는 메모리를 소모하므로 GC에 가해지는 부하가 늘어나고 메모리 이외에도 많은 자원 소모
    - 안정성 문제 : 프로그램이제한 된 값 안에서 동작하도록 작성해 OutOfMemoryException을 방지해야 한다.
    - 일정 수준 이상 스레드 추가시 성능이 떨어진다. 
## 6.2 Executor 프레임워크
- 스레드 풀은 스레드를 관리하는 측면에서 메모리를 모두 소모해 버리지 않도록 톡젤겨을 갖출 수 있도록 해주묘, Executor 프레엠워크의 일부분으로 유연하게 사용할 수 있는 스레드 풀이 만들어져 있다.
- 자바 클래스 라이브러리에서 작업을 실행 시 Thread보다 Executor가 훨씬 추상화가 잘 되어 있으며 사용하기 좋다.
- 예제 6.3 Executor 인터페이스
~~~
    public interface Executor {
        void excute(Runnable command);
    }
~~~       
- 다양한 종류의 작업 정책을 지원하는 유연하면서도 강력한 비동기적 작업 실행 프레임워크의 근간을 이루는 인터페이스
- Executor는 작업 등록과 작업 실행을 분리하는 표준적인 방법, 각 작업은 Runnable의 형태로 정의 
- Executor는 프로듀서-컨슈머 패턴에 기반. 
- 6.2.1 예제 : Executor를 사용한 웹서버
    - 예제 6.4 스레드 풀을 사용한 웹서버
~~~java
class TaskExecutionWebServer {
    private static final int NTHREAD = 100; //고정된 스레드 풀 확보
    private static final Executor exec = Executors.newFixedThreadPool(NTHREAD);
    
    public static void main(String[] args) throws IOException{
      ServerSocket socket = new ServerSocket(80);
      while (true) {
          final Socket connection = socket.accept();
          Runnable task = new Runnable() {@Override public void run() {
            handlerRequest(connection);
          }};
          exec.execute(task);
      }
    }
}
~~~
- 
    - 요청 처리 작업을 등록하는 부분과 실제로 처리 기능을 실행하는 부분이 Executor를 사이에 두고 분리.
    - Executor를 다른 방법으로 구현한 클래스를 사용하면 변경이 쉽ㄴ다.
    - Executor에 필요한 설정은 대부분 초기에 한 번 지정, Executor를 사용해 작업을 등록하는 코드는 프로그램에 퍼져있으므로 보기 어렵다.
    - 예제 6.4를 그대로 유지하면서 들어오는 요청 마다 새로운 스레드를 생성 해 변경하는 방법은 Executor를 상속받아 또다른 모양으로 구현
    - 예제 6.5 작업마다 스레드를 새로 생성시키는 Executor 
~~~java
import java.util.concurrent.Executor;public class ThreadPerTaskExcutor implements Executor {
    public void excute(Runnable r) {
        new Thread(r).start();
    }
}
~~~
-
    - 이와 유사하게 작업을 순차적으로 처리하는 일도 간단하다.
    - 예제 6.6과 같이 execute메소드 안에서 요청에 대한 처리 작업을 모두 실행하고, 처리가 끝나면 executor에서 리턴되도록 구현
    - 예제 6.6 작업을 등록한 스레드에서 직접 동작시키는 Executor
~~~java
import java.util.concurrent.Executor;public class WithinThreadExecutor implements Executor {
    public void execute(Runnable r) {
        r.run();
    }
}
~~~

- 6.2.2 실행 정책
    - 작업 등록 부분과 실행 부분을 분리시켜두면 특정 작업 실행시 코드를 많이 변경하지 않고 쉽게 변경할 수 있다. 
    - 실행 정책(자원관리도구) 
        - 작업을 어느 스레드에서 실행?
        - 작업을 어떤 순서로? (FIFO, LIFO 등)
        - 동시에 몇 개의 작업을 병렬로 실행?
        - 최대 몇 개까지의 작업이 큐에서 실행 대기?
        - 시스템 부하가 많이 걸려서 작업 거절 시 어떤걸 거절?, 작업을 요청한 프로그램에 어떻게 알림?
        - 작업을 실행하기 직전이나 직후에 동작은?
    - 어디든 new Thread(runnable).start()가 있으면 유연한 실행정책을 위해 Executor를 사용해 구현해야 한다 
- 6.2.3 스레드 풀 
    - 작업을 처리할 수 있는 동일한 형태의 스레드 풀의 형태로 관리
    - 작업 큐와 밀접한 관련 
    - 매번 스레드를 생성하는 대신 이전에 사용했던 스레드를 재사용. (시스템 자원이 줄어드는 효과, 만들어진 상태도 대기하므로 반응속도 향상)
    - 미리 정의되어 있는 스레드 풀을 사용하려면 Executors 클래스에 만들어져 있는 다음과 같은 메소드 호출
        - newFixedThreadPool : 처리할 작업이 등록되면 실제 작업할 스레드를 하나씩 생성. 생성할 수 있는 스레드 수 제한           
        - newCachedThreadPool : 현재 풀에 갖고 있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생 시 쉬는 스레드 종료. 처리할 작업이 많으면 스레드 새로 생성, 스레드 제한 x
        - newSingleThreadPool : 단일 스레드로 동작. 작업 중에 Exception 발생 시 새로운 스레드 생성해 나머지 작업 실행. 지정 순서에 따라 순차적으로 처리
        - newScheduledThreadPool : 일정 시간 이후에 주기적으로 작업 실행.  Executor.Timer와 비슷.
    - 풀을 기반으로 하는 전략으로 변경하면 안정성 측면에서 장점. 성능이 떨어질 때도 점진적으로 서서히 떨어진다.
- 6.2.4 Executor 동작 주기
    - Executor을 제대로 종료시키지 않으면 JVM 자체가 종료되지 않고 대기된다.
    - Executor가 종료 절차를 밟는 동안 실행중이거나 대기중이던 작업을 어떻게 처리했는지를 작업을 맡겼던 애플리케이션에 알려줄 의무가 있다.
    - ExecutorService 인터페이스에서 동작 주기를 과니할 수 있는 메소드가 추가되어있다.
    - 예제 6.7 ExecutorService 인터페이스의 동작 주기 관리
~~~java
import java.util.concurrent.Executor;import java.util.concurrent.TimeUnit;public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNwo();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    //... 작업을 등록할 수 있는 몇가지 추가 메소드

}
~~~      
-
    - 동작주기는 실행중, 종료중, 종료의 상태
    - ExecutorService의 하위 클래스인 ThreadPoolExecutor는 이미 종료 절차가 시작 되거나 종료된 이후에 새로운 작업을 등록하려 하면 실행 거절 핸들러를 통해 오류로 처리
    - 처음 생성시 실행 중 상태로 동작. 종료 절차가 시작된 이후 실행중이거나 대기 중이던 작읍을 모두 끝내고 나면 종료상태로 들어감. 
    - 예제 6.8 종료 기능을 추가한 웹서버
~~~java
class LifecycleWebServer {
    private ExecutorService executorService;
    
    public void start() throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (!executorService.isShutdown()) {
            try {
                final Socket conn = socket.accept();
                executorService.execute(new Runnable() {
                    @Override
                    public void run() {
                        handlerRequest(conn);
                    }
                });
            } catch (RejectedExecutionException e) {
                if(!executorService.isShutdown()) {
                    log("task submission rejected", e);
                }
            }
        }
    }
    
    public void stop() { executorService.shutdown();}
    
    void handlerRequest(Socket connection) {
        Request req = readRequest(connection);
        
        if(isShutdownRequest(req)) {
            stop(); // stop메소드 호출
        } else {
            dispatchRequest(req); //클라이어트 측에서 특정한 형태의 HTTP 요청을 전송
        }
    }
}
~~~
- 6.2.5 지연 작업, 주기적 작업
    - Timer 클래스는 약간의 단점(절대 시각 지원)이 있기 때문에 ScheduledThreadPoolExecutor를 사용하는 방법이 좋다.
    - ScheduledThreadPoolExecutor를 생성하려면 직업 ScheduledThreadPoolExecutor 클래스의 생성 메소드를 호출해 생성하는 방법과, newScheduledThreadPool 팩토리 메소드를 사용해 생성하는 방법이 있다.
    - Timer 클래스는 등록된 작업을 실행히키는 스레드를 하나만 생성해 사용하므로 등록된 특정 작업이 너무 오래 실행되면 다른 TimerTask작업이 예정된 시각에 실행되지 못할 가능성이 높다.
    - ScheduledThreadPoolExecutor 사용시 지연 작업과 주기적 작업마다 여러개의 스래드를 할당해 작업을 실행하므로 예정 시각을 벗어나는 일이 없다.
    - Timer 클래스는 또한 TimerTaask가 동작되던 도중에 예상치 못한 Exception을 던질 경우 예측하지 못한 상태로 넘어갈 수 있다.
    - BlockingQueue를 구현하면서 ScheduledThreadPollExecutor와 비슷한 DelayQueue를 사용하는것도 추천.
## 6.3 병렬로 처리할 만한 작업.
- Executor를 사용하려면 실행하려는 작업을 항상 Runnable 인터페이스에 맞춰 구현해야만 한다.
- 6.3.1 예제 : 순차적 페이지 렌더링
    - 가장 간단한 방법은 HTML 문서의 내용을 순차적으로 그려가는 방법.
    - 텍스트 마크업 만날 시 해당하는 문자열은 이미지 버퍼에, 이미지 파일에 대한 링크를 만나면 이미지를 네트워크로 다운 바아서 이미지 버퍼에 넣기
    - 사용자 입장에서는 페이지 내용이 전부 표시될 때까지 시간이 걸리므로 짜증남
    - 대안은 텍스트 부분 처리 후 텍스트 사이에 있는 이미지에 대항하는 부분을 실제 이미지 없는 네모난 박스로만 처리 후 이미지를 차례로 다운받아 비워넣음
    - 예제 6.10 페이지 내용을 순차적으로 랜더링
~~~java
public class SingleThreadRenderer {
    void renderPage(CharSequence source) {
        renderText(source);
        List<ImageData> imageData = new ArrayList<ImageData>(); 
        for(ImageInfo imageInfo : imageData) { imageData.add(imageInfo.downloadImage()); } // 네모난 박스로 처리
        for(ImageData data : imageData) { //실제 이미지 다운
            renderImage(data);
        }
    }
}
~~~

- 6.3.2 결과가 나올 때까지 대기 : Callable과 Future    
    
   