# 12 병렬 프로그램 테스트
- 병렬 프로그램 역시 순차적으로 처리하는 프로그램과 유사한 디자인 패턴을 가져다 쓰지만 순차적인 프로그램에 비해 곳곳에 작동 내용을 확인하기 어려운 부분을 포함하고 있다.
- 그러므로 순차적인 프로그램에 비해 각 부분 간에 상호 작용이 훨씬 복잡하며, 미리 예상하고 분석해야 할 가능한 오류 상황도 훨씬 많다.
- 테스팅 방법 역시 순차적인 프로그램을 테스트하던 방법을 그대로 가져와 사용하는데, 테스트 결과로 얻을 수 있는 값의 범위가 순차적인 프로그램보다 훨씬 다양하다는 특징이 있다.
- 병렬 프로그램을 테스트하는 프로그램을 작성할 때 처음 부딪히는 부분은 바로 순차적인 프로그램보다 문제 상황이 발생할 확률이 훨씬 적다는데 있다.
    - 결국 발생 확률이 훨씬 떨어지는 결과를 제대로 확힌해야 하기 때문에 테스트 프로그램에서 대상 애플리케이션을 훨씬 강하게 밀어붙여야 하고, 순차적인 프로그램보다 긴 시간동안 테스트하는 일이 많다.
- 병렬 프로그램을 테스트한 결과는 전통적으로 사용해왔던 문제 상황인 안전성(안 좋은 일이 발생하지 않는 상황)과 활동성(결국 좋은 일이 발생하는 상황)의 문제로 귀결된다.
- 클래스가 동작하는 형태가 설계했던 모습 그대로 움직이는지를 확인하는 안전성 테스트는 대부분 변수의 값이 정확한지를 확인하는 것부터 시작한다.
    - 갖고있는 항목의 개수를 독립 변수에 캐시하고 변경 사항이 발생할 때마다 업데이트하도록 만들어진 연결 리스트를 구현하고 있다면, 갖고 있는 항목의 개수와 캐시된 변수의 값이 일치하는지를 확인하는 부분이 가장 기본적인 안전성 테스트
- 단일 스레드 환경에서는 리스트에 들어있는 항목이 테스트 도중 변경될 수 없기 때문에 굉장히 쉽게 테스트할 수 있다.
- 그러나 다수의 스레드가 동작하는 병렬 처리 환경에서는 항목의 개수를 세는 작업과 세어진 개수가 캐시된 변수의 값과 일치하는지를 확인하는 두 가지 작업을 단일 연산으로 수행하지 않는 한 올바르지 않은 결과가 속출할 것이다.
- 이런 테스트를 병렬 환경에서 올바르게 진행하려면 대상 리스트를 독점적으로 사용할 수 있도록 준비해야 한다.
- 예를 들어 구현하고 있는 리스트클래스에서 현재 항목의 목록에 대한 스냅샷을 뽑아주는 기능을 구현하거나, 테스트 프로그램이 값을 제대로 비교하거나 테스트 코드를 안전하게 실행할 수 있도록 테스트 포인트를 마련하는 방법도 있다.
- 이책에서는 딱 맞아떨어지는 오류 상황을 표한하기 위해 타이밍 다이어그램을 사용하곤 했다.
- 테스트 프로그램은 물론 발생 가능한 상황을 최대한 넓게 지나다니면서 불행하게 타이밍이 딱 맞는 상황을 놓치지 않아야 한다. 반대로 안 좋은 타이밍을 만들어내기 위해 준비한 테스트 프로그램이 오히려 실제로 발생할 수 있는 상황을 표현하지 못하는 오류를 남겨두는 경우도 생길 수 있다.
    - 하이젠 버그 : 오류를 확인하기 위해 디버깅 관련 코드를 추가하면 사라져 버리는 버그
-  활동성 테스트는 어려운데, 활동성 테스트를 하다 보면 진행 중인 상태와 진행이 멈춘 상태를 테스트하는 경우가 많다.
    - ex : 특정 메소드를 테스트하는 도중에 더 이상 실행되지 않는 것처럼 보이는 경우가 생기면, 단순히 실행 속도가 너무 느린 것으로 봐야 할지, 실행 도중에 멈추는 오류가 발생한 것인지를 확인해야 한다.
- 이와 비슷하게 프로그램을 구현할 때 적용한 특정 알고리즘이 데드락에 걸리지 않는다고 어떻게 보장할 것인가? 프로그램에 오류가 있다고 판단하기 전까지 얼마나 오랫동안 느리게 실행되는 프로그램을 참아줘야 하는가?
- 활동성 문제를 테스트하는 것은 성능 문제를 테스트하는 것과 밀접한 관련이 있다. 성능은 여러가지 측면에서 수치화해 측정할 수 있다.
    - 처리량 : 병렬로 실행되는 여러 개의 작업이 각자가 할 일을 끝내는 속도
    - 응답성 : 요청이 들어온 이후 작업을 마치고 결과를 줄 때까지의 시간
    - 확장성 : 자원을 더 많이 확보할 때마다 그에 따라 처리할 수 있는 작업량이 늘어나는 정도

## 12.1 정확성 테스트
- 병렬 프로그램을 테스트하기 위한 테스트 프로그램을 작성할때는 순차적인 프로그램을 테스트하는 경우와 똑같은 분석 작업으로 시작
    - 올바른 값을 정확하게 알고 있는 변수가 어떤 것인지, 그 변수가 최종적으로 어떤 값을 가져와 하는 지 확인
- 설계가 충분히 이뤄진 경우에는 이와 같은 변수에 대한 사항이 설계 문서에 포함돼 있을 수 있다.
- 테스트 프로그램을 작성하는 나머지 시간은 전부 설계 과정에서 놓친 기능 명세를 찾아가는 과정이다.
- 정확성 테스트에 대해 확실하게 이해할 수 있는 예제로 크기가 제한된 버퍼 클래스에 대한 테스트 케이스 구현
- 예제 12.1 세마포어를 사용한 BoundedBuffer 클래스
~~~java
@ThreadSafe
public class BoundedBuffer<E> {
    private final Semaphore availableItems, availableSpaces; // availableItems : 현재 버퍼 내부에서 뽑아낼 수 있는 항목의 개수, availableSpaces : 버퍼에 추가할 수 있는 항목이 개수 
 
    @GuardedBy("this") private final E[] items; // 배열을 기반으로 하는 큐의 형태
    @GuardedBy("this") private int putPosition = 0, takePosition = 0;
    
    public BoundedBuffer(int capacity) {
        availableItems = new Semaphore(0);
        availableSpaces = new Semaphore(capacity); // 크기 제한
        items = (E[]) new Object[capacity];
    }
    
    public boolean isEmpty() {
        return availableItems.availablePermits() == 0;
    }
    
    public boolean isFull() {
        return availableSpaces.availablePermits() == 0;
    }
    
    public void put(E x) throws InterruptedException {  //대기상태에 들어갈 수 있음, 제한된 크기를 초과한 경우 대기
        availableSpaces.acquire();  
        doInsert(x);
        availableItems.release(); // 개수가 지정된 세마포어를 사용해 동기화
    }
    
    public E take() throws InterruptedException { // 대기 상태에 들어갈 수 있음
        availableItems.acquire(); // 세마포어에서 가져갈 수 있는 항목이 있는지 확인 받기
        E item = doExtract();
        availableSpaces.release(); // 세마포어 값 증가. 
        return item;
    } // put은 반대이므로 항상 양쪽 세마포어가 갖고 있는 값의 합이 버퍼의 크기와 일치
    
    private synchronized void doInsert(E x) {
        int i = putPosition;
        items[i] = x;
        ++i;
        if(i == items.length) {
            putPosition = 0;
            return;
        }
        putPosition = i;
    }
    
    private synchronized E doExtract() {
        int i = takePosition;
        E x = items[i];
        items[i] = null;
        ++i;
        if(i == items.length) {
            takePosition = 0;
            return x;
        }
        takePosition = i;
        return x;
    }
}
~~~
 
 
### 12.1.1 가장 기본적인 단위 테스트
- BoundedBuffer 클래스를 테스트하기 위한 가장 기본적인 단위 테스트 클래스는 순차적인 개념으로 생각했을 때와 별로 다르지 않다.
- BoundedBuffer 인스턴스를 하나 생성하고, 메소드를 이것 저것 호출해보고, 최종적인 상태와 변수의 값 등을 확인해보는 방법
    - ex : BoundedBuffer 인스턴스를 생성한 직후에는 자신이 데이터를 하나도 갖고 있지 않으며 가득 차지도 않았다는 점 표현,
    - ex2 : 용량이 N인 BoundedBuffer 클래스에 N개의 항목을 추가하고, 버퍼 클래스 스스로가 용량이 가득 찼다고 표현해야만 한다.
- 예제 12.2 BoundedBuffer 클래스의 기능을 테스트하는 가장 기본적인 테스트 케이스
 ~~~java
public class BoundedBufferTest extends TestCase {
    void testIsEmptyWhenConstructed() {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        assertTrue(bb.isEmpty());
        assertFalse(bb.isFull());
    }
    
    void testIsFullAfterPuts() throws InterruptedException {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        for(int i = 0; i < 10; i ++) {
            bb.put(i);
        }
        assertTrue(bb.isFull());
        assertFalse(bb.isEmpty());
    }
}
~~~
- 순차적으로 동작하는 테스트 케이스를 작성해두면 경쟁상황에서의 테스트는 경쟁상황에서 발생하는 오류라고 추측 가능

### 12.1.2 블로킹 메소드 테스트
- 병렬로 동작하는 상황을 테스트하고자 한다면 스레드를 두 개 이상 실행시켜야 하는 경우가 대부분
- 테스트를 도와주는 프레임워크는 대부분 병렬 처리 환경에 적절히 대응하지 못하는 경우가 많다.
    - ex : 스레드를 생성하는 기능이나 실행된 스레드가 의도하지 않는 방법으로 종료되는 일이 있는지를 모니터링하는 등의 기능을 제공하지 않음.
    - 만약 테스트 케이스 내부에서 생성한 도우미 스레드가 오류 상태를 확인했다 해도 프레임워크 입장에서는 스레드가 발견된 오류가 정확하게 어떤 테스트와 연관돼 있는지조차 제대로 알아내기가 힘들다.
    - 따라서 따로 실행되고 있는 스레드에서 성공과 실패 여부를 파악하는 경우에, 파악된 성공 또는 실패 여부를 다시 원래 테스트 케이스의 메소드에 알려줄 수 있는 방법이 마련돼 있어야 테스트 결과를 단위 테스트 프레임워크에서 제대로 리포팅 할 수 있다.
- java.util.concurrent 패키지에 대한 표준 부합 테스트를 진행할 때 실패건이 발생하는 경우 어떤 테스트에서 실패했는지를 정확하게 파악하는 일이 굉장히 중요했다.
- 따라서 JSR 166 전문가 그룹에서는 테스트 케이스에서 실패 상황이 발생했을 때 해당 건을 모아 뒀다가 tearDown 메소드에서 모든 오류 상황을 표시하는 기능을 구현한 기반 클래스를 하나 구현했다.[링크](http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java)
- 단 이 기반 클래스를 사용할 때에는 모든 테스트를 진행할 때 항상 특정 테스트에서 생성된 스레드는 해당 테스트가 종료되기 직전에 모두 종료돼야 한다는 조건을 만족해야 한다.
- 테스트가 오류 없이 정상적으로 끝났는지, 아니면 오류가 발생했을 때 오류를 제대로 찾아낼 수 있도록 오류 관련 정보를 충분히 출력해 줘야 한다.
- 만약 특정 메소드가 어떤 상황에서는 반드시 대기 상태에 들어가야 한다고 하면, 해당 기능에 대한 테스트를 담당했던 스레드가 더 이상 실행하지 않고 멈춰야만 테스트가 성공이라고 볼 수 있다.
- 대기상태에 들어가는 메소드를 테스트하는 것은 반드시 예외 상황이 발생해야 하는 메소드를 테스트하는것과 비슷하다. 만약 대상 메소드가 리턴되 버리면 테스트는 실패
- 대기 상태에 들어가는 메소드를 테스트할 때에는 여러가지 복잡한 사항이 있다.
    - 대상 메소드를 호출해서 제대로 대기 상태로 들어갔다고 하면 어떤 방법으로건 대기 상태를 풀어서 대기 상태에 들어갔었음을 확인해야 한다.
    - 이런 테스트를 할 수 있는 가장 확실한 방법은 인터럽트를 거는 방법
    - ex : 대기상태에 들어가야 하는 메소드를 호출할 때는 따로 스레드를 실행시켜 호출하고, 해당 스레드가 대기 상태에 들어갈 때까지 기다리고 있다가 대기 상태에 들어가면 인터럽트를 걸고 원하는 연산을 제대로 처리했는지 확인하는 순서로 진행
    - 물론 이와 같이 인터럽트를 활용해 테스트하려면 대기 상태에 들어갈 대상 메소드가 인터럽트에 적절하게 대응하도록(인터럽트가 걸리는 즉시 리턴되거나 InterruptedException 던지는 등의 행동)  만들어져 있어야 한다.
- '스레드가 대기 상태에 들어갈 때까지 기다리는 ' 방법은 간단하지 않다.
- 대기 상태에 들어가기 전에 배치된 프로그램코드가 실행되는데 얼마만큼의 시간이 걸릴것인지를 예측하고 있어야 하고, 그보다 오래 기다려 보는 수밖에 없다.
- 기다리도록 지정한 시간이 예상보다 짧아서 테스트가 제대로 이뤄지지 않는다면 기다리는 시간을 언제든지 늘릴 수 있도록 테스트 프로그램을 준비해야 한다.
- 예제 12.3 대기 상태와 인터럽트에 대한 대응을 테스트하는 루틴
    - 먼저 비어있는 버퍼의 take 메소드를 호출하는 taker 스레드 생성
    - taker 스레드가 호출한 take 메소드가 리턴된다면 taker 스레드는 오류가 발생했다는 사실을 기록
    - 테스트 프로그램을 실행하면 먼저 taker 스레드를 생성하고 적당량 이상 오래 기다려보고, 그 다음에는 taker 스레드에 인터럽트를 건다.
    - taker 스레드가 정상적으로 대기 상태에 들어가 있었다면 InterruptedException을 띄울것이고, InterruptedException을 받은 catch 구문에서는 예외가 발생한 상황이 정상적이라고 판단하고 스레드를 그대로 종료
    - taker 스레드를 실행시켰던 테스트 프로그램은 taker 스레드가 종료될 때까지 join 메소드를 기다리고, Thread.isAlive 메소드를 사용해 join메소드가 정상적으로 종료되었는지 확인
    - taker 스레드가 정상적으로 인터럽트에 응답했다면 join 메소드가 즉시 종료돼야 맞다.
    - 일반적인 join 메소드 대신 타임아웃을 지정하는 join 메소드를 사용하면 take 메소드가 예상치 못한 상황에 걸려 응답하지 않는 경우에도 테스트 프로그램을 제대로 종료시킬 수 있다. 
    - 아무것도 없을 때 take 메소드를 호출하면 대기 상태에 들어가야 한다는 것뿐만 아니라 대기중에 인터럽트가 걸리면 InterruptedException을 발생시켜야 한다는 기능도 테스트 가능
    - join 메소드를 사용해 정상적으로 종료되는지를 확인하는 작업은 Runnable 인터페이스를 구현하는 대신 스레드 클래스를 직접 상속받아 사용하는 편이 더 나은 몇 안되는 방법 가운데 하나.
    - 이와같은 방법을 사용하면 테스트 프로그램에서 버퍼에 항목을 직접 추가하면서 항목이 추가되는 시점에 대기 상태에 들어가있던 taker 스레드가 정상적으로 빠져나오는지도 확인 가능
~~~java
public class BoundedBufferTest extends TestCase {
    void testTakeBlocksWhenEmpty() {
        final BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        Thread taker = new Thread() {
            @Override
            public void run() {
                try {
                    int unused = bb.take();
                    fail(); //여기 들어오면 오류    
                } catch (InterruptedException success) {}
            }
        };
        
        try {
            taker.start();
            Thread.sleep(LOCKUP_DETECT_TIMEOUT);
            taker.isInterrupted();
            taker.join(LOCKUP_DETECT_TIMEOUT);
            assertFalse(taker.isAlive());
        } catch (Exception unexcepted) {
            fail();
        }
    }
}
~~~
- Thread.getState 메소드는 믿을만하지 못하다.
- 스레드가 대기 상태에 들어갈 때 JVM의 구현방법에 따라 스핀 대기 기법을 활용할 수도 있으므로, 특정 스레드가 대기 상태에 들어갔다고 해서 항상 드레드가 WAITING또는 TIME_WATING 상태에 놓여있다고 볼 수 없기 때문
- Object.wait 메소드나 Condition.await 메소드에서 정상적이지 않지만 예정보다 일찍 리턴될 수가 있는데 원래 대기하게 된 원인 조건이 해소되지 않았는데도 스레드의 상태가 WAITING또는 TIME_WATING에서 일시적으로 RUNNABLE상태로 전환될 가능성도 있다. 
- 병렬성을 제어하는 용도로 Thread.getState를 사용하지 말아야 한다.

### 12.1.3 안전성 테스트
- 예제 12.2와 예제 12.3은 크기가 제한된 버퍼의 여러가지 속성을 테스트한다.
- 하지만 공유된 데이터를 서로 사용하고자 하는 경쟁하는 데서 발생하는 오류는 제대로 테스트 불가능
- 병렬 처리 환경에서 동작하는 클래스의 기능을 동시 다발적으로 호출할 때 발생하는 문제를 테스트하려면, put 메소드나 take 메소드를 호출하는 여러 개의 스레드를 충분한 시간 동안 동작시킨 다음 테스트 대상 클래스의 상태가 올바른지, 잘못된 값이 들어 있지는 않은지 확인해야 한다.
- 병렬 실행 환경에서 발생하는 오류를 확인하는 프로그램을 작성하다 보면 닭이 먼저냐 달걀이 먼저냐하는 문제에 걸림
- 즉 테스트 프로그램 자체가 병렬프로그램이 되어야 하기 때문.
- 안전성을 테스트하는 프로그램을 효과적으로 작성하려면 뭔가 문제가 발생했을 때 잘못 사용되는 속성을 '높은 확률로' 찾아내는 작업을 해야 함과 동시에 오류를 확인하는 코드가 테스트 대상의 병렬성을 인위적으로 제한해서는 안된다는 점을 고려해야 한다.
- 테스트 하는 대상 속성의 값을 확인할 때 추가적인 동기화 작업을 하지 않아도 된다면 가장 좋은 상태라고 볼 수 있다.
- 방법1 : 프로듀서-컨슈머 디자인 패턴을 사용해 동작하는 클래스에 가장 적합한 방법은 큐나 버퍼에 추가된 항목을 모두 뽑아낼 수 있는지 확인하고, 그 외에는 아무런 일도 하지 않는지 확인하는 방법
    - 테스트 대상과 함께 똑같은 내옹을 담은 제 2의 리스트를 마련해두고, 큐나 버퍼에 항목이 추가될 때 제2의 리스트에도 같은 항목을 추가한다.
    - 큐나 버퍼에서 항목을 제거할 때 제2의 리스트에서도 항목을 제거하고, 큐나 버퍼에서 항목을 모두 제거했을 때 제2의 리스트도 비어있는지를 확인
    - 하지만 이런 방법은 제2의 리스트에 항목을 추가하고 제거하는 과정에 스레드 동기화 작업이 필요하기 때문에 테스트 스레드의 스케쥴링 부분이 약간 꼬여버릴 가능성이 있다.
- 방법2 : 큐에 들어가고 나오는 항목의 체크섬을 구한 다음 순서를 유지하는 체크섬의 형태로 관리하고, 쌓인 체크섬을 비교해 확인하는 방법
    - 체크섬을 비교해 양쪽이 동일하다면 테스트 통과
    - 버퍼에 집어 넣을 항목을 생성하는 프로듀서가 하나만 동작하고 하나의 컨슈머가 버퍼의 내용을 가져다 사용하는 구조에서 가장 효과가 큰 테스트 방법
    - 올바른 항목을 뽑아내는지 테스트하는 것과 더불어 올바른 순서로 항목을 가져오는지도 테스트할 수 있기 때문
    - 다수의 프로듀서와 컨슈머가 연결돼 있는 구조에서 테스트하는 프로그램까지 확장시켜 적용하려면 항목이 추가되는 순서에 상관없는 체크섬 방법을 사용해야 하며, 결국 마지막에 체크섬을 모두 합해 볼 수 있어야 한다.
    - 그렇지 않으면 체크섬을 계산하는 부분을 동기화하느라 확장성 측면에서 병목이 나타날 수 있고, 그러다보면 테스트에 걸린 시간을 제대로 측정할 수 없게 된다. (더하기 연산이나 XOR 연산과 같이 교환 법칙을 만족하는 연산 방법이라면 체크섬 용도로 활용할 수 있겠다.)
    - 작성한 테스트 프로그램이 실제로 원하는 내용을 테스트하는지 확인하려면 사용하고 있는 체크섬 연산을 컴파일러가 예측할 수 ㅇ벗는 연산인지도 확인해야 한다.
    - ex : 테스트용 데이터로 일련번호를 사용하면 결과가 항상 동일, 컴파일러가 최적화를 충분히 할 수 있는 능력이 된다면 결과를 미리 계산해 버릴수도 있다.
    - 너무 똑똑한 컴파일러 때문에 발생하는 문제를 해결하려면 테스트에 사용할 데이터를 일련번호 대신 임의의 숫자를 생성해 사용해야 한다. 하지만 너무 허술한 난수 발생기를 사용하면 이 또한 테스트 결과가 잘못 나올 수 있다.
    - 허술한 난수 발생기는 현재 시간과 클래스 간에 종속성이 있는 난수를 생성하는 경우가 있는데, 대부분의 난수 발생기가 스레드 안전성을 확보한 상태이고 추가적인 동기화 작업이 필요하기 때문이다.
    - 각 테스트 스레드마다 독립적인 난수 발생기 인스턴스를 사용하도록 하면 스레드 안전성 때문에 동기화하느라 성능의 병목을 야기하는 경우를 막을 수 있다.
    - 범용 난수 발생기를 사용하는 대신 아주 간단한 난수 발생기를 사용하는 것도 좋은 방법.
    - 테스트 프로그램을 실행할 때마다 어느 정도 적절한 임의성만 확보하면 된다.
- 예제 12.4 테스트 프로그램에 적합한 중간 품질의 난수 생성기
    - 싼값에 중급의 품질을 제공하는 난수 발생기,
    - 클래스 인스턴스의 hashCode 값과 nanoTime값을 사용해 xorShift 메소드를 사용하면 거의 예측할 수 없을 뿐더라 실행할 때마다 난수 생성 가능
~~~
static int xorShift(int y) {
    y ^= (y << 6);
    y ^= (y >>> 21);
    y ^= (y << 7);
    return y;
}
~~~ 
- 예제 12.5와 예제 12.6의 PutTakeTest 클래스는 항목을 생성하는 큐에 쌓는 프로듀서 스레드를 N개 생성해 실행시키고, 큐에 쌓인 항목을 뽑아내는 N개의 컨슈머 스레드를 역시 생성해 실행한다.
- 예제 12.5 BoundedBuffer 를 테스트하는 프로듀서-컨슈머 구조의 테스트 프로그램, 예제 12.6 PutTakeTest에서 사용한 프로듀서 클래스와 컨슈머 클래스
    - 항목을 생성해서 큐에 쌓는 프로듀서 스레드를 N개 생성해 실행시키고, 큐에 쌓인 항목을 뽑아내는 N개의 컨슈머 스레드를 생성해 실행
    - 각 스레드는 큐에 항목을 추가하거나 제거할 때마다 각 스레드마다 나눠져 있는 각자의 체크섬을 업데이트 하고, 각자의 체크섬은 테스트가 끝나는 시점에 하나로 합해 결과가 올바른지 테스트한다.
    - 각 스레드마다 체크섬을 따로 운영하면 따로 동기화할 필요도 없고 따라서 경쟁이 발생하지 않으므로 실제로 원하는 테스트에만 집중 가능
~~~java
public class PutTakeTest {
    private static final ExecutorService pool = Executors.newCachedThreadPool();
    private final AtomicInteger putSum = new AtomicInteger(0);
    private final AtomicInteger takeSum = new AtomicInteger(0);
    private final CyclicBarrier barrier;
    private final BoundedBuffer<Integer> bb;
    private final int nTrials, nPairs;

    public static void main(String[] args) {
        new PutTakeTest(10, 10, 10000).test(); // 예제 인자 값
        pool.shutdown();
    }

    PutTakeTest(int capacity, int nPairs, int nTrials) {
        this.bb = new BoundedBuffer<Integer>(capacity);
        this.nPairs = nPairs;
        this.nTrials = nTrials;
        this.barrier = new CyclicBarrier(nPairs * 2 + 1);
    }

    void test() {
        try {
            IntStream.range(0, nPairs)
                    .forEach(i -> {
                        pool.execute(new Producer());
                        pool.execute(new Consumer());
                    });
            barrier.await(); // 모든 스레드가 준비될 때까지 대기
            barrier.await(); // 모든 스레드의 작업이 끝날 때까지 대기
            assertEquals(putSum.get(), takeSum.get());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    class Producer implements Runnable {
        @Override
        public void run() {
            try {
                int seed = (this.hashCode() ^ (int) System.nanoTime());
                int sum = 0;
                barrier.await();
                for(int i = nTrials; i > 0; --i) {
                    bb.put(seed);
                    sum += seed;
                    seed = xorShift(seed);
                }
                putSum.getAndAdd(sum);
                barrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    class Consumer implements Runnable {
        @Override
        public void run() {
            try {
                barrier.await();
                int sum = 0;
                for(int i = nTrials; i > 0; --i) {
                    sum += bb.take();
                }
                takeSum.getAndAdd(sum);
                barrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
~~~ 
- 플랫폼마다 다르지만 스레드를 생성하고 실행하는 일이 상당히 부하가 걸리는 작업일 가능성도 있다.
- 스레드가 처리할 작업이 굉장히 짧은 시간이면 충분한 작업일 때 이와 같은 스레드를 반복문 내부에서 차례로 생성해 실행시킨다면 결국 최악의 경우 각 스레드가 병렬로 실행되는 대신 순차적으로 실행될 가능성도 있다.
    - ex : 최초에 실해오딘 스레드는 한동안 혼자만 실행될 것이고, 그 다음 스레드가 실행되면 일부분만 두 개의 스레드가 함께 실행되며, 마지막 스레드까지 모두 실행된 이후에야 스레드가 병렬로 동작하게 된다.
- 이와 같은 문제의 해결 방법은 CountDownLatch 사용해 모든 스레드가 준비될 때까지 대기하고 또 다른 CountDownLatch를 사용해 스레드가 완료될 때까지 대기하기
- CyclicBarrir를 사용해도 이와 같은 효과 가능
    - 작전체 작업 스레드의 개수에 1을 더한 크기로 초기화해두고, 작업 스레드와 테스트 프로그램이 시작하는 시점에 모두 동시에 시작할 수 있도록 대기하고, 끝나는 시점에도 한꺼번에 끝내도록 대기하는 방법
- PutTakeTest 역시 이와 같은 방법을 사용해 작업 스레드가 한꺼번에 시작하고 한꺼번에 종료하도록 하고 있으며 여러 개의 스레드가 병렬로 처리되는 상황을 훨씬 자 ㄹ묘사할 수 있다.
- 그렇다 해도 그 내부에서 스케쥴러가 작업 스레드를 순차적으로 실행시키지 않는다는 보장은 없다.
- PutTakeTest 에 적용돼 있는 마지막 테크닉은 테스트가 끝났음을 알리느라 스레드 간에 통신 기능을 구현하는 대신, 테스트가 시작할 때 이미 종료 조건을 결정지어두는 방법
- test 메소드가 시작되면 동일한 숫자의 프로듀서와 컨슈머가 생성된다.
- 각 프로듀서는 항목을 추가하고, 각 컨슈머는 항목을 뽑아내기 때문에 전체적으로 추가된 항목의 수와 제거된 항목의 수는 일치한다.
- PutTakeTest 와 같은 유형의 테스트 프로그램은 테스트 대상의 안전성을 확인하기에 좋다.
    - ex : 세마포어로 제어하는 버퍼를 구현할 때 범하기 쉬운 오류 중의 하나는 바로 항목을 추가하거나 뽑아내는 작업이 상호 배타적인 상태에서 이뤄져야 한다는 점을 잊은 채 동기화를 빼먹고 구현하는 부분이다.
    - 만약 doInsert와 doExtract 메소드의 동기화 구분을 빼먹은 버전의 BoundedBuffer 를 대상으로 PutTakeTest 프로그램을 돌려보면 오류 찾기 바로 가능
    - 따라서 수십개의 스레드를 사용하도록 설정하고, 각 스레드마다 수백 만개의 put 또는 take 연산을 실행하도록 하며, 버퍼의 크기도 다양하게 지정해보고, 다양한 플랫폼에서 PutTakeTest 프로그램으로 테스트를 거친다면 완벽한 결과 얻는다.
- 테스트 프로그램은 스레드가 교차 실행되는 경우의 수를 최대한 많이 확보할 수 있도록 CPU가 여러 개 장착된 시스템에서 돌려보는게 좋다. 그렇다고 CPU가 수십개 달렸다고 해서 서너 개의 CPU가 장착된 시스템에 비해 테스트 효율이 좋다고 보기는 어렵다.
- 절묘한 타이밍에 공유된 데이터를 사용하다 나타나는 오류를 찾으려면 CPU가 많이 있는 것보다 스레드를 더 많이 돌리는 편이 낫다. 스레드가 많아지면 실행중인 스레드와 대기 상태에 들어간 스레드가 서로 교차하면서 스레드 간의 상호 작요잉 발생하는 경우의 수가 많아지기 때문이다.
- 미리 지정된 개수만큼의 연산을 실행하고 테스트를 마치는 프로글매은 테스트 도중에 테스트 대상 클래스의 버그로 인해 예외가 발생하는 등의 상황에 맞닥뜨리면 테스트 프로그램이 종료되지 않고 계속해서 실행될 가능성이 있다.
- 이런 위험을 방지할 수 있는 가장 간편한 방법은 테스트 프로그램이 동작하는 시간에 제한을 두고 제한된 시간이 넘어가도 프로그램이 종료되지 않으면 테스트를 중단하는 방법
- 제한시간을 넘기는 문제가 발생한다면 실제로 프로그램에 오류가 있는 것인지 아니면 좀 더 오래 기다렸어야 하는지를 분석해서 확인해야 한다.

### 12.1.4 자원 관리 테스트
- 테스트 프로그램을 테스트하고자 하는 두 번째 측면은 하지 말아야 할 일을 실제로 하지 않는지 테스트 하는 일(ex : 자원을 유출하는 일, 다른 객체를 사용하거나 관리하는 모든 객체는 더 이상 필요하지 않는 객체ㄴ에 대한 참조를 갖고 있으면 안됨.)
- 이처럼 데이터를 갖고 있는 객체의 참조를 해체하지 않고 유출되면 GC가 메모리(또는 스레드, 파일 핸들, 네트워크 소켓, DB연결 등의 제한적인 자원)를 확보할 수 없다. 그럼 오류 발생
- 자원을 관리하는 문제는 BoundedBuffer 와 같은 클래스에서는 더욱 큰 문제이다.
    - 버퍼의 크기를 제한하는 이유는 오로지 프로듀서가 컨슈머보다 빨리 동작해서 자원이 고갈되는 상황을 방지하고자 하는 것.
    - 버퍼의 크기를 제한해두면 너무 활발하게 동작하는 프로듀서의 활동을 필요한 만큼 멈추도록 할 수 있으며, 그 결과 메모리와 기타 자원 소모 방지
- 메모리를 원하지 않음에도 계쏙해서 잡고 있는 경우가 있는지 확인하려면 애플리케이션이 사용하는 메모리의 상황을 들여다 볼 수 있는 힙 조사용 도구를 사용해볼만 한다.
- 예제 12.7 자원 유출 테스트
~~~java
public class Test {
    class Big {
            double[] data = new double[10000];
    }
    
    void teskLeadk() throws InterruptedException {
        BoundedBuffer<Big> bb = new BoundedBuffer<Big>(CAPACITY);
        int heapSize1 = /* 힙 스냅샷 */ ;
        for(int i = 0; i < CAPACITY; i++) {
            bb.put(new Big());
        }
        
        for(int i = 0; i < CAPACITY; i++) {
            bb.take();
        }
        
        int heapSize2 = /* 힙 스냅샷 */ ;
        
        assertTrue(Math.abs(heapSize1 - heapSize2) < THRESHOLD);
    }
}
~~~
- 12.7의 takeLeak 메소드는 크기가 제한된 버퍼에 상당한 메모리를 차지하는 객체를 여러 개 추가하고, 추가된 객체를 제거한다.
- 그러면 버퍼에는 아무런 내용이 없기 때문에 2번 자리에서 측정한 메모리 사용량이 1번 위치에서 측정한 메모리 사용량과 비교할 때 거의 차이가 없어야 한다.
- 해당하는 위치에는 힙 조사 도구가 생성한 코드가 들어가는데, 힙 조사 도구가 추가한 코드는 GC를 강제로 실행하고 힙 사용량과 기타 메모리 사용 현황을 불러오는 기능 담당.
- takeLeak 메소드는 크기가 제한된 버퍼에 상당한 메모리를 차지하는 객체를 여러 개 추가하고, 추가된 객체를 제거
    - 만약에 doExtract 메소드에서 뽑혀 나간 객체를 담고 있던 부분의 참조를 null로 세팅하지 않았다면 양쪽 지점에서 측정한 메모리 사용량이 분명히 다를 것이다.

### 12.1.5 콜백 사용
- 클라이언트가 제공하는 코드에 콜백 구조를 적용하면 테스트 케이스를 구현하는 데 도움이 된다.
- 콜백 함수는 객체를 사용하는 동안 중요한 시점마다 그 내부의 값을 확인시켜주는 좋은 기회로 사용할 수 있다.
- ThreadPoolExecutor 클래스가 작업을 담당하는 Runnable과 스레드를 생ㅅ어하는 ThreadFactory의 여러 콜백 함수를 호출하는 예를 보면 알기 쉽다.
- 스레드 풀이 제대로 동작하는지 테스트하려면 실행 정책에 맞게 여러 측면에서 적절한 수치를 뽑아낼 수 있는지를 테스트하면 된다.
    - ex : 스레드를 생성해야 할 시점이라면 스레드가 생성되어야 함.
    - 스레드 생성 시점이 아니라면 스레드가 생성되면 안됨.
- 원하는 기능 모두를 완벽하게 테스트할 수 있는 프로그램을 작성하려면 상당한 양의 노력을 들여야 한다. 
- 하지만 테스트하고자 하는 기능 가운데 대부분은 그 테스트 프로그램을 상대적으로 간단하게 작성할 수 있는 경우가 많다.
- 먼저 ThreadPoolExecutor 클래스에서 테스트용으로 작성한 TestingThreadFactory 를 사용해 스레드 생성해보기
- 예제 12.8 ThreadPoolExecutor를 테스트하기 위한 TestingThreadFactory
~~~java
public class Example12_8 {
    class TestingThreadFactory implements ThreadFactory {
        public final AtomicInteger numCreated = new AtomicInteger(); // 생성된 스레드의 개수 세는 기능
        private final ThreadFactory factory = Executors.defaultThreadFactory();
        
        @Override
        public Thread newThread(Runnable r) {
            numCreated.incrementAndGet();
            return factory.newThread(r);
        }
    }
}
~~~
- 실제 테스트 케이스에서는 TestingThreadFactory가 알고 있는 스레드의 개수가 올바른지 확인해볼 수 있다.
- 이에 더해 기능이 추가된 Thread객체를 생성하도록 TestingThreadFactory 를 좀 더 변경하면 생성된 스레드가 언제 종료되는지를 추적할 수 있다.
    - 테스트 케이스는 없어져야 할 스레드가 적절한 시점에 올바르게 사라졌는지도 확인 가능
- ex : 코어 풀 크기가 최대 풀 크기보다 작에 설정돼 있다면 실행할 대상이 늘어날 때마다 스레드의 개수가 함께 늘어나야 한다.
- 스레드 풀에 오래 실행될 작업을 많이 추가해두면 예제 12.9에서 보다시피 스레드 개수가 올바르게 늘어나는지 등의 수치를 확인하기에 충분할 만큼 어느정도 시간을 벌어주는 역할을 한다.
- 예제 12.9 스레드 풀의 개수가 제대로 늘어나는지를 확인할 수 잇는 테스트 케이스
~~~java
public class Example12_9 extends TestCase {
    public void testPoolExpansion() throws InterruptedException  {
        int MAX_SIZE = 10;
        Example12_8.TestingThreadFactory threadFactory = new Example12_8.TestingThreadFactory();
        ExecutorService exec = Executors.newFixedThreadPool(MAX_SIZE, threadFactory);
        
        for(int i = 0; i < 10 * MAX_SIZE; i++) {
            exec.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(Long.MAX_VALUE);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        
        for(int i = 0; i < 20 && threadFactory.numCreated.get() < MAX_SIZE; i++) {
            Thread.sleep(100);
        }
        
        assertEquals(threadFactory.numCreated.get(), MAX_SIZE);
        exec.shutdownNow();
    }
}
~~~
### 12.1.6 스레드 교차 실행량 확대
- 병렬 프로그램에서 나타나는 오류의 대부분 발생 확률이 상당히 낮은 경우가 ㅁ낳다.
- 따라서 병렬 프로그램의 오류를 찾아내는 테스트 과정은 수치와의 싸움이지만, 확률을 높이는 방법이 있다.
- 이미 몇 개의 CPU 프로세서가 장착된 하드웨어에서 CPU의 개수보다 많은 수의 스레드로 동작하는 프로그램이 단일 CPU 하드웨어나 CPU의 개수가 많은 하드웨어에서 동작하는 프로그램보다 교차 실행되는 양이 많다.
- 이와 비슷하게 CPu 프로세서의 개수, 운영체제, 프로세서 아키텍쳐 등을 다양하게 변경하면서 테스트해보면 특정 시스템에서만 발생하는 오류 찾아낼 수 있다.
- 스레드의 교차 실행 정도를 크게 높이고 그와 동시에 테스트할 대상 공간을 크게 확대시킬 수 있는 트릭이 있는데, 공유된 자원을 사용하는 부분에서 Thread.yeild 메소드를 호출해 컨텍스트 스위치가 많이 발생하도록 유도하기.
- 예제 12.10에서 나타난 코드를 보면 한쪽 계좌에서 일정 금액을 다른 계좌로 이체하는데 값을 변경하는 두 번의 연산 가운데 "양쪽 계좌 잔액의 합은 항상 0이다" 라는 명제가 일치하지 않는 시점이 존재
    - 작업 도중에 Thread.yeild 메소드를 호출해주면 동기화 방법을 사용하지 않는 경우 발생할수 있는 버그가 실제로 노출되는 가능성을 높일 수 있다.
    - Thread.yeild와 같이 테스트때는 사용하다가 상용으로 사용할때는 해당 코드를 제거해야 하는 경우에는 관점 지향 프로그래밍 기법으로 간편하게 처리 가능
- 예제 12.10 Thread.yeild 메소드를 사용해 교차 실행 가능성을 높이는 방법
~~~java
public class Example12_10 {
    public synchronized void transferCredis(Account from, Account to, int amount) {
        from.setBalance(from.getBalance - amount);
        if(random.nextInt(1000) > THREADHOLD) {
            Thread.yield();
        }
        to.setBalance(to.getBalance + amount);
    }
}
~~~
## 12.2 성능테스트
- 성능 테스트 프로그램은 대부분 기능 테스트의 확장된 버전인 경우가 많다.
- 오류가 있는 코드의 성능을 테스트하는 우스운 상황을 미연에 방지하려면 성능 테스트 프로그램에 최소한의 기본적인 기능 테스트 코드를 추가해 두는 것도 좋은 방법
- 성능 테스트와 기능 테스트 프로그램 간에는 중복되는 부분이 있을 수밖에 없기는 하지만 양쪽의 목표는 확연하게 다르다. 
    - 성능테스트의 목적 1 : 특정한 사용 환경 시나리오를 정해두고, 해당 시나리오를 통과하는데 얼마만큼의 시간이 걸리는지 측정하는게 목적
    - 의미가 있는 사용 환경 시나리오를 찾아내는 일은 어렵다. 가장 이상적인 시나리오라면 테스트하고자 하는 대상 클래스가 실제 애플리케이션에서 사용되는 환경을 최대한 동일하게 반영해야 한다.    
    - 성능테스트의 목적 2 : 성능과 관련된 스레드의 개수, 버퍼의 크기 등 각종 수치를 뽑아내고자 함. 

### 12.2.1 PutTakeTest에 시잔 측정 부분 추가
- 단일연산을 실행한 이후 해당 연산에 대한 시간을 구하기보다는 단일 연산을 굉장히 많이 실행시켜 전체 실행 시간을 구한 다음 실행했던 연산의 개수로 나눠 단일 연산을 실행하는데 걸린 평균 시간을 찾는 방법이 더 정확
- 작업 스레드가 시작하고 종료하는 부분에 이미 CyclicBarrier를 적용했기 때문에 예제 12.11과 같이 배리어가 적용되는 부분에서 시작 시간과 종료 시간을 측정할 수 있도록 기존 클래스를 확장할 수 있다.
- 예제 12.11 배리어 기반의 타이머
~~~java
public class BarrierTimer implements Runnable{
    private boolean started;
    private long startTime, endTime;
    
    @Override
    public synchronized void run() {
        long t = System.nanoTime();
        if(!started) {
            started = true;
            startTime = t;
        } else {
            endTime = t;
        }
    }
    
    public synchronized void clear() {
        started = false;
    }
    
    public synchronized long getTime() {
        return endTime - startTime;
    }
}
~~~
- 배리어에서 시간을 측정하는 기능을 갖고 있는 배리어 액션을 사용하도록 하려면 CyclicBarrier를 초기화는 부분에 다음와 같이 원하는 배리어 액션을 지정한다.
~~~
this.timer = new BarrierTimer();
this.barrier = new CyclicBarrier(npairs * 2 + 1, timer);
~~~ 
- 배리어 기반 타이머를 사용하도록 변경한 클래스는 예제 12.12에서 볼 수 있다. 
- 예제 12.12 배리어 기반 타이머를 사용한 테스트
~~~java
public class TimedPutTakeTest {
    //...
    // this.timer = new BarrierTimer();
    // this.barrier = new CyclicBarrier(npairs * 2 + 1, timer);

    public void test() {
        try {
            timer.clear();
            for(int i = 0; i < nPairs; i++) {
                pool.execute(new Producer());
                pool.execute(new Consumer());
            }
            barrier.await();
            barrier.await();
            long nsPerItem = timer.getTime() / (nPairs * (long) nTrials);
            System.out.println("Throughput : " + nsPerItem + " ns/item");
            assertEquals(putSum.get(), takeSum.get());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
~~~

- TimedPutTakeTest를 실행해보면 몇 가지 결과를 얻을 수 있다.
    - 1. 여러 가지 설정을 사용했을 때 프로듀서와 컨슈머 간에 데이터를 얼마나 빠르게 넘겨줄 수 있느냐 하는 수치.
    - 2. 스레드의 개수가 많아질 때 크기가 제한된 버퍼가 얼마나 확장성을 받쳐주는지
    - 3. 버퍼의 크기를 얼마로 제한해야 최고의 성능을 내는지
- 여러가지 인자에 다양한 값을 설정하면서 테스트 프로그램을 실행해봐야 한다. 예제 12.13과 같은 프로그램 사용시 편리
- 예제 12.13 TimedPutTakeTest 실행 프로그램
~~~java
public class TimedPutTakeTest {
    // ...
    public static void main(String[] args) throws Exception{
        int tpt = 100000; //스레드별 실행 횟수
        for(int cap = 1; cap <= 1000; cap *= 10) {
            System.out.println("Capacity : " + cap);
            for(int pairs = 1;  pairs <= 128; pairs *= 2) {
                TimedPutTakeTest t = new TimedPutTakeTest(cap, pairs, tpt);
                System.out.print("Pairs: "+ pairs + "\t");
                t.test();
                System.out.print("\t");
                Thread.sleep(1000);
                t.test();
                System.out.println();
                Thread.sleep(1000);
            }
        }
        pool.shutdown();
    }    

}
~~~
- 그림 12.1을 보면 CPU가 4개 장착된 하드웨어에서 버퍼의 크리를 1, 10, 100, 1000으로 변경하면서 실행한 결과가 그래프로 나타나있다.
- 버퍼 크기를 1로 지정한 경우에는 성능이 크게 떨어짐(각 스레드가 대기 상태로 들어가고 나오면서 아주 작은 작업밖에 할 수 없기 때문)
- 버퍼의 크기를 늘려주면 성능은 빠르게 증가하지만 10을 넘는 크기를 지정하면 버퍼의 크기에 비해 성능이 향상되는 정도가 떨어지는 것을 볼 수 있다.
- 스레드의 개수를 크게 늘린다 해도 성능이 별로 떨어지지 않는 이유는 테스트 프로그램의 결과로는 이해하기 어렵고, 테스트 프로그램이 실행되는 동안 perfbar등의 유틸리티를 사용해 CPU의 성능을 보다 보면 쉽게 이해 가능
- 스레드가 많이 실행되고 있다 하더라도, 실제 작업을 하는 양은 그다지 많지 않고 대신 스레드가 대기 상태에 들어갔다 나왔다 하는 동기화를 맞추느라 CPU 용량의 대부분을 사용하기 때문이다.
- 그러다보니 더 많은 스레드를 사용해 동일한 작업을 처리하도록 해도 성능에는 별 악영향이 없다는 섣부른 판단을 내리는 경우도 많다.
- 하지만 이와 같은 결과를 놓고 크기가 제한된 버퍼를 사용하는 프로듀서-컨슈머 패턴의 구조라면 언제든지 스레드를 추가해도 좋다는 방향으로 해석하기 전에 조심해야 한다.
    - 사용했던 테스트 프로그램이 너무나 인공적으로 만들어졌기 때문
- 프로듀서는 큐에 쌓을 항목을 생성할 때 거의 아무런 작업 없이 객체만 생성한다.
- 컨슈머 역시 큐에서 가져온 항목을 사용한다는 말이 무색할 정도로 아무 작업을 하지 않는다.
- 프로듀서-컨슈머 패턴은 실제로 항목을 생성하고 사용하는과정에서 상당히 많은 양의 작업을 진행할 것이다.
- 그러면 테스트 프로그램에서 봤던 여유가 줄어들 것이며 스레드를 너무 많이 추가했다는 여파를 눈으로 확인 가능
- TimedPutTakeTest의 주 목적은 프로듀서-컨슈머 패턴의 프로그램에서 프로듀서와 컨슈머 간에 값을 넘겨줄 때 얼마만큼의 성능을 낼 수 있는지, 병목이 있다면 어디에 있는지를 알아내는 정도에 그친다.

### 12.2.2 다양한 알고리즘 비교
- BoundedBuffer 클래스는 잘 구현돼 있지만 ArrayBlockingQueue나 LinkedBlockingQueue 등의 클래스에 비해 성능이 떨어진다.
- java.util.concurrent 패키지에 포함돼 있는 클래스의 알고리즘은 주의 깊게 선택하고 튜닝돼 이다.
- BoundedBuffer 클래스의 속도가 떨어지는 가장 큰 이유는 바로 put과 take연산 양쪽에서 모두 스레드 경쟁을 유발할 수 있는 연산을 사용하기 때문
    - ex : 세마포어를 확보하거나, 락을 확보하거고 세마포어를 다시 해제하는 연산 등
- 고성능 클래스는 경쟁유발이 적다.
- 그림 12.2의 경우 TimedPutTakeTest 프로그램을 약간 변형시키고 듀얼 하이퍼스레드 CPU가 장착된 하드웨어에서 버퍼 크기가 256인 클래스 3개를 비교 실행한 결과이다.
- 테스트 결과를 보면 LinkedBlockigQueue 클래스가 ArrayBlockingQueue보다 확장성이 약간 더 좋다고 보이는데, 언뜻 생각하기에는 약간 이상한 결과
- 연결 큐는 새로운 항목을 추가할 때마다 버퍼 항목을 메모리에 새로 할당받아야 하며, 따라서 배열 기반의 큐보다 더 많은 일을 해야 하기 때문이다.
- 그런데 객체를 할당하는 부하가 더 크고 가비지 컬렉션에도 부하가 더 걸린다고 해도, 잘 튜닝된 연결리스트 알고리즘을 사용하면 큐의 처음과 끝 부분에 서로 다른 스레드가 동시에 접근해 사용할 수 있다.
- 따라서 연결리스트 기반의 큐는 put과 take 연산에 대해서 배열 기반의 큐보다 병렬 처리 환경에서 훨씬 안정적으로 동작
- 그리고 메모리 할당 작업은 스레드 내부에서 한정돼 있기 때문에 메모리를 할당한다 해도 스레드 간의 경쟁을 줄일 수 있는 알고리즘의 확장성이 더 높을 수밖에 없다.

### 12.2.3 응답성 측정
- 일부 상황에서는 단일 작업을 처리하는데 얼마만큼의 시간이 걸리는지를 측정하는 일이 더 중요할 수도 있다.
- 단일 처리 시간을 측정할 때는 보통 측정 값의 분산을 중요한 수치로 생각한다.
- 평균 처리 시간은 길지만 처리 시간의 분산이 작은 값을 유지하는 일이 더 중요할 수 있기 때문
- 즉 예층성 역시 성능 지표 가운데 중요한 하나
- 처리시간에 대한 분산 = 100밀리 초 안에 작업을 끝내는 비율이 몇%정도인가?와 같은 서비스 품질에 대한 수치를 결과로 제시
- 서비스 시간에 대한 분산을 시각적으로 표현할 수 있는 효과적인 방법 = 작업을 처리하는데 걸린 시간을 히스토그램으료 그리기
- 분산은 평균을 구하는 것보다 조금 더 복잡한 난이도이다. 작업 처리 시간을 모두 더할 뿐만 아니라 각 처리 시간을 목록으로 관리해야 한다.
- 그런데 개별 작업을 처리하는 속도가 아주 빠르다면 통계 값에 오류가 생기기 쉽다. 
    - ex: 컴퓨터가 갖고 있는 시간 측정의 최소 단위와 비슷한 시간 안에 작업을 처리할 수 있다면 작업 처리 시간을 제대로 측정할 수 없다.
- 이런 오류를 방지할 수 있도록 put과 take 등의 연산을 일정 개수로 묶어 일괄 처리하고, 일괄 처리하는데 걸린 시간을 하나의 작업 시간으로 묶어서 생각하자.
- 그림 12.3을 보면 버퍼의 크리를 1000으로 지정하고 256개의 병렬 작업이 각각 1000개의 항목을 버퍼에 넣는데, 한쪽은 공정한 세마포어를 사용하고 다른쪽은 불공정 세마포어를 사용해 테스트한 결과가 나타나 있다.
- 불공정한 방법을 사용한 테스트 결과에는 작업 처리 시간이 최소 104밀리초에서 최대 8,714초까지 걸렸다. 최대와 최소 시간 차 80배가 넘음
- 최소 시간과 최대 시간의 차이를 줄이려면 동기화 코드에 공정성을 높이면 된다. Boundedbuffer의 경우 세마포어를 생성할 때 공정한 모드로 초기화시켜 공정성을 높일 수 있다.
- 동기화 부분에 공정성을 높이고 나면 처리 시간의 분산 값을 엄정나게 줄여주는 효과를 볼 수 있지만 처리 속도가 떨어지는 역효과를 가져온다.
- 만약 버퍼 크기를 굉장히 작게 잡고 사용한다면 매번 연산마다 모두 컨텍스트 스위칭이 발생하고, 부하가 늘어나서 결국 불공정 동기화 방법을 사용한다 해도 실행 속도가 크게 느려진다는 사실을 살펴본 바 있다.
- 공정하기 때문에 속도가 느려지는 상황은 스레드가 대기 상태로 들어가기 때문이라고 생각할 수 있다.
- 이번 테스트에서 버퍼 크기를 1로 지정하고 다시 실행해보면 불공정 세마포어를 사용해도 공정한 세마포어를 사용한 경우와 거의 비슷한 속도로 느려진다는 결과를 얻는다.
- 그림 12.4를 보면 이 경우에 공정함의 문제가 평균 실행 시간을 크게 늦추가너 실행시간의 분산을 훨씬 낮게 바꿔주지는 못한다는 사실이 나타나있다.
- 결국 스레드가 아주 빡빡한 동기화 요구사항 때문에 계속해서 대기 상태에 들어가는 상황이 아니라면 불공정한 세마포어를 사용해 처리 속도를 크게 높일 수 있고, 반대로 공정한 세마포어를 사용해 처리 시간의 분산을 낮출 수 있다.
- 공정성 문제로 속도가 빨라지거나 분산 값이 줄어드는 정도가 굉장히 심한 편이기 때문에 세마포어를 사용할 때는 항상 어느 방법을 사용할 것인지 결정해야만 한다.

## 12.3 성능 측정의 함정 피하기
- 이론적으로 성능 테스트 프로그램을 작성하는 일은 그다지 어렵지 않다. 일반적인 사용 시나리오를 알아보고, 알아냄 사용 시나리오를 여러 차례 실행시키고, 실행하는데 걸린 시간을 측정하면 된다.
- 하지만 실제로 테스트 프로그램을 작성할 때는 성능을 올바로 나타내지 못하는 잘못된 수치를 뽑아내는 잘못된 코딩 방법으로 프로그램을 작성하지 않도록 주의해야 한다.

### 12.3.1 가비지 컬렉션
- 가비지 컬렉션이 언제 실행될것인지는 미리 알고 있을 수가 없으며, 따라서 시간을 측정하는 테스트 프로그램이 동작하는 동안 가비지 컬렉션 작업이 진행될 가능성도 높다. 
- 테스트 프로그램이 총 N번의 작업을 실행하는데 N번의 작업이 실해는 동안은 가비지 컬렉션이 진행되지 않는다 해도 N+1번째에 가비지 컬렉션이 진행될 수도 있다.
- 따라서 테스트 실행 횟루를 살짝 변경하기만 해도 테스트당 실행시간은 엉터리 값으로 바뀔 수 있다. 
- 가비지 컬렉션 때문에 테스트 결과가 올바르지 않게 나오는 경우를 막을수 있는 방법 2가지
    - 1. 먼저 테스트가 진행되는 동안 가비지 컬렉션 작업이 실행되지 않도록 하는 방법
    - 2. 테스트가 진행되는 동안 가비지 컬렉션이 여러번 실행된다는 사실을 명확히하고 테스트 결과에 객체 생성 부분이나 가비지 컬렉션 부분을 적절하게 반영하도록 하는 방법
- 일반적으로 2번 방법이 많이 사용되는데, 테스트 프로그램을 훨씬 긴 시간동안 실행할수 있으며 실제 상황에서 나타나는 성능을 좀 더 가깝게 반영하기 때문
- 프로듀서-컨슈머 패턴으로 구성된 대부분의 애플리케이션은 상당한 양의 객체를 메모리에 할당하고 가비지 컬렉션 부하도 큰 편이다. 
- 프로듀서는 계속해서 큐에 쌓을 항목을 생성해내고, 컨슈머는 큐에서 뽑아낸 항목을 사용하는 구조이기에 어쩔 수 없다.
- 따라서 BoundedBuffer 클래스를 대상으로 테스트 프로그램을 적당히 오랜시간 동안 동작시키면 일정 횟수 이상 가비지 컬렉션이 동작할 것이며, 실제 적용할 때와 유사한 성능 결과를 얻을 수 있겠다.

### 12.3.2 동적 컴파일
- 자바 언어와 같이 동적으로 컴파일하면서 실행되는 언어로 작성된 프로그램은 C나 C++과 같이 정적으로 컴파일된 상태에서 실행되는 언으로 만들어진 프로그램보다 그 성능을 측정하는 테스트 프로그램을 작성하기도 어렵거니와 결과로 해석하기도 어려운 측면이 이다.
- 핫스팟JVM이나 기타 최근 사용되는 JVM은 바이트코드 인터프리트 방식과 동적컴파일 방법을 혼용해 사용한다.
- ex : 클래스의 바이트 코드를 처음 읽어들인 이후에는 인터프리터를 통해 바이트 코드를 실행한다. 그리고 일정 시점이 지난 이후 메소드가 특정 횟수 이상 자주 실행된다는 판단이 들면 동적 컴파일러가 해당 메소드를 기계어 코드로 컴파일한다.
- 컴파일이 완료되면 그 이후에는 인터프리트하는 대신 컴파일된 코드를 직접 실행시킨다.
- 그런데 컴파일 작업이 언제 실행되는지는 알 수 없다. 
- 실행 시간을 측정하는 테스트 프로그램은 대상 클래스의 코드가 모두 컴파일된 이후에 실행돼야 마땅하다. 대부분의 애플리케이션은 실제 사용할 때 필요한 거의 모든 메소드가 컴파일된 상태에서 실행된다고 봐야 하는데, 이런 상황에서 인터프리트되는 코드의 실행속도는 측정할 가치가 거의 없기 때문이다.
- 하지만 테스트 프로그램이 시간을 측정하는 도중에 컴파일러가 동적으로 메소드 코드를 컴파일하도록 놔둔다면 두 가지 측면에서 테스트 결과에 오류가 생길 가능성이 있다.
    - 1. 컴파일하는 과정에서 CPU를 상당 부분 소모할 것이 분명하다
    - 2. 인터프리트되는 코드와 컴파일된 코드, 컴파일하는 시간을 모두 테스트 결과에 포함시키면 일관성이 부족한 결과 값을 얻을 수 밖에 없다.
- 그림 12.5를 보면 동적 컴파일과 관련한 여러가지 요소가 테스트 결과 값을 어떠헥 뒤섞어 놓는지 알 수 있다.
- 그림 12.5에 나타난 세 가지 항목은 각각의 조건에서 동일한 횟수의 테스트 모듈을 실행하는 과정을 보여준다. 
- A는 컴파일하지 않고 계속해서 인터프리터로 실행하는 모습
- B는 인터프리터로 실행하다 중간에 컴파일해 실행되는 모습
- C는 B보다 먼저 컴파일을 진행하고 실행되는 모습
- 보다시피 컴파일 작업이 언제 실행되는지가 전체 실행 시간에 큰 영향을 미치고, 그에 따라 단일 연산에 소모되는 시간 역시 영향을 미친다.
- 컴파일된 프로그램 코드는 때에 따라 디컴파일 하고 다시 재컴파일하는 과정을 거치는 경우도 있다.
    - ex: 이전 컴파일 과정에서 가정했던 사항이 변경됐거나 실제로 실행해보면서 얻는 성능 평가 결과를 놓고 다른 최적화 방법을 적용해 다시 컴파일 하기도 한다.
- 컴파일된 코드와 컴파일되지 않은 코드 때문에 성능 측정치가 올바르지 않게 나타나는 상황을 예방하는 가장 간단한 방법은 테스트 프로그램을 긴 시간 동안 실행시켜 컴파일될 모든 부분은 컴파일되고, 추가로 컴파일하거나 인터프리터로 실행되는 코들르 최소화하는 방법이다.
- 또 다른 방법으로는 시간을 측정하지 않는 '워밍업' 하는 테스트를 한 번 미리 실행시켜 필요한 코드를 모두 컴파일시키고, 그 이후에 시간을 측정하는 실제 테스트 프로그램을 실행시켜 성능 측정치를 뽑아내는 방법도 있다.
- 핫스팟 JVM을 사용하는 경우라면 -XX:+PrintCompilation 옵션을 사용해 동적 컴파일 작업이 실행될 때 메시지를 출력시킬 수 있다. 이렇게 메시지를 출력시켜보면 컴파일이 모두 끝나고 성능을 측정하기 좋은 시간이 언제쯤인지 측정해볼수 있다.
- 동일한 테스트 프로그램을 하나의 JVM에서 여러번 실행해보면 그 가운데 적당한 테스트 결과를 골라낼 수 있다. 초기해 실행했던 결과는 워밍업 과정이라고 보고 제외하고, 그 이후에 측정 결과를 봤을 때 측정 값의 변동이 크다면 똑같은 테스트를 실행하는데 걸리는 시간이 왜 일정하게 유지되지 않는지에 대한 원이를 찾아봐야 할 것이다.
- JVM은 일상적인 내부 작업을 처리하기 위해 여러 개의 백그라운드 스레드를 사용한다. 서로 관련되지 않으면서 한번에 CPU를 중점적으로 상요하는 기능을 테스트하고자 한다면 테스트를 여러 번 실행하는 사이마다 약간의 쉬는 시간을 두어 JVM이 일상 작업을 처리할 수 있도록 배려하는게 좋다. 그래야 시간을 측정하는 테스트가 진행될 때 꼭 해야 하는 JVM 내부 작업을 처리하느라 CPU를 소모하고 그로 인해 테스트 실행 시간 결과 값에 오류가 발생하는 일이 줄어든다.

### 12.3.3 비현실적인 코드 경로 샘플링 
- 런타임 컴파일러는 컴파일할 코드에 대한 최적화 정보를 얻기 위해 실행 과정에서 여러 가지 성능 값을 추출한다.
- JVM은 더 나은 코드를 생성할 수 있도록 프로그램 실행에 관련된 특정 정보를 사용하기도 한다.
    - ex : 특정 프로그램에서 사용하는 메소드 M를 컴파일 했을 때의 결과 코드와 다른 프로그램에서 사용하는 동일한 메소드를 컴파일한 결과가 다를 수 있다.
- 특히 어떤 경우에는 JVM이 코드를 컴파일할 때 일시적으로만 효과를 발휘할 수 있는 몇 가지 가정을 설정하고 그에 따라 컴파일하기도 한다.
- 그리고 만약 설정했던 가정이 어느 시점 이후에 올바르지 않은 가정이라고 판단되면 컴파일한 코드를 무효로 하고 새로 컴파일하기도 한다. 
- 따라서 특정 애플리케이션에서 사용하는 시나리오 패턴만을 묘사해 테스트하는 것보다는 그와 유사한 시나리오 패턴도 한데 묶어서 테스트하는 일도 중요한 부분이다.
- 이렇게 테스트 하지 않을 경우
    - ex : 단일 스레드에서 동작했어야 할 테스트 프로그램에 동적 컴파일러가 일반적인 서버 애플리케이션처럼 최소한의 병렬성을 필요로 하는 상황에 맞게 특별한 최적화 기법을 사용해 코드를 컴파일해 문제가 발생할수도 있다.
- 그래서 단일 스레드 프로그램의 성능을 테스트하고자할 때도 단일 스레드 프로그램의 성능 뿐만 아니라 멀티스레드 애플리케이션의 성능도 함께 테스트하는것이 좋다.(TimedPutTakeTest의 경우 최소 스레드가 2개이 때문에 해당 문제 발생 x)

### 12.3.4 비현실적인 경쟁 수준
- 병렬 애플리케이션은 두 종류의 작업을 번갈아가며 실행하는 구조로 동작 
- 여러 스레드가 공유하는 큐에서 다음 처리할 작업을 뽑아내는 것과 같이 공유된 데이터에 접근하는 종류의 작업이 있고, 큐에서 가져온 작업을 실행하는 것과 같이 스레드 내부의 데이터만을 갖고 실행되는 작업이 있다. (물론 큐에서 가져온 작업을 처리할 때 공유된 데이터를 사용하지 않아야 한다.)
- 전체 작업을 두 종류의 작업으로 구분해 봤을 때 각각 얼마만큼의 비율을 차지하는지에 따라 경쟁의 수준이 달라지고 성능과 확장성 측면에서 굉장히 다른 결과를 내놓게 된다.
- 이를테면 N개의 스레드가 서로 공유하는 작업 큐에서 작업을 가져다 실행한다고 하고, 각 작업은 CPU 중심의 작업이며 오랜 시간 동안 실행된다고 하면 스레드 간의 경쟁은 거의 발생하지 않을 것이다.
- 실행 성능은 CPU의 처리 속도에 굉장히 의존하게 된다.
- 반대로 개별 작업이 아주 짧은 시간 안에 빠르게 실행된다면 작업 큐에서 서로 작업을 가져가려고 경쟁이 많이 발생할것이며 전체적인 실행 성능은 동기화 방법에 따라 좌지우지된다.
- 병렬테스트 프로그램에서 실제 상황과 유사한 결과를 얻으려면 직접적으로 알고자 하는 부분, 즉 병렬 처리 작업을 조율하는 동기화 부분의 성능과 함께 스레드 내부에서 실행되는 작업의 형태도 실제 애플리케이션과 비슷한 특성을 띠고 있어야 한다.
- 실제 애플리케이션의 작업 스레드가 처리하는 개별 작업이 테스트 프로그램의 가상 개별 작업과 다른 특성을 갖고 있다면 성능상의 병목이 어느 지점인가를 파악할 때 전혀 엉뚱한 지점을 지목하게 될 수도 있다.
- 이미 11.5절에서 살펴본 바가 있지만, synchronizedMap 메소드로 생성한 락 동기화 기반의 Map을 놓고 봤을 때 락을 확보하려는 부분에서 스레드 간의 경쟁이 많이 발생하느냐 별로 발생하지 않느냐의 차이가 성능 측정치에 지대한 영향을 미친다.
- 11.5절에서 실행해봤던 테스트는 Map 클래스를 마구 사용해보는 수준일 뿐이다.
- 그런데 단 2개의 스레드만을 사용하는 경우에도 Map에 접근하려는 거의 모든 경우에 스레드 간의 경쟁이 발생했다.
- 어찌됐건 애플리케이션의 작업 구조상 공유딘 데이터에 접근해 사용하는 부분보다 스레드 내부 작업의 양이 상대적으로 많다고 하면 스레드 경쟁 정도가 크게 떨어지고, 경쟁이 적어지니 전반적으로 괜찮은 성능을 낼 수 있을 것이다.
- 이런 관점에서 보면 TimedPutTakeTest 프로그램에서 사용했던 모델은 일부 애플리케이션 구조를 묘사하기에는 그다지 훌륭하지 못하다.
- 스레드 내부에서 별다른 작업을 하지 않기 때문에 성능 측정치는 스레드 간의 경쟁 정도에 좌우되며, 프로듀서와 컨슈머 간에 큐를 사용해 데이터를 주고받는 애플리케이션 모두가 이와 같이 스레드 내부의 작업이 적다고 볼 수 없기 때문

### 12.3.5 의미 없는 코드 제거
- 최적화 컴파일러는 의미 없는 코드를 제거하는데 뛰어난 능력을 갖고 있으며, 따라서 훌륭한 성능 측정프로그램을 작성하는 일은 쉽지 않다.
- 일반적으로 성능 측정을 하는 동안에는 실제적인 계산 작업을 거의 하지 않기 때문에 최적화 컴파일러 입장에서는 1차 제거 대상이 될 수 있다.
- 대부분의 경우에는 최적화 컴파일러가 의미없는 코드를 자동으로 제거해주면 좋지만, 성능 측정 프로그램을 실행하는 경우에는 최적화된 이후 예상했던 것보다 훨씬 적은 코드만이 실행될 수 있기 떄문에 큰 문제가 되고 한다.
- 운이 좋다면 최적화 컴파일러가 실행 코드 대부분을 제거해버리고 너무나 빠르게 실행된다는 성능 측정 결과를 내놓을 수도 있는데, 이런 경우에는 결과 값을 보고 이상하다는 걸 한눈에 알 수 있을테니 그나마 다행.
- 그렇지 않다면 어느 정도의 코드만 제거되고 빠르게 실행된다는 결과를 내놓고, 테스트는 뭔가 다른 그럴싸한 이유를 붙여 성능이 잘 나온다고 판단하는 오류를 범할 수 있다.
- 의미없는 코드 제거 기능은 정적으로 컴파일하는 언어로 성능을 측정하는 경우에도 비슷한 문제점을 발생시킬 수 있다. 
- 하지만 컴파일 과정을 미리 진행하기 떄문에 생성된 기계어 코드를 들여다보면 컴파일러가 최적화 과정에서 코드를 얼마만큼 제거해 버렸는지를 정확하게 파악할 수 있다.
- 반대로 동적인 컴파일 방법을 사용하는 언어의 경우에는 이와 같은 컴파일된 기계어 코드를 살펴보기 어려워 이런 정보를 얻기가 어렵다.
- 여러 가지 성능 테스트를 실행해보면 핫스팟 JVM 클라이언트 모드보다 서버 모드로 실행했을 때의 결과가 훨씬 좋다. 서버 모드의 동적 컴파일러가 클라이언트 모드의 컴파일러보다 더 효율적인 코드를 생성할 수 있다는 것 뿐만 아니라 의미 없는 코드를 최적화하는 능력도 더 낫기 때문
- 다만 성능을 측정할 때 잘 동작해 의미 없는 코드를 대부분 최적화하곤 했지만, 실제 애플리케이션을 실행할때는 그다지 최적화하지 못할 수 도 있다. 그래도 CPU가 여러 개 장착된 시스템에서는 사용서비스를 실행하거나 성능 측정 프로그램을 실행하는 경우 모두 클라이언트 대신 서버 옵션을 지정하는게 좋다.
- 그저 의미 없는 코드로 제거돼 버리지 않고 제대로 실행돼 올바른 결과를 낼 수 있도록 테스트 프로그램을 주의깊게 작성하기만 하면 된다
- 훌륭한 성능 측정 프로그램을 작성하려면 최적화 컴파일러가 의미 없는 코드를 제거하는 과정에 성능 측정 상 필요한 부분까지 제거하지 않도록 약간의 편법을 써야 할 필요가 있다. 그러려면 프로그램 코드가 만들어내는 모든 결과 값을 프로그램 어디선가 사용하도록 해야 한다. 물론 그 때문에 추가적으로 동기화를 해야 하거나 더 많은 자원을 소모하도록 하지는 않는 것이 좋다.
- ex : PutTakeTest 에서 큐에 추가하거나 큐에서 제거하는 모든 항목마다 체크섬 값을 계산하고, 나중에 모든 스레드의 체크셤을 합산해 올바르게 동작하는지 확인하는 부분이 있었다.
- 이처럼 올바르게 동작하는지 여부를 확인하기 위해 사용했던 체크셤 값도 결국 실제로 사용하는 부분은 없기 때문에 최적화 컴파일러에 의해 의미없는 코드로 게거될 가능성이 있는 부분이다.
- 원래 이 체크섬 부분은 버퍼 알고리즘이 정상적으로 동작하는지를 확인하기 위한 것이었지만, 콘솔에 출력하는 기능을 넣어서 실제로 사용하는 값이라는 사실을 최적화 컴파일러에게 알려주자.
- 그렇다해도 I/O 기능을 호출하면 성능 측정 값에 영향을 줄 수 있기 때문에 성능 테스트를 실행하는 동안에, 특히 시간을 측정하는 동안에는 I/O 기능을 사용하지 않는 편이 좋다.
- I/O 를 사용해야 하지만 성능에 영향을 줄 수 있으니 사용하기도 곤란할 때
    - 아래 코드와 같이 hashCode 메소드로 현재 클래스의 해시 값을 가져오도록 하고, 그 해시 값과 임의의 숫자, System.nanoTime과 같은 값을 비교하도록 한다.
    - 그러면 두 값이 거의 일치할 일이 없을 것이며 비교문 안에 I/O 를 사용하는 출력문을 적어두면 성능 측정에 영향을 줄만한 작업은 하지 않으면서 최적화 컴파일러가 의미없는 코드로 판단해 제거해버리는 일을 바지할 수 있다.
~~~
if(foo.x.hashCode() == System.nanoTime()) {
    System.out.print(" ");
}
~~~
- 보다시피 위의 코드에서 사용했던 비교 구문이 참일 가능성은 거의 없다. 참이어도 그냥 공백 문자 출력
- 프로그램 내부에서 계산했던 모든 값을 어떤 방법으로건 사용해야할 뿐만 아니라 그 사용처를 추측할 수 없어야 한다.
- 괜찮은 최적화 컴파일러가 동작하고 있을 때 결과 값을 예측할 수 있었다면 최적화 컴파일러가 매번 계산 과정을 실행하는 대신 미리 계산된 값을 사용하기도 한다.
- 이번에 PutTakeTest 프로그램을 작성할 때는 이런 가능성을 고려하고 작업했지만 정적인 입력 값을 갖고 동작하는 테스트 프로그램은 항상 최적화 컴파일러가 미리 계산된 값을 사용할 수 있다.

## 12.4 보조적인 테스트방법
- 훌륭한 테스트 프로그램을 작성해도 모든 버그를 찾는 프로그램은 없다.
- 프로그램이 조금만 복잡해지면 오류를 모두 잡는건 불가능하다.
- 테스팅의 목적은 '오류를 찾는 일'이 아니라 대상 프로그램이 처음 작성할 때 설계했던 대로 동작한다는 신뢰성을 높이는 작업이다.
- 모든 버그 찾기는 불가능하므로 품질보증 전략으로 가능한 테스트 자원 내에서 신뢰성을 끌어내는 방향으로 가야 한다.
- 지금까지는 단위 테스트와 성능 테스트를 효과적으로 작성할 수 있는 방법을 중점적으로 봤다.
- 테스팅 작업은 병렬 프로그램이 제대로 동작한다는 신뢰도를 높이는 과정에서 아주 중요한 역할을 담당하지만 사용할 수 잇는 여러 가지 QA방법 가운데 하나
- 코드리뷰나 정적분석과 같이 상호 보완적인 테스트 방법을 사용하면 신뢰도를 크게 높일 수 있다.

### 12.4.1 코드 리뷰
- 병렬 프로그램의 오류를 찾아내고자 할 때 단위 테스트와 성능 테스트만큼이나 중요하고 또 효과적인 테스트 방법은 바로 여러 명이 모여서 코드를 하나하나 살펴보는 코드 리뷰이다. 
- 병렬 프로그램에 대한 테스트 프로그램을 작성해 안전성 오류를 최대한 찾아내도록 하는 일이나, 테스트 프로그램을 자주 실행하면서 계속해서 오류가 없다는 사실을 확인하는 것 외에도 코드를 직접 작성하지 않은 다른 사람들에게 프로그램 코드를 보여주는 일을 항상 시간과 노력을 들인 만큼의 가치를 안겨주는 일이다.
- 아주 사소한 경쟁 조건을 찾아내는 등의 일은 여러 개의 테스트 프로그램을 작성하는 것보다 병렬 프로그램 전문가가 코드를 들여다 보는 것으로 더 쉽게 찾아내는 경우가 많다.
- 코드 리뷰를 하다 보면 그 외에도 더 만은 이득을 볼 수 있다.
- ex : 단순하게 문제점을 찾아내는 것뿐만 아니라 코드 리뷰와 함께 소스코드의 주석문에 코드에 대한 더 자세한 설명을 추가하는 일을 함께 하면서 나중에 반드시 발생알 유지보수 낮출수도 있다.

### 12.4.2 정적 분석 도구
- 정적 분석 도구 방법 = 코드를 실행하지 않고 그 자체로 분석하며, 코드 감사 도구를 사용하면 클래스 파일 내부에 흔히 알려진 여러 가지 버그 패턴 가운데 해당하는 부분이 있는지를 확인해준다.
- 오픈소스로 공개된 FindBugs와 같은 정적분석도구에는 패턴감지기가 포함돼 있고, 단위 테스트나 성능테스트, 코드리뷰등의 과정에서 빼먹기 쉬운 다양한 종류의 일반적인 코딩 오류 발견 가능
- 정적 분석 도구를 실행시키면 경고할만한 부분을 목록으로 리포팅해주며, 리포팅된 부분이 오류인지 아닌지는 확인해야 한다.
- lint와 같은 도구를 사용했을 때 많은 잘못된 경고 리포트를 출력했지만 FindBugs는 튜닝으로 최대한 줄였다.
- 정적 분석 도구는 아직 굉장히 초창기를 벗어나지 못하고 있지만, 프로그램 테스트 과정에서 굉장히 쓸모있는 도구라고 인식
- 일관적이지 않는 동기화 : 다수의 클래스는 클래스 내부의 변수를 자신의 암묵적인 락으로 동기화하는 동기화 정책 사용. 특정 변수가 동기화 블록 내부에서 사용되는 경우가 많으면서 일부는 동기화 블록 외부에서도 사용되는 경우가 있다면 해당 변수에 대해 동기화정책이 정확하게 적용되지 않은 경우일 수 있다.
    - 나중에 @GaurdedBy와 같은 어노테이션이 표준화된 이후에는 감사 도구에서 변수와 락 간의 관계를 분석하는 등의 방법으로 동기화 정책을 추측하는 대신 어노테이션을 직업 분석해 정적 분석 결과의 품질 향상 가능
- Thread.run 호출 : Thread 클래스는 Runnable 인터페이스를 구현하고 있기 때문에 run메소드를 갖고 있다. 그렇지만 일반적으로 Thread.start메소들르 호출하는 대신 Thread.run 메소드를 호출하는 일은 잘못된 방법일 경우가 많다.
- 해제되지 않은 락 : 암묵적인 락 대신 명시적인 락은 해당 락을 확보한 블록이 실행을 마치고 빠져나갔다 해도 락이 자동으로 해제되지 않는다. 표준적으로 사용해야 하는 방법은 확보했던 락을 finally구문에서 해제하는 방법이지만, 그렇지 않은 경우 실행 도중에 예외 상황이 발생했을 때 락이 해제되지 않을 가능성이 있다.
- 빈 synchronized 블록 : 자바 메모리 모델상에서는 비어있는 synchronized 블록이 의미가 있을 수 있겠지만 대부분 잘못 사용된 경우. 개발자가 어떤 의도에서 빈 synchonized 블록을 사용했는지 모르겠지만, 대부분의 경우 빈 synchonzied 블록 대신 사용할만한 다른 방법이 있다.
- 더블 체크 락 : 더블 체크락은 늦은 초기화 방법에서 발생하는 동기화 부분을 줄이는 방법. 하지만 동기화 능력이 부족하기 때문에 공유된 변경 가능한 값을 읽어가는 경우가 발생할 가능성이 있다.
- 생성 메소드에서 스레드 발생 : 새엇ㅇ 메소드에서 새로운 스레드를 실해잇키도록 한다면, 해당 클래스를 상속받았을 때 문제가 생길 수 있고, 또한 this 변수를 스레드에게 노출시킬 수 있다는 위험도 있다.
- 알림 오류 : notify나 notifyAll 메소드는 해당하는 조건 큐에서 대기하고 있는 스레드가 있다면, 객체의 상태가 변경돼 대기중인 스레드가 대기 상태에서 푸려도나 좋다는 조건을 알려주는 메소드. notify나 notifyAll메소드는 항상 해당 조건과 관련된 상태가 변경됐을때만 사용해야 한다. ex : synchonized 블록 내부에서 notify나 noyifyAll메소드를 호출하지만 상태를 변경하지 않은 상태라면 오류일 가능성이 높다.
- 조건부 대기 오류 : 조건 큐에서 대기할 때는 필요한 락을 확보한 상태에서 상태 변수를 확인한 이후에 Object.wait 나 Condition.await 메소드를 반복문으로 감싸는 구조로 표현해야 한다. 락을 확보하지 않은 상태이거나 상태 변수를 제대로 확인하지 않은 상황에서 Object.wait 메소드나 Condition.await 메소드를 호출하도록 돼 있다면 오류일 가능성이 높다.
- Lock과 Condition의 오용 : synchronized 블록에 락인자를 넣을 때 Lock이라는 클래스 이름을 지정한다거나, 아니면 Condition.await 메소드를 호출하는 대신 Conditaion.wait 메소드를 호출하는 경우는 오타로 인해 동기화 구문을 잘못 작어하는 예이다.
- 락을 확보하고 대기 상태 진입 : 락을 확본한 상태에서 Thread.sleep 메소드를 호출하면 락을 필요로 하는 다른 스레드 역시 아무 일도 못하고 대기 상태에 들어가게 할 수 있으며 따라서 나중에 활동성에 심각한 영향을 줄 수 있다. 락을 두 개 확보한 상태에서 Object.wait 메소드를 호출하거나 Condition.await 메소드를 호출하는 경우 역시 비슷한 문제의 원인
- 스핀 반복문 : 아무런 일도 하지 않으면서 특정 변수의 값이 원하는 상태에 도달할 때까지 계속해서 반복하기만 하는 반복문을 사용하면 CPU자원을 엄청나게 소모할 뿐만 아니라 해당 변수가 volatile 이 아니라면 심지어 무한 반복에 빠질 수 있다. 원하는 형태로 상태 변수 값이 변경되기를 기다리는 경우네느 래치나 여러가지 조건부 대기 기능을 활용하는 편이 안전하다.

### 12.4.3 관점 지향 테스트 방법
- 관점 지향 프로그래밍(AOP) 기법이 병렬 프로그래밍 분야에 적용되는 사례는 굉장히 제한적이다.
- AOP 도구가 아직은 동기화 관련 지점에서 포인트컷을 지원하고 있지 않기 때문.
- 그렇다 해도 AOP를 사용하면 상태 변수의 값이 동기화 정책에 잘 맞는지를 확인하는 등의 작업을 하도록 적용해 볼 수 있다.
- ex : 스레드 안전성이 보장되지 않는 스윙 메소드를 호출하는 모든 부분에 관점을 적용해 항상 이벤트 스레드에서만 스윙 클래스의 메소드를 호출하는지 확인하는 사례를 볼 수 있다.
- AOP의 특성상 코드를 따로 변경해야 할 필요가 없으니 이런 기법은 적용하기도 간편하고, 사소한 변수 공개 상황이나 스레드 한정 오류와 같은 부분을 찾아내기에 좋다.

### 12.4.4 프로파일러와 모니터링 도구
- 대부분의 상용 프로파일링 도구에는 스레드의 동작 상황을 살펴볼 수 있는 모듈이 포함돼 있다. 각 제품마다 기능과 효율성 등이 서로 다르긴 하지만 테스트 대상 프로그램이 도대체 무슨 일을 하는지에 대한 내부적인 정보를 들여다보기에 좋은 방법이다.
- 대부분 각 스레드의 실행 상태를 여러가지 색으로 구분해 시간이 지나감에 따라 어떻게 실행되는지를 표시는 기능을 갖고 있다.
- 이와 같은 결과 그래프를 보면 CPU를 얼마나 충분하게 활횽하고 있으며, 만약 CPU을 충분하게 사용하지 못했다면 그 원인이 어디에 있는지도 대략 알려준다.
- 자바에 내장된 JMX 에이전트를 사용하는 것도 제한적이나마 스레드의 상태를 모니터링 할 수 있는 방법이다.
- ThreadInfo 클래스를 보면 스레드의 현재 상태 ID를 갖고 있고, 만약 스레드가 대 기상태에 들어가 있다면 어떤 락을 놓고 대기중인지도 알 수 있다. 그리고 '스레드 경쟁 모니터링' 기능이 켜져 있다면 락이나 알림을 대상으로 몇번이나 대기 상태에 들어갔었는지를 ThreadInfo클래스에 저장하고 대기 상태에서 소모한 누적 값도 보관한다.

## 요약
- 병렬 프로그램이 올바르게 동작하는지 테스트하는 일은 어렵다.
- 병렬 프로그램에서 발생하는 오류의 대부분 = 아주 작은 타이밍 문제, 부하 문제, 기타 쉽게 발현되지 않는 여러 원인
- 테스트 프로그램에서 발생하는 동기화 문제나 타이밍 문제 때문에 원래 테스트 대상이 갖고 있던 문제를 발견하지 못할 수도 있다.
- 자바는 동적으로 컴파일되므로 병렬 처리 프로그램은 성능을 측정하기가 더 어렵다.
- 성능을 측정할 때 실행 시간이 동적인 컴파일, 가비지 컬렉션, 각종 최적화 방법때문에 크게 변경될수 있으며 의도했던 대로 시간 측정이 어렵다.
- 숨어있는 버그를 사용 서비스 이전에 발견할 수 있는 가장 좋은 방법은 전통적인 테스트 방법과 함께 코드 리뷰나 자동화도니 분석 도구를 사용하는 방법
- 각 방법은 모두 다른 방법이 잘 찾아내지 못하는 오률 찾아낼 수 이으니, 다양한 방법을 동원해 테스트해야 오류 최소화 가능
