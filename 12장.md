# 12 병렬 프로그램 테스트
- 병렬 프로그램 역시 순차적으로 처리하는 프로그램과 유사한 디자인 패턴을 가져다 쓰지만 순차적인 프로그램에 비해 곳곳에 작동 내용을 확인하기 어려운 부분을 포함하고 있다.
- 그러므로 순차적인 프로그램에 비해 각 부분 간에 상호 작용이 훨씬 복잡하며, 미리 예상하고 분석해야 할 가능한 오류 상황도 훨씬 많다.
- 테스팅 방법 역시 순차적인 프로그램을 테스트하던 방법을 그대로 가져와 사용하는데, 테스트 결과로 얻을 수 있는 값의 범위가 순차적인 프로그램보다 훨씬 다양하다는 특징이 있다.
- 병렬 프로그램을 테스트하는 프로그램을 작성할 때 처음 부딪히는 부분은 바로 순차적인 프로그램보다 문제 상황이 발생할 확률이 훨씬 적다는데 있다.
    - 결국 발생 확률이 훨씬 떨어지는 결과를 제대로 확힌해야 하기 때문에 테스트 프로그램에서 대상 애플리케이션을 훨씬 강하게 밀어붙여야 하고, 순차적인 프로그램보다 긴 시간동안 테스트하는 일이 많다.
- 병렬 프로그램을 테스트한 결과는 전통적으로 사용해왔던 문제 상황인 안전성(안 좋은 일이 발생하지 않는 상황)과 활동성(결국 좋은 일이 발생하는 상황)의 문제로 귀결된다.
- 클래스가 동작하는 형태가 설계했던 모습 그대로 움직이는지를 확인하는 안전성 테스트는 대부분 변수의 값이 정확한지를 확인하는 것부터 시작한다.
    - 갖고있는 항목의 개수를 독립 변수에 캐시하고 변경 사항이 발생할 때마다 업데이트하도록 만들어진 연결 리스트를 구현하고 있다면, 갖고 있는 항목의 개수와 캐시된 변수의 값이 일치하는지를 확인하는 부분이 가장 기본적인 안전성 테스트
- 단일 스레드 환경에서는 리스트에 들어있는 항목이 테스트 도중 변경될 수 없기 때문에 굉장히 쉽게 테스트할 수 있다.
- 그러나 다수의 스레드가 동작하는 병렬 처리 환경에서는 항목의 개수를 세는 작업과 세어진 개수가 캐시된 변수의 값과 일치하는지를 확인하는 두 가지 작업을 단일 연산으로 수행하지 않는 한 올바르지 않은 결과가 속출할 것이다.
- 이런 테스트를 병렬 환경에서 올바르게 진행하려면 대상 리스트를 독점적으로 사용할 수 있도록 준비해야 한다.
- 예를 들어 구현하고 있는 리스트클래스에서 현재 항목의 목록에 대한 스냅샷을 뽑아주는 기능을 구현하거나, 테스트 프로그램이 값을 제대로 비교하거나 테스트 코드를 안전하게 실행할 수 있도록 테스트 포인트를 마련하는 방법도 있다.
- 이책에서는 딱 맞아떨어지는 오류 상황을 표한하기 위해 타이밍 다이어그램을 사용하곤 했다.
- 테스트 프로그램은 물론 발생 가능한 상황을 최대한 넓게 지나다니면서 불행하게 타이밍이 딱 맞는 상황을 놓치지 않아야 한다. 반대로 안 좋은 타이밍을 만들어내기 위해 준비한 테스트 프로글매이 오히려 실제로 발생할 수 있는 상황을 표현하지 못하는 오류를 남겨두는 경우도 생길 수 있다.
    - 하이젠 버그 : 오류를 확인하기 위해 디버깅 관련 코드를 추가하면 사라져 버리는 버그
-  활동성 테스트는 어려운데, 활동성 테스트를 하다 보면 진행 중인 상태와 진행이 멈춘 상태를 테스트하는 경우가 많다.
    - ex : 특정 메소드를 테스트하는 도중에 더 이상 실행되지 않는 것처럼 보이는 경우가 생기면, 단순히 실행 속도가 너무 느린 것으로 봐야 할지, 실행 도중에 멈추는 오류가 발생한 것인지를 확인해야 한다.
- 이와 비슷하게 프로그램을 구현할 때 적용한 특정 알고리즘이 데드락에 걸리지 않는다고 어떻게 보장할 것인가? 프로그램에 오류가 있다고 판단하기 전까지 얼마나 오랫동안 느리게 실행되는 프로그램을 참아줘야 하는가?
- 활동성 문제를 테스트하는 것은 성능 문제를 테스트하는 것과 밀접한 관련이 있다. 성능은 여러가지 측면에서 수치화해 측정할 수 있다.
    - 처리량 : 병렬로 실행되는 여러 개의 작업이 각자가 할 일을 끝내는 속도
    - 응답성 : 요청이 들어온 이후 작업을 마치고 결과를 줄 때까지의 시간
    - 확장성 : 자원을 더 많이 확보할 때마다 그에 따라 처리할 수 있는 작업량이 늘어나는 정도

## 12.1 정확성 테스트
- 병렬 프로그램을 테스트하기 위한 테스트 프로그램을 작성할때는 순차적인 프로그램을 테스트하는 경우와 똑같은 분석 작업으로 시작
    - 올바른 값을 정확하게 알고 있는 변수가 어떤 것인지, 그 변수가 최종적으로 어떤 값을 가져와 하는 지 확인
- 설계가 충분히 이뤄진 경우에는 이와 같은 변수에 대한 사항이 설계 문서에 포함돼 있을 수 있다.
- 테스트 프로그램을 작성하는 나머지 시간은 전부 설계 과정에서 놓친 기능 명세를 찾아가는 과정이다.
- 정확성 테스트에 대해 확실하게 이해할 수 있는 예제로 크기가 제한된 버퍼 클래스에 대한 테스트 케이스 구현
- 예제 12.1 세마포어를 사용한 BoundedBuffer 클래스
- 다시 공부 : 제한된 크기를 초과한 경우에 대기 상태에 들어감
~~~java
@ThreadSafe
public class BoundedBuffer<E> {
    private final Semaphore availableItems, availableSpaces; // availableItems : 현재 버퍼 내부에서 뽑아낼 수 있는 항목의 개수, availableSpaces : 버퍼에 추가할 수 있는 항목이 개수 
 
    @GuardedBy("this") private final E[] items; // 배열을 기반으로 하는 큐의 형태
    @GuardedBy("this") private int putPosition = 0, takePosition = 0;
    
    public BoundedBuffer(int capacity) {
        availableItems = new Semaphore(0);
        availableSpaces = new Semaphore(capacity); // 크기 제한
        items = (E[]) new Object[capacity];
    }
    
    public boolean isEmpty() {
        return availableItems.availablePermits() == 0;
    }
    
    public boolean isFull() {
        return availableSpaces.availablePermits() == 0;
    }
    
    public void put(E x) throws InterruptedException {  //대기상태에 들어갈 수 있음, 제한된 크기를 초과한 경우 대기
        availableSpaces.acquire();  
        doInsert(x);
        availableItems.release(); // 개수가 지정된 세마포어를 사용해 동기화
    }
    
    public E take() throws InterruptedException { // 대기 상태에 들어갈 수 있음
        availableItems.acquire(); // 세마포어에서 가져갈 수 있는 항목이 있는지 확인 받기
        E item = doExtract();
        availableSpaces.release(); // 세마포어 값 증가. 
        return item;
    } // put은 반대이므로 항상 양쪽 세마포어가 갖고 있는 값의 합이 버퍼의 크기와 일치
    
    private synchronized void doInsert(E x) {
        int i = putPosition;
        items[i] = x;
        ++i;
        if(i == items.length) {
            putPosition = 0;
            return;
        }
        putPosition = i;
    }
    
    private synchronized E doExtract() {
        int i = takePosition;
        E x = items[i];
        items[i] = null;
        ++i;
        if(i == items.length) {
            takePosition = 0;
            return x;
        }
        takePosition = i;
        return x;
    }
}
~~~
 
 ### 12.1.1 가장 기본적인 단위 테스트
 - BoundedBuffer 클래스를 테스트하기 위한 가장 기본적인 단위 테스트 클래스는 순차적인 개념으로 생각했을 때의 방법과 다르지 않다.
    - BoundedBuffer 인스턴스를 하나 생성하고 메소드를 이것 저것 호출해보고, 최종적인 상태와 변수의 값등을 확인해보기
    - 용량이 N인 BoundedBuffer 클래스에 N개의 항목을 추가하고, 버퍼 클래스 스스로 용량이 가득 찾다고 표현해야 한다.
 - 예제 12.2 BoundedBuffer 클래스의 기능을 테스트하는 기본 테스트 케이스
 ~~~java
public class BoundedBufferTest extends TestCase {
    void testIsEmptyWhenConstructed() {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        assertTrue(bb.isEmpty());
        assertFalse(bb.isFull());
    }
    
    void testIsFullAfterPuts() throws InterruptedException {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        for(int i = 0; i < 10; i ++) {
            bb.put(i);
        }
        assertTrue(bb.isFull());
        assertFalse(bb.isEmpty());
    }
}
~~~
- 순차적으로 동작하는 테스트 케이스를 작성해두면 경쟁상황에서의 테스트는 경쟁상황에서 발생하는 오류라고 추측 가능

### 12.1.1 블로킹 메소드 테스트
- 