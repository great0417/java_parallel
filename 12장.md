# 12 병렬 프로그램 테스트
- 병렬 프로그램 역시 순차적으로 처리하는 프로그램과 유사한 디자인 패턴을 가져다 쓰지만 순차적인 프로그램에 비해 곳곳에 작동 내용을 확인하기 어려운 부분을 포함하고 있다.
- 그러므로 순차적인 프로그램에 비해 각 부분 간에 상호 작용이 훨씬 복잡하며, 미리 예상하고 분석해야 할 가능한 오류 상황도 훨씬 많다.
- 테스팅 방법 역시 순차적인 프로그램을 테스트하던 방법을 그대로 가져와 사용하는데, 테스트 결과로 얻을 수 있는 값의 범위가 순차적인 프로그램보다 훨씬 다양하다는 특징이 있다.
- 병렬 프로그램을 테스트하는 프로그램을 작성할 때 처음 부딪히는 부분은 바로 순차적인 프로그램보다 문제 상황이 발생할 확률이 훨씬 적다는데 있다.
    - 결국 발생 확률이 훨씬 떨어지는 결과를 제대로 확힌해야 하기 때문에 테스트 프로그램에서 대상 애플리케이션을 훨씬 강하게 밀어붙여야 하고, 순차적인 프로그램보다 긴 시간동안 테스트하는 일이 많다.
- 병렬 프로그램을 테스트한 결과는 전통적으로 사용해왔던 문제 상황인 안전성(안 좋은 일이 발생하지 않는 상황)과 활동성(결국 좋은 일이 발생하는 상황)의 문제로 귀결된다.
- 클래스가 동작하는 형태가 설계했던 모습 그대로 움직이는지를 확인하는 안전성 테스트는 대부분 변수의 값이 정확한지를 확인하는 것부터 시작한다.
    - 갖고있는 항목의 개수를 독립 변수에 캐시하고 변경 사항이 발생할 때마다 업데이트하도록 만들어진 연결 리스트를 구현하고 있다면, 갖고 있는 항목의 개수와 캐시된 변수의 값이 일치하는지를 확인하는 부분이 가장 기본적인 안전성 테스트
- 단일 스레드 환경에서는 리스트에 들어있는 항목이 테스트 도중 변경될 수 없기 때문에 굉장히 쉽게 테스트할 수 있다.
- 그러나 다수의 스레드가 동작하는 병렬 처리 환경에서는 항목의 개수를 세는 작업과 세어진 개수가 캐시된 변수의 값과 일치하는지를 확인하는 두 가지 작업을 단일 연산으로 수행하지 않는 한 올바르지 않은 결과가 속출할 것이다.
- 이런 테스트를 병렬 환경에서 올바르게 진행하려면 대상 리스트를 독점적으로 사용할 수 있도록 준비해야 한다.
- 예를 들어 구현하고 있는 리스트클래스에서 현재 항목의 목록에 대한 스냅샷을 뽑아주는 기능을 구현하거나, 테스트 프로그램이 값을 제대로 비교하거나 테스트 코드를 안전하게 실행할 수 있도록 테스트 포인트를 마련하는 방법도 있다.
- 이책에서는 딱 맞아떨어지는 오류 상황을 표한하기 위해 타이밍 다이어그램을 사용하곤 했다.
- 테스트 프로그램은 물론 발생 가능한 상황을 최대한 넓게 지나다니면서 불행하게 타이밍이 딱 맞는 상황을 놓치지 않아야 한다. 반대로 안 좋은 타이밍을 만들어내기 위해 준비한 테스트 프로글매이 오히려 실제로 발생할 수 있는 상황을 표현하지 못하는 오류를 남겨두는 경우도 생길 수 있다.
    - 하이젠 버그 : 오류를 확인하기 위해 디버깅 관련 코드를 추가하면 사라져 버리는 버그
-  활동성 테스트는 어려운데, 활동성 테스트를 하다 보면 진행 중인 상태와 진행이 멈춘 상태를 테스트하는 경우가 많다.
    - ex : 특정 메소드를 테스트하는 도중에 더 이상 실행되지 않는 것처럼 보이는 경우가 생기면, 단순히 실행 속도가 너무 느린 것으로 봐야 할지, 실행 도중에 멈추는 오류가 발생한 것인지를 확인해야 한다.
- 이와 비슷하게 프로그램을 구현할 때 적용한 특정 알고리즘이 데드락에 걸리지 않는다고 어떻게 보장할 것인가? 프로그램에 오류가 있다고 판단하기 전까지 얼마나 오랫동안 느리게 실행되는 프로그램을 참아줘야 하는가?
- 활동성 문제를 테스트하는 것은 성능 문제를 테스트하는 것과 밀접한 관련이 있다. 성능은 여러가지 측면에서 수치화해 측정할 수 있다.
    - 처리량 : 병렬로 실행되는 여러 개의 작업이 각자가 할 일을 끝내는 속도
    - 응답성 : 요청이 들어온 이후 작업을 마치고 결과를 줄 때까지의 시간
    - 확장성 : 자원을 더 많이 확보할 때마다 그에 따라 처리할 수 있는 작업량이 늘어나는 정도

## 12.1 정확성 테스트
- 병렬 프로그램을 테스트하기 위한 테스트 프로그램을 작성할때는 순차적인 프로그램을 테스트하는 경우와 똑같은 분석 작업으로 시작
    - 올바른 값을 정확하게 알고 있는 변수가 어떤 것인지, 그 변수가 최종적으로 어떤 값을 가져와 하는 지 확인
- 설계가 충분히 이뤄진 경우에는 이와 같은 변수에 대한 사항이 설계 문서에 포함돼 있을 수 있다.
- 테스트 프로그램을 작성하는 나머지 시간은 전부 설계 과정에서 놓친 기능 명세를 찾아가는 과정이다.
- 정확성 테스트에 대해 확실하게 이해할 수 있는 예제로 크기가 제한된 버퍼 클래스에 대한 테스트 케이스 구현
- 예제 12.1 세마포어를 사용한 BoundedBuffer 클래스
- 다시 공부 : 제한된 크기를 초과한 경우에 대기 상태에 들어감
~~~java
@ThreadSafe
public class BoundedBuffer<E> {
    private final Semaphore availableItems, availableSpaces; // availableItems : 현재 버퍼 내부에서 뽑아낼 수 있는 항목의 개수, availableSpaces : 버퍼에 추가할 수 있는 항목이 개수 
 
    @GuardedBy("this") private final E[] items; // 배열을 기반으로 하는 큐의 형태
    @GuardedBy("this") private int putPosition = 0, takePosition = 0;
    
    public BoundedBuffer(int capacity) {
        availableItems = new Semaphore(0);
        availableSpaces = new Semaphore(capacity); // 크기 제한
        items = (E[]) new Object[capacity];
    }
    
    public boolean isEmpty() {
        return availableItems.availablePermits() == 0;
    }
    
    public boolean isFull() {
        return availableSpaces.availablePermits() == 0;
    }
    
    public void put(E x) throws InterruptedException {  //대기상태에 들어갈 수 있음, 제한된 크기를 초과한 경우 대기
        availableSpaces.acquire();  
        doInsert(x);
        availableItems.release(); // 개수가 지정된 세마포어를 사용해 동기화
    }
    
    public E take() throws InterruptedException { // 대기 상태에 들어갈 수 있음
        availableItems.acquire(); // 세마포어에서 가져갈 수 있는 항목이 있는지 확인 받기
        E item = doExtract();
        availableSpaces.release(); // 세마포어 값 증가. 
        return item;
    } // put은 반대이므로 항상 양쪽 세마포어가 갖고 있는 값의 합이 버퍼의 크기와 일치
    
    private synchronized void doInsert(E x) {
        int i = putPosition;
        items[i] = x;
        ++i;
        if(i == items.length) {
            putPosition = 0;
            return;
        }
        putPosition = i;
    }
    
    private synchronized E doExtract() {
        int i = takePosition;
        E x = items[i];
        items[i] = null;
        ++i;
        if(i == items.length) {
            takePosition = 0;
            return x;
        }
        takePosition = i;
        return x;
    }
}
~~~
 
 
### 12.1.1 가장 기본적인 단위 테스트
- BoundedBuffer 클래스를 테스트하기 위한 가장 기본적인 단위 테스트 클래스는 순차적인 개념으로 생각했을 때와 별로 다르지 않다.
- BoundedBuffer 인스턴스를 하나 생성하고, 메소드를 이것 저것 호출해보고, 최종적인 상태와 변수의 값 등을 확인해보는 방법
    - ex : BoundedBuffer 인스턴스를 생성한 직후에는 자신이 데이터를 하나도 갖고 있지 않으며 가득 차지도 않았다는 점 표현,
    - ex2 : 용량이 N인 BoundedBuffer 클래스에 N개의 항목을 추가하고, 버퍼 클래스 스스로가 용량이 가득 찼다고 표현해야만 한다.
- 예제 12.2 BoundedBuffer 클래스의 기능을 테스트하는 가장 기본적인 테스트 케이스
 ~~~java
public class BoundedBufferTest extends TestCase {
    void testIsEmptyWhenConstructed() {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        assertTrue(bb.isEmpty());
        assertFalse(bb.isFull());
    }
    
    void testIsFullAfterPuts() throws InterruptedException {
        BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        for(int i = 0; i < 10; i ++) {
            bb.put(i);
        }
        assertTrue(bb.isFull());
        assertFalse(bb.isEmpty());
    }
}
~~~
- 순차적으로 동작하는 테스트 케이스를 작성해두면 경쟁상황에서의 테스트는 경쟁상황에서 발생하는 오류라고 추측 가능

### 12.1.2 블로킹 메소드 테스트
- 병렬로 동작하는 상황을 테스트하고자 한다면 스레드를 두 개 이상 실행시켜야 하는 경우가 대부분
- 테스트를 도와주는 프레임워크는 대부분 병렬 처리 환경에 적절히 대응하지 못하는 경우가 많다.
    - ex : 스레드를 생성하는 기능이나 실행된 스레드가 의도하지 않는 방법으로 종료되는 일이 있는지를 모니터링하는 등의 기능을 제공하지 않음.
    - 만약 테스트 케이스 내부에서 생성한 도우미 스레드가 오류 상태를 확인했다 해도 프레임워크 입장에서는 스레드가 발견된 오류가 정확하게 어떤 테스트와 연관돼 있는지조차 제대로 알아내기가 힘들다.
    - 따라서 따로 실행되고 있는 스레드에서 성공과 실패 여부를 파악하는 경우에, 파악된 성공 또는 실패 여부를 다시 원래 테스트 케이스의 메소드에 알려줄 수 있는 방법이 마련돼 있어야 테스트 결과를 단위 테스트 프레임워크에서 제대로 리포팅 할 수 있다.
- java.util.concurrent 패키지에 대한 표준 부합 테스트를 진행할 때 실패건이 발생하는 경우 어떤 테스트에서 실패했는지를 정확하게 파악하는 일이 굉장히 중요했다.
- 따라서 JSR 166 전문가 그룹에서는 테스트 케이스에서 실패 상황이 발생했을 때 해당 건을 모아 뒀다가 tearDown 메소드에서 모든 오류 상황을 표시하는 기능을 구현한 기반 클래스를 하나 구현했다.[링크](http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/test/tck/JSR166TestCase.java)
- 단 이 기반 클래스를 사용할 때에는 모든 테스트를 진행할 때 항상 특정 테스트에서 생성된 스레드는 해당 테스트가 종료되기 직전에 모두 종료돼야 한다는 조건을 만족해야 한다.
- 테스트가 오류 없이 정상적으로 끝났는지, 아니면 오류가 발생했을 때 오류를 제대로 찾아낼 수 있도록 오류 관련 정보를 충분히 출력해 줘야 한다.
- 만약 특정 메소드가 어떤 상황에서는 반드시 대기 상태에 들어가야 한다고 하면, 해당 기능에 대한 테스트를 담당했던 스레드가 더 이상 실행하지 않고 멈춰야만 테스트가 성공이라고 볼 수 있다.
- 대기상태에 들어가는 메소드를 테스트하는 것은 반드시 예외 상황이 발생해야 하는 메소드를 테스트하는것과 비슷하다. 만약 대상 메소드가 리턴되 버리면 테스트는 실패
- 대기 상태에 들어가는 메소드를 테스트할 때에는 여러가지 복잡한 사항이 있다.
    - 대상 메소드를 호출해서 제대로 대기 상태로 들어갔다고 하면 어떤 방법으로건 대기 상태를 풀어서 대기 상태에 들어갔었음을 확인해야 한다.
    - 이런 테스트를 할 수 있는 가장 확실한 방법은 인터럽트를 거는 방법
    - ex : 대기상태에 들어가야 하는 메소드를 호출할 때는 따로 스레드를 실행시켜 호출하고, 해당 스레드가 대기 상태에 들어갈 때까지 기다리고 있다가 대기 상태에 들어가면 인터럽트를 걸고 원하는 연산을 제대로 처리했는지 확인하는 순서로 진행
    - 물론 이와 같이 인터럽트를 활용해 테스트하려면 대기 상태에 들어갈 대상 메소드가 인터럽트에 적절하게 대응하도록(인터럽트가 걸리는 즉시 리턴되거나 InterruptedException 던지는 등의 행동)  만들어져 있어야 한다.
- '스레드가 대기 상태에 들어갈 때까지 기다리는 ' 방법은 간단하지 않다.
- 대기 상태에 들어가기 전에 배치된 프로그램코드가 실행되는데 얼마만큼의 시간이 걸릴것인지를 예측하고 있어야 하고, 그보다 오래 기다려 보는 수밖에 없다.
- 기다리도록 지정한 시간이 예상보다 짧아서 테스트가 제대로 이뤄지지 않는다면 기다리는 시간을 언제든지 늘릴 수 있도록 테스트 프로그램을 준비해야 한다.
- 예제 12.3 대기 상태와 인터럽트에 대한 대응을 테스트하는 루틴
    - 먼저 비어있는 버퍼의 take 메소드를 호출하는 taker 스레드 생성
    - taker 스레드가 호출한 take 메소드가 리턴된다면 taker 스레드는 오류가 발생했다는 사실을 기록
    - 테스트 프로그램을 실행하면 먼저 taker 스레드를 생성하고 적당량 이상 오래 기다려보고, 그 다음에는 taker 스레드에 인터럽트를 건다.
    - taker 스레드가 정상적으로 대기 상태에 들어가 있었다면 InterruptedException을 띄울것이고, InterruptedException을 받은 catch 구문에서는 예외가 발생한 상황이 정상적이라고 판단하고 스레드를 그대로 종료
    - taker 스레드를 실행시켰던 테스트 프로그램은 taker 스레드가 종료될 때까지 join 메소드를 기다리고, Thread.isAlive 메소드를 사용해 join메소드가 정상적으로 종료되었는지 확인
    - taker 스레드가 정상적으로 인터럽트에 응답했다면 join 메소드가 즉시 종료돼야 맞다.
    - 일반적인 join 메소드 대신 타임아웃을 지정하는 join 메소드를 사용하면 take 메소드가 예상치 못한 상황에 걸려 응답하지 않는 경우에도 테스트 프로그램을 제대로 종료시킬 수 있다. 
    - 아무것도 없을 때 take 메소드를 호출하면 대기 상태에 들어가야 한다는 것뿐만 아니라 대기중에 인터럽트가 걸리면 InterruptedException을 발생시켜야 한다는 기능도 테스트 가능
    - join 메소드를 사용해 정상적으로 종료되는지를 확인하는 작업은 Runnable 인터페이스를 구현하는 대신 스레드 클래스를 직접 상속받아 사용하는 편이 더 나은 몇 안되는 방법 가운데 하나.
    - 이와같은 방법을 사용하면 테스트 프로그램에서 버퍼에 항목을 직접 추가하면서 항목이 추가되는 시점에 대기 상태에 들어가있던 taker 스레드가 정상적으로 빠져나오는지도 확인 가능
~~~java
public class BoundedBufferTest extends TestCase {
    void testTakeBlocksWhenEmpty() {
        final BoundedBuffer<Integer> bb = new BoundedBuffer<Integer>(10);
        Thread taker = new Thread() {
            @Override
            public void run() {
                try {
                    int unused = bb.take();
                    fail(); //여기 들어오면 오류    
                } catch (InterruptedException success) {}
            }
        };
        
        try {
            taker.start();
            Thread.sleep(LOCKUP_DETECT_TIMEOUT);
            taker.isInterrupted();
            taker.join(LOCKUP_DETECT_TIMEOUT);
            assertFalse(taker.isAlive());
        } catch (Exception unexcepted) {
            fail();
        }
    }
}
~~~
- Thread.getState 메소드는 믿을만하지 못하다.
- 스레드가 대기 상태에 들어갈 때 JVM의 구현방법에 따라 스핀 대기 기법을 활용할 수도 있으므로, 특정 스레드가 대기 상태에 들어갔다고 해서 항상 드레드가 WAITING또는 TIME_WATING 상태에 놓여있다고 볼 수 없기 때문
- Object.wati 메소드나 Condition.await 메소드에서 정상적이지 않지만 예정보다 일찍 리턴될 수가 있는데 원래 대기하게 된 원인 조건이 해소되지 않았는데도 스레드의 상태가 WAITING또는 TIME_WATING에서 일시적으로 RUNNABE상태로 전환될 가능성도 있다. 
- 병렬성을 제어하는 용도로 Thread.getState를 사용하지 말아야 한다.

### 12.1.3 안전성 테스트
- 예제 12.2와 예제 12.3은 크기가 제한된 버퍼의 여러가지 속성을 테스트한다.
- 하지만 공유된 데이터를 서로 사용하고자 하는 경쟁하는 데서 발생하는 오류는 제대로 테스트 불가능
- 병렬 처리 환경에서 동작하는 클래스의 기능을 동시 다발적으로 호출할 때 발생하는 문제를 테스트하려면, put 메소드나 take 메소드를 호출하는 여러 개의 스레드를 충분한 시간 동안 동작시킨 다음 테스트 대상 클래스의 상태가 올바른지, 잘못된 값이 들어 있지는 않은지 확인해야 한다.
- 병렬 실행 환경에서 발생하는 오류를 확인하는 프로그램을 작성하다 보면 닭이 먼저냐 달걀이 먼저냐하는 문제에 걸림
- 즉 테스트 프로그램 자체가 병렬프로그램이 되어야 하기 때문.
- 안전성을 테스트하는 프로그램을 효과적으로 작성하려면 뭔가 문제가 발생했을 때 잘못 사용되는 속성을 '높은 확률로' 찾아내는 작업을 해야 함과 동시에 오류를 확인하는 코드가 테스트 대상의 병렬성을 인위적으로 제한해서는 안된다는 점을 고려해야 한다.
- 테스트 하는 대상 속성의 값을 확인할 때 추가적인 동기화 작업을 하지 않아도 된다면 가장 좋은 상태라고 볼 수 있다.
- 방법1 : 프로듀서-컨슈머 디자인 패턴을 사용해 동작하는 클래스에 가장 적합한 방법은 큐나 버퍼에 추가된 항목을 모두 뽑아낼 수 있는지 확인하고, 그 외에는 아무런 일도 하지 않는지 확인하는 방법
    - 테스트 대상과 함께 똑같은 내옹을 담은 제 2의 리스트를 마련해두고, 큐나 버퍼에 항목이 추가될 때 제2의 리스트에도 같은 항목을 추가한다.
    - 큐나 버퍼에서 항목을 제거할 때 제2의 리스트에서도 항목을 제거하고, 큐나 버퍼에서 항목을 모두 제거했을 때 제2의 리스트도 비어있는지를 확인
    - 하지만 이런 방법은 제2의 리스트에 항목을 추가하고 제거하는 과정에 스레드 동기화 작업이 필요하기 때문에 테스트 스레드의 스케쥴링 부분이 약간 꼬여버릴 가능성이 있다.
- 방법2 : 큐에 들어가고 나오는 항목의 체크섬을 구한 다음 순서를 유지하는 체크섬의 형태로 관리하고, 쌓인 체크섬을 비교해 확인하는 방법
    - 체크섬을 비교해 양쪽이 동일하다면 테스트 통과
    - 버퍼에 집어 넣을 항목을 생성하는 프로듀서가 하나만 동작하고 하나의 컨슈머가 버퍼의 내용을 가져다 사용하는 구조에서 가장 효과가 큰 테스트 방법
    - 올바른 항목을 뽑아내는지 테스트하는 것과 더불어 올바른 순서로 항목을 가져오는지도 테스트할 수 있기 때문
    - 다수의 프로듀서와 컨슈머가 연결돼 있는 구조에서 테스트하는 프로그램까지 확장시켜 적용하려면 항목이 추가되는 순서에 상관없는 체크섬 방법을 사용해야 하며, 결국 마지막에 체크섬을 모두 합해 볼 수 있어야 한다.
    - 그렇지 않으면 체크섬을 계산하는 부분을 동기화하느라 확장성 측면에서 병목이 나타날 수 있고, 그러다보면 테스트에 걸린 시간을 제대로 측정할 수 없게 된다. (더하기 연산이나 XOR 연산과 같이 교환 법칙을 만족하는 연산 방법이라면 체크섬 용도로 활용할 수 있겠다.)
    - 작성한 테스트 프로그램이 실제로 원하는 내용을 테스트하는지 확인하려면 사용하고 있는 체크섬 연산을 컴파일러가 예측할 수 ㅇ벗는 연산인지도 확인해야 한다.
    - ex : 테스트용 데이터로 일련번호를 사용하면 결과가 항상 동일, 컴파일러가 최적화를 충분히 할 수 있는 능력이 된다면 결과를 미리 계산해 버릴수도 있다.
    - 너무 똑똑한 컴파일러 때문에 발생하는 문제를 해결하려면 테스트에 사용할 데이터를 일련번호 대신 임의의 숫자를 생성해 사용해야 한다. 하지만 너무 허술한 난수 발생기를 사용하면 이 또한 테스트 결과가 잘못 나올 수 있다.
    - 허술한 난수 발생기는 현재 시간과 클래스 간에 종속성이 있는 난수를 생성하는 경우가 있는데, 대부분의 난수 발생기가 스레드 안전성을 확보한 상태이고 추가적인 동기화 작업이 필요하기 때문이다.
    - 각 테스트 스레드마다 독립적인 난수 발생기 인스턴스를 사용하도록 하면 스레드 안전성 때문에 동기화하느라 성능의 병목을 야기하는 경우를 막을 수 있다.
    - 범용 난수 발생기를 사용하는 대신 아주 간단한 난수 발생기를 사용하는 것도 좋은 방법.
    - 테스트 프로그램을 실행할 때마다 어느 정도 적절한 임의성만 확보하면 된다.
- 예제 12.4 테스트 프로그램에 적합한 중간 품질의 난수 생성기
    - 싼값에 중급의 품질을 제공하는 난수 발생기,
    - 클래스 인스턴스의 hashCode 값과 nanoTime값을 사용해 xorShift 메소드를 사용하면 거의 예측할 수 없을 뿐더라 실행할 때마다 난수 생성 가능
~~~
static int xorShift(int y) {
    y ^= (y << 6);
    y ^= (y >>> 21);
    y ^= (y << 7);
    return y;
}
~~~ 
- 예제 12.5와 예제 12.6의 PutTakeTest 클래스는 항목을 생성하는 큐에 쌓는 프로듀서 스레드를 N개 생성해 실행시키고, 큐에 쌓인 항목을 뽑아내는 N개의 컨슈머 스레드를 역시 생성해 실행한다.
- 예제 12.5 BoundedBuffer 를 테스트하는 프로듀서-컨슈머 구조의 테스트 프로그램, 예제 12.6 PutTakeTest에서 사용한 프로듀서 클래스와 컨슈머 클래스
    - 항목을 생성해서 큐에 쌓는 프로듀서 스레드를 N개 생성해 실행시키고, 큐에 쌓인 항목을 뽑아내는 N개의 컨슈머 스레드를 생성해 실행
    - 각 스레드는 큐에 항목을 추가하거나 제거할 때마다 각 스레드마다 나눠져 있는 각자의 체크섬을 업데이트 하고, 각자의 체크섬은 테스트가 끝나는 시점에 하나로 합해 결과가 올바른지 테스트한다.
    - 각 스레드마다 체크섬을 따로 운영하면 따로 동기화할 필요도 없고 따라서 경쟁이 발생하지 않으므로 실제로 원하는 테스트에만 집중 가능
~~~java
public class PutTakeTest {
    private static final ExecutorService pool = Executors.newCachedThreadPool();
    private final AtomicInteger putSum = new AtomicInteger(0);
    private final AtomicInteger takeSum = new AtomicInteger(0);
    private final CyclicBarrier barrier;
    private final BoundedBuffer<Integer> bb;
    private final int nTrials, nPairs;

    public static void main(String[] args) {
        new PutTakeTest(10, 10, 10000).test(); // 예제 인자 값
        pool.shutdown();
    }

    PutTakeTest(int capacity, int nPairs, int nTrials) {
        this.bb = new BoundedBuffer<Integer>(capacity);
        this.nPairs = nPairs;
        this.nTrials = nTrials;
        this.barrier = new CyclicBarrier(nPairs * 2 + 1);
    }

    void test() {
        try {
            IntStream.range(0, nPairs)
                    .forEach(i -> {
                        pool.execute(new Producer());
                        pool.execute(new Consumer());
                    });
            barrier.await(); // 모든 스레드가 준비될 때까지 대기
            barrier.await(); // 모든 스레드의 작업이 끝날 때까지 대기
            assertEquals(putSum.get(), takeSum.get());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    class Producer implements Runnable {
        @Override
        public void run() {
            try {
                int seed = (this.hashCode() ^ (int) System.nanoTime());
                int sum = 0;
                barrier.await();
                for(int i = nTrials; i > 0; --i) {
                    bb.put(seed);
                    sum += seed;
                    seed = xorShift(seed);
                }
                putSum.getAndAdd(sum);
                barrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    class Consumer implements Runnable {
        @Override
        public void run() {
            try {
                barrier.await();
                int sum = 0;
                for(int i = nTrials; i > 0; --i) {
                    sum += bb.take();
                }
                takeSum.getAndAdd(sum);
                barrier.await();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
~~~ 
- 플랫폼마다 다르지만 스레드를 생성하고 실행하는 일이 상당히 부하가 걸리는 작업일 가능성도 있다.
- 스레드가 처리할 작업이 굉장히 짧은 시간이면 충분한 작업일 때 이와 같은 스레드를 반복문 내부에서 차례로 생성해 실행시킨다면 결국 최악의 경우 각 스레드가 병렬로 실행되는 대신 순차적으로 실행될 가능성도 있다.
    - ex : 최초에 실해오딘 스레드는 한동안 혼자만 실행될 것이고, 그 다음 스레드가 실행되면 일부분만 두 개의 스레드가 함께 실행되며, 마지막 스레드까지 모두 실행된 이후에야 스레드가 병렬로 동작하게 된다.
- 이와 같은 문제의 해결 방법은 CountDownLatch 사용해 모든 스레드가 준비될 때까지 대기하고 또 다른 CountDownLatch를 사용해 스레드가 완료될 때까지 대기하기
- CyclicBarrir를 사용해도 이와 같은 효과 가능
    - 작전체 작업 스레드의 개수에 1을 더한 크기로 초기화해두고, 작업 스레드와 테스트 프로그램이 시작하는 시점에 모두 동시에 시작할 수 있도록 대기하고, 끝나는 시점에도 한꺼번에 끝내도록 대기하는 방법
- PutTakeTest 역시 이와 같은 방법을 사용해 작업 스레드가 한꺼번에 시작하고 한꺼번에 종료하도록 하고 있으며 여러 개의 스레드가 병렬로 처리되는 상황을 훨씬 자 ㄹ묘사할 수 있다.
- 그렇다 해도 그 내부에서 스케쥴러가 작업 스레드를 순차적으로 실행시키지 않는다는 보장은 없다.
- PutTakeTest 에 적용돼 있는 마지막 테크닉은 테스트가 끝났음을 알리느라 스레드 간에 통신 기능을 구현하는 대신, 테스트가 시작할 때 이미 종료 조건을 결정지어두는 방법
- test 메소드가 시작되면 동일한 숫자의 프로듀서와 컨슈머가 생성된다.
- 각 프로듀서는 항목을 추가하고, 각 컨슈머는 항목을 뽑아내기 때문에 전체적으로 추가된 항목의 수와 제거된 항목의 수는 일치한다.
- PutTakeTest 와 같은 유형의 테스트 프로그램은 테스트 대상의 안전성을 확인하기에 좋다.
    - ex : 세마포어로 제어하는 버퍼를 구현할 때 범하기 쉬운 오류 중의 하나는 바로 항목을 추가하거나 뽑아내는 작업이 상호 배타적인 상태에서 이뤄져야 한다는 점을 잊은 채 동기화를 빼먹고 구현하는 부분이다.
    - 만약 doInsert와 doExtract 메소드의 동기화 구분을 빼먹은 버전의 BoundedBuffer 를 대상으로 PutTakeTest 프로그램을 돌려보면 오류 찾기 바로 가능
    - 따라서 수십개의 스레드를 사용하도록 설정하고, 각 스레드마다 수백 만개의 put 또는 take 연산을 실행하도록 하며, 버퍼의 크기도 다양하게 지정해보고, 다양한 플랫폼에서 PutTakeTest 프로그램으로 테스트를 거친다면 완벽한 결과 얻는다.
- 테스트 프로그램은 스레드가 교차 실행되는 경우의 수를 최대한 많이 확보할 수 있도록 CPU가 여러 개 장착된 시스템에서 돌려보는게 좋다. 그렇다고 CPU가 수십개 달렸다고 해서 서너 개의 CPU가 장착된 시스템에 비해 테스트 효율이 좋다고 보기는 어렵다.
- 절묘한 타이밍에 공유된 데이터를 사용하다 나타나는 오류를 찾으려면 CPU가 많이 있는 것보다 스레드를 더 많이 돌리는 편이 낫다. 스레드가 많아지면 실행중인 스레드와 대기 상태에 들어간 스레드가 서로 교차하면서 스레드 간의 상호 작요잉 발생하는 경우의 수가 많아지기 때문이다.
- 미리 지정된 개수만큼의 연산을 실행하고 테스트를 마치는 프로글매은 테스트 도중에 테스트 대상 클래스의 버그로 인해 예외가 발생하는 등의 상황에 맞닥뜨리면 테스트 프로그램이 종료되지 않고 계속해서 실행될 가능성이 있다.
- 이런 위험을 방지할 수 있는 가장 간편한 방법은 테스트 프로그램이 동작하는 시간에 제한을 두고 제한된 시간이 넘어가도 프로그램이 종료되지 않으면 테스트를 중단하는 방법
- 제한시간을 넘기는 문제가 발생한다면 실제로 프로그램에 오류가 있는 것인지 아니면 좀 더 오래 기다렸어야 하는지를 분석해서 확인해야 한다.

### 12.1.4 자원 관리 테스트
- 테스트 프로그램을 테스트하고자 하는 두 번째 측면은 하지 말아야 할 일을 실제로 하지 않는지 테스트 하는 일(ex : 자원을 유출하는 일, 다른 객체를 사용하거나 관리하는 모든 객체는 더 이상 필요하지 않는 객체ㄴ에 대한 참조를 갖고 있으면 안됨.)
- 이처럼 데이터를 갖고 있는 객체의 참조를 해체하지 않고 유출되면 GC가 메모리(또는 스레드, 파일 핸들, 네트워크 소켓, DB연결 등의 제한적인 자원)를 확보할 수 없다. 그럼 오류 발생
- 자원을 관리하는 문제는 BoundedBuffer 와 같은 클래스에서는 더욱 큰 문제이다.
    - 버퍼의 크기를 제한하는 이유는 오로지 프로듀서가 컨슈머보다 빨리 동작해서 자원이 고갈되는 상황을 방지하고자 하는 것.
    - 버퍼의 크기를 제한해두면 너무 활발하게 동작하는 프로듀서의 활동을 필요한 만큼 멈추도록 할 수 있으며, 그 결과 메모리와 기타 자원 소모 방지
- 메모리를 원하지 않음에도 계쏙해서 잡고 있는 경우가 있는지 확인하려면 애플리케이션이 사용하는 메모리의 상황을 들여다 볼 수 있는 힙 조사용 도구를 사용해볼만 한다.
- 예제 12.7 자원 유출 테스트
~~~java
public class Test {
    class Big {
            double[] data = new double[10000];
    }
    
    void teskLeadk() throws InterruptedException {
        BoundedBuffer<Big> bb = new BoundedBuffer<Big>(CAPACITY);
        int heapSize1 = /* 힙 스냅샷 */ ;
        for(int i = 0; i < CAPACITY; i++) {
            bb.put(new Big());
        }
        
        for(int i = 0; i < CAPACITY; i++) {
            bb.take();
        }
        
        int heapSize2 = /* 힙 스냅샷 */ ;
        
        assertTrue(Math.abs(heapSize1 - heapSize2) < THRESHOLD);
    }
}
~~~
- 12.7의 takeLeak 메소드는 크기가 제한된 버퍼에 상당한 메모리를 차지하는 객체를 여러 개 추가하고, 추가된 객체를 제거한다.
- 그러면 버퍼에는 아무런 내용이 없기 때문에 2번 자리에서 측정한 메모리 사용량이 1번 위치에서 측정한 메모리 사용량과 비교할 때 거의 차이가 없어야 한다.
- 해당하는 위치에는 힙 조사 도구가 생성한 코드가 들어가는데, 힙 조사 도구가 추가한 코드는 GC를 강제로 실행하고 힙 사용량과 기타 메모리 사용 현황을 불러오는 기능 담당.
- takeLeak 메소드는 크기가 제한된 버퍼에 상당한 메모리를 차지하는 객체를 여러 개 추가하고, 추가된 객체를 제거
    - 만약에 doExtract 메소드에서 뽑혀 나간 객체를 담고 있던 부분의 참조를 null로 세팅하지 않았다면 양쪽 지점에서 측정한 메모리 사용량이 분명히 다를 것이다.

### 12.1.5 콜백 사용
- 클라이언트가 제공하는 코드에 콜백 구조를 적용하면 테스트 케이스를 구현하는 데 도움이 된다.
- 콜백 함수는 객체를 사용하는 동안 중요한 시점마다 그 내부의 값을 확인시켜주는 좋은 기회로 사용할 수 있다.
- ThreadPoolExecutor 클래스가 작업을 담당하는 Runnable과 스레드를 생ㅅ어하는 ThreadFactory의 여러 콜백 함수를 호출하는 예를 보면 알기 쉽다.
- 스레드 풀이 제대로 동작하는지 테스트하려면 실행 정책에 맞게 여러 측면에서 적절한 수치를 뽑아낼 수 있는지를 테스트하면 된다.
    - ex : 스레드를 생성해야 할 시점이라면 스레드가 생성되어야 함.
    - 스레드 생성 시점이 아니라면 스레드가 생성되면 안됨.
- 원하는 기능 모두를 완벽하게 테스트할 수 있는 프로그램을 작성하려면 상당한 양의 노력을 들여야 한다. 
- 하지만 테스트하고자 하는 기능 가운데 대부분은 그 테스트 프로그램을 상대적으로 간단하게 작성할 수 있는 경우가 많다.
- 먼저 ThreadPoolExecutor 클래스에서 테스트용으로 작성한 TestingThreadFactory 를 사용해 스레드 생성해보기
- 예제 12.8 ThreadPoolExecutor를 테스트하기 위한 TestingThreadFactory
~~~java
public class Example12_8 {
    class TestingThreadFactory implements ThreadFactory {
        public final AtomicInteger numCreated = new AtomicInteger(); // 생성된 스레드의 개수 세는 기능
        private final ThreadFactory factory = Executors.defaultThreadFactory();
        
        @Override
        public Thread newThread(Runnable r) {
            numCreated.incrementAndGet();
            return factory.newThread(r);
        }
    }
}
~~~
- 실제 테스트 케이스에서는 TestingThreadFactory가 알고 있는 스레드의 개수가 올바른지 확인해볼 수 있다.
- 이에 더해 기능이 추가된 Thread객체를 생성하도록 TestingThreadFactory 를 좀 더 변경하면 생성된 스레드가 언제 종료되는지를 추적할 수 있다.
    - 테스트 케이스는 없어져야 할 스레드가 적절한 시점에 올바르게 사라졌는지도 확인 가능
- ex : 코어 풀 크기가 최대 풀 크기보다 작에 설정돼 있다면 실행할 대상이 늘어날 때마다 스레드의 개수가 함께 늘어나야 한다.
- 스레드 풀에 오래 실행될 작업을 많이 추가해두면 예제 12.9에서 보다시피 스레드 개수가 올바르게 늘어나는지 등의 수치를 확인하기에 충분할 만큼 어느정도 시간을 벌어주는 역할을 한다.
- 예제 12.9 스레드 풀의 개수가 제대로 늘어나는지를 확인할 수 잇는 테스트 케이스
~~~java
public class Example12_9 extends TestCase {
    public void testPoolExpansion() throws InterruptedException  {
        int MAX_SIZE = 10;
        Example12_8.TestingThreadFactory threadFactory = new Example12_8.TestingThreadFactory();
        ExecutorService exec = Executors.newFixedThreadPool(MAX_SIZE, threadFactory);
        
        for(int i = 0; i < 10 * MAX_SIZE; i++) {
            exec.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(Long.MAX_VALUE);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        
        for(int i = 0; i < 20 && threadFactory.numCreated.get() < MAX_SIZE; i++) {
            Thread.sleep(100);
        }
        
        assertEquals(threadFactory.numCreated.get(), MAX_SIZE);
        exec.shutdownNow();
    }
}
~~~
### 12.1.6 스레드 교차 실행량 확대
- 병렬 프로그램에서 나타나는 오류의 대부분 발생 확률이 상당히 낮은 경우가 ㅁ낳다.
- 따라서 병렬 프로그램의 오류를 찾아내는 테스트 과정은 수치와의 싸움이지만, 확률을 높이는 방법이 있다.
- 이미 몇 개의 CPU 프로세서가 장착된 하드웨어에서 CPU의 개수보다 많은 수의 스레드로 동작하는 프로그램이 단일 CPU 하드웨어나 CPU의 개수가 많은 하드웨어에서 동작하는 프로그램보다 교차 실행되는 양이 많다.
- 이와 비슷하게 CPu 프로세서의 개수, 운영체제, 프로세서 아키텍쳐 등을 다양하게 변경하면서 테스트해보면 특정 시스템에서만 발생하는 오류 찾아낼 수 있다.
- 스레드의 교차 실행 정도를 크게 높이고 그와 동시에 테스트할 대상 공간을 크게 확대시킬 수 있는 트릭이 있는데, 공유된 자원을 사용하는 부분에서 Thread.yeild 메소드를 호출해 컨텍스트 스위치가 많이 발생하도록 유도하기.
- 예제 12.10에서 나타난 코드를 보면 한쪽 계좌에서 일정 금액을 다른 계좌로 이체하는데 값을 변경하는 두 번의 연산 가운데 "양쪽 계좌 잔액의 합은 항상 0이다" 라는 명제가 일치하지 않는 시점이 존재
    - 작업 도중에 Thread.yeild 메소드를 호출해주면 동기화 방법을 사용하지 않는 경우 발생할수 있는 버그가 실제로 노출되는 가능성을 높일 수 있다.
    - Thread.yeild와 같이 테스트때는 사용하다가 상용으로 사용할때는 해당 코드를 제거해야 하는 경우에는 관점 지향 프로그래밍 기법으로 간편하게 처리 가능
- 예제 12.10 Thread.yeild 메소드를 사용해 교차 실행 가능성을 높이는 방법
~~~java
public class Example12_10 {
    public synchronized void transferCredis(Account from, Account to, int amount) {
        from.setBalance(from.getBalance - amount);
        if(random.nextInt(1000) > THREADHOLD) {
            Thread.yield();
        }
        to.setBalance(to.getBalance + amount);
    }
}
~~~
    
     
 