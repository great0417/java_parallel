# 07 중단 및 종료
- 작업이나 스레드를 시작시키기는 쉽지만 안전하고 빠르고 안정적으로 멈추게 하는 것은 어려운 일이다.(더군다나 자바에는 스레드가 작업을 실행하고 있을 때 강제로 멈추도록 하는 방법이 없다.)
- 대신 특정 스레드에게 작업을 멈춰달라고 요청하는 인터럽트를 사용할 수 있다. 
    - 실제 상황에서 특정 스레드나 서비스를 즉시 멈춰야 할 경우가 거의 없고, 강제로 종료하면 공유되어있는 자원이 비정상적인 상태에 놓을 수 있기 때문이다. 
    - 작업이나 서비스를 실행하는 부분의 코드를 작성할 때 멈춰달라는 요청을 받으면 진행중이던 작업을 모두 정리한 다음 종료하도록 만들어야 한다.
- 오류가 발생하는 경우, 종료하는 경우, 작업을 취소하는 경우에 적절하게 대응하는 프로그램을 만드는게 중요하다
- 7장에서는 작업을 취소하고 인터럽트를 거는 부분에 대한 개념 설명 및, 작업이나 서비스가 취소 요청에도 잘 반응하도록 프로그램하는 방법을 살펴본다

## 7.1 작업 중단
- 실행중인 작업을 취소하고자 하는 요구사항
    - 1. 사용자가 취소하기를 요청한 경우 : 사용자가 GUI에서 취소 버튼을 클릭하거나, JMX 등의 관리 인터페이스를 통해 작업을 취소하도록 하는 경우
    - 2. 시간이 제한된 작업 : 일정한 시간 이내에 결과를 찾다가 제한된 시간이 지나면 그 동안 찾았던 결과 가운데 가장 좋은 값을 사용하도록 프로그램을 작성하는 경우 제한된 시간이 지나면 동작중이던 작업은 모두 취소
    - 3. 애플리케이션 이벤트 : 원하는 결과를 얻기 위해 다양한 조건을 지정해 여러 작업을 동시에 실행시키는 경우 원하는 값이 나올 시 나머지 실행중이던 작업은 모두 취소하
    - 4. 오류 : 웹 크롤러가 찾다가 특정 작업에서 오류(ex: 디스크 가득 참) 발생시 다른 작업도 모두 취소. 현재 작업이 무엇인지 기록하는 작업은 필요할 수 있다.
    - 5. 종료 : 애플리케이션이나 서미스를 종료할 때에는 처리하는 중이었던 작업에 대한 내용이건, 처리하기 위해 큐에서 대기하던 항목이건 마무리 절차 필요. 
- 자바 언어에서 특정 스레드를 명확하게 종료시킬 수 있는 방법은 없다. 작업을 실행하는 스레드와 작업을 취소했으면 한다고 요청하는 스레드가 함께 작업을 멈추는 협력적인 방법을 사용해야만 한다.
- 가장 기본적인 형태는 '취소 요청이 들어왔다'는 플래그를 설정하고 실행중인 작업은 취소 요청 플래그를 주기적으로 확인하는 방법이다.
- 예제 7.1 volatile 변수를 사용해 취소 상태를 확인, 예제 7.2 1초간 소수를 계산하는 프로그램
~~~java
@ThreadSafe
public class PrimeGenerator implements Runnable {  // 취소 요청 플래그가 설정되면 작업 멈추는 작업이 가장 기본적인 취소 정책.
    @GuardedBy("this") private final List<BigInteger> primes = new ArrayList<BigInteger>();
    private volatile boolean cancelled;
    
    public void run() {
        BigInteger p = BigInteger.ONE;
        while(!cancelled) {  // 취소 요청이 들어왔다는 플래그가 설정되면 실행하던 작업을 멈춤
            p = p.nextProbablePrime(); // 취소 요청이 올 때까지 소수를 찾아내는 작업
            synchronized (this) {
                primes.add(p);
            }
        }
    }
    
    public void cancel() {cancelled = true;}
    
    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }
}

class startThread {
    List<BigInteger> aSecondOfPrices() throws InterruptedException {
        PrimeGenerator generator = new PrimeGenerator();
        new Thread(generator).start(); //스레드 실행
        try{
            SECONDS.sleep(1); //1초 후에 소수 계산 작업을 멈추도록 함(정확히 1초 후는 아닐 수 있음)
        } finally{
            generator.cancel(); //인터럽트가 걸려도 소수 계산 작업은 반드시 멈춤, 멈추지 않는다면 소수 계산 작업은 멈추지 않고, cpu 자원 낭비, JVM도 종료되지 않도록 막음.
        }
        return generator.get();
    }
}
~~~
- 작업을 쉽게 취소시킬 수 있도록 만들려면 작업을 취소하려 할 때 '어떻게', '언제', '어떤 일'에 대한 취소 정책을 명확히 정의해야 한다. 
- ex : 수표에 대한 지급을 중단하기 (근데 이것보다 쇼핑몰에서 옷 환불하는 취소 정책이 더 낫지 않을까?) 
    - 은행에서는 수표에 대한 지급을 중단해 달라는 요청을 어떻게 보내야 하는지 명확하게 설명한다
    - 요청이 들어온 이후 얼마만의 시간 안에 처리해 줄 수 있는지도 명시한다
    - 실제로 지급이 중지되면 어떤 절차가 진행되는지도 설명한다.    
    - 작업 절차와 진행될 일에 대해 설명하는 일에 대해 설명하는 일이 수표 지급에 대한 취소 정책     
- 7.1.1 인터럽트
    - PrimeGenerator 클래스의 작업 취소 방법은 결국 소수를 찾는 작업을 멈추게 하지만 때에 따라 실제로 종료하는 데 시간이 꽤 걸릴 수도 있다. 
    - 이와 같은 취소 방법을 사용하는 작업 내부에서 BlockingQueue.put과 같은 블로킹 메소드를 호출하는 부분이 있었다면 훨씬 큰 문제가 발생할 수 있다. (왜? 공간이 가득 차있다면 마냥 대기하니깐)
    - 심지어는 작업 내부에서 취소 요청이 들어왔는지를 확인하지 못하는 경우도 생길 수 있을 것이며, 그 경우 작업이 영원히 멈추지 못한다.
    - 예제 7.3 프로듀서가 대기 중인 상태로 계속 멈춰 있을 가능성이 있는 안전하지 않은 취소 방법의 예. 
~~~java
public class Example7_3 {
    class BrokenPrimeProducer extends Thread {
        private final BlockingQueue<BigInteger> queue;
        private volatile boolean cancelled = false;

        BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
            this.queue = queue;
        }

        @Override
        public void run() {
            try {
                BigInteger p = BigInteger.ONE;
                while (!cancelled) {
                    queue.put(p = p.nextProbablePrime()); //소수를 찾은 후 블로킹 큐에 집어 넣는다. 컨슈머가 가져가는 것보다 프로듀서가 소수를 찾아내는 속도가 더 빠르다면 put 메소드는 블록
                }
            } catch (InterruptedException consumed) {}
        }

        public void cancel() {cancelled = true;}
    }

    void consumerPrimes() throws InterruptedException {
        BlockingQueue<BigInteger> primes = ...;
        
        BrokenPrimeProducer primeProducer = new BrokenPrimeProducer(primes);
        
        primeProducer.start();
        try {
            while (needMorePrimes()) {
                consume(primes.take());
            }
        } finally {
            /**
                부하가 걸린 컨슈머가 큐에 put하려고 대기중인 프로듀서의 작업을 취소시키려 한다면 cancelled 플래그는 변경되지만 프로듀서는 put에서 멈추고 
                put 메소드에서 멈춘 작업을 풀어줘야 할 컨슈머가 더이상 작업을 처리하지 못하기 때문에 cancelled 변수를 확인할 수 없다.
            **/
            primeProducer.cancel(); 

        }
    }
}
~~~
-
    - 5장에서 언급했던 것처럼 블로킹 될 수 있는 라이브러리 가운데 일부는 인터럽트를 걸 수 있다.
    - 스레드에 거는 인터럽트는 특정 스레드에게 적당한 상황이고 작업을 멈추려는 의지가 있는 상황이라면, 현재 실행 중이던 작업을 멈추고 다른 일을 할 수 있도록 해야 한다고 신호를 보내는 것과 같다.
    - API나 언어 명세 어디를 보더라도 인터럽트가 작업을 취소하는 과정에 어떤 역할을 하는 지에 대해 명시되어 있는 부분은 없다. 하지만 실제 상황에서는 작업을 중단하고자 하는 부분이 아닌 다른 부분에 인터럽트를 사용한다면 오류가 발생하기 쉬울 수밖에 없으며, 애플리케이션의 규모가 커질 수록 관리하기도 어려워진다.
    - 모든 스레드는 불린 값으로 인터럽트 상태를 갖고 있다. 스레드에 인터럽트를 걸면 인터럽트 상태 변수의 값이 true로 설정된다. 
    - 예제 7.4 Thread 클래스의 인터럽트 관련 메소드 
    - ![thread 메소드](/image/thread_method.PNG)
    - Thread 클래스에는 인터럽트를 거는 메소드, 인터럽트가 걸린 상태인지 확인할 수 있는 메소드도 있다. 
    - 스태틱으로 선언된 interrupted 메소드를 호출하면 현재 스레드의 인터럽트 상태를 해제하고, 해제하기 이전의 값이 무엇이었는지 알려준다. interruped 메소드는 인터럽트 상태를 해제할 수 있는 유일한 방법.
    - Thread.sleep이나 Object.wait 메소드와 같은 블로킹 메소드는 인터럽트 상태를 확인하고 있다가 인터럽트가 걸리면 즉시 리턴된다. 
    - Thread.sleep이나 Object.wait 메소드에서 대기하던 중에 인터럽트가 걸리면 인터럽트 상태를 해제하면서 InterruptedException을 던진다.
    - Thread.sleep이나 Object.wait 메소드에서 인터럽트가 걸렸을 때 인터럽트가 걸렸다는 사실을 얼마나 빠르게 확인하는지는 JVM에서도 아무런 보장을 하지 않는다.(하지만 일반적으로 볼 때 무리하게 늦게 반응하는 경우는 없다고 본다.)
    - 스레드가 블록되어 있지 않은 실행 상태에서 인터럽트가 걸린다면 인터럽트 상태 변수가 설정되긴 하지만 인터럽트가 걸렸는지 확인하고, 인터럽트가 걸렸을 경우 그에 대응하는 일을 해당 스레드에서 알아서 해야 한다.
    - 특정 스레드의 interrupt 메소드를 호출한다 해도 해당 스레드가 처리하던 작업을 멈추지는 않는다. 단지 해당 스레드에게 인터럽트 요청이 있었다는 메시지를 전달할 뿐이다.
    - wait, sleep, join과 같음 메소드는 인터럽트 요청을 굉장히 심각하게 처리하는데, 인터럽트 요청을 받거나 실행할 때 인터럽트 상태라고 지정했던 시점이 되는 순간 예외를 띄운다. 
    - 인터럽트 요청을 무시할 생각이 아니라면 InterruptedException을 띄우거나, interrupt 메소드를 호출해 인터럽트 상태를 되돌려줘야 한다.
    - BrokenPriceProducer 클래스를 보면 각자 작성한 스레드 종료 방법이 자바 라이브러리 가운데 블록될 수 있는 메소드와 항상 원할하게 연동되지는 않는다는 사실을 알 수 있다
        - 그러므로 작업 취소 기능을 구현하고자 할 때는 인터럽트가 가장 적절한 방법이라고 볼 수 있다.
    - 예제 7.5 인터럽트를 사용해 작업을 취소
~~~java
public class PrimeProducer extends Thread {
    private final BlockingQueue<BigInteger> queue;
    
    PrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while(!Thread.currentThread().isInterrupted()) { //인터럽트 상태 확인(여기도 두는 이유는 소수를 계산하는 것처럼 오래 걸리는 작업을 애초에 안하기 위해
                queue.put(p = p.nextProbablePrime()); // 인터럽트 상태 확인
            }
        } catch (InterruptedException consumed) {
            /* 스레드를 종료한다. */
        }
    }
}
~~~
- 7.1.2 인터럽트 정책
    - 단일 작업마다 해당 작업을 멈출 수 있는 취소 정책이 있는 것처럼 스레드 역시 인터럽트 처리 정책이 있어야 한다.(추후 제거)
    - 인터럽트 처리 정책은 인터럽트 요청이 들어 왔을 때, 해당 스레드가 인터럽트를 어떻게 처리해야 하는지에 대한 지침.
        - ex : 인터럽트가 걸렸다는 사실을 확인하고 나면, 어디에서 무슨 일을 하고, 인터럽트ㅔ 대비해 단일 연산으로 보호할 수 있는 범위가 어디까지인지도 확인해야 하며, 인터럽트가 발생했을 때 해당하는 인터럽트에 어떻게 재빠르게 대응할 지 등의 지침
    - 최대한 빠르게 중단시킬 수 있고, 사용하던 자원은 적절하게 정리하고, 가능하다면 작업 중단을 요청한 스레드에게 작업을 중단하고 있다는 사실을 알려줄 수 있으면 가장 좋겠다.
    - 작업과 스레드가 인터럽트 상황에서 서로 어떻게 동작해야 하는지를 명확히 구분할 필요가 있다. 
        - 인터럽트 요청 하나로 중단시키고자 하는 대상이 여럿일 수 있기 때문 
        - 스레드 풀에서 작업을 실행하는 스레드에 인터럽트를 거는 것은 '현재 작업을 중단하라'일수도 '작업 스레드를 중단시켜라'는 뜻일 수도 있다. 
    - 작업은 그 작업을 소유하는 스레드에서 실행되지 않고, 스레드 풀과 같이 실행만 전담하는 스레드를 빌려 사용하게 된다.
        - 실제로 작업을 실행하는 스레드를 갖고 있지 않은 프로그램은 작업을 실행하는 스레드의 인터럽트 상태를 그대로 유지해 스레드를 소유하는 프로그램이 인터러브 상태에 직접 대응할 수 있도록 해야 한다.
        - ex : 누군가 집을 비웠을 때 그 집을 잠시 봐주는 상황에서 원래 주인이 자리를 비웠을 때 우편물이 배달되면 우편물을 고이 모아뒀다가 주인이 돌아왔을때 돌려주는게 상식이다. 
    - 대부분의 블로킹 메소드에서 인터럽트가 걸렸을 때 InterruptedException을 그래서 던진다.
    - 외부 작업이나 자바 내부의 라이브러리 메소드에서 동시에 적용할 수 있는 가장 적절한 인터럽트 정책, 즉 실행 중에 최대한 빨리 작업을 중단하고 자신을 호출한 스레드에게 전달받은 인터럽트 요청을 넘겨 인터럽트에 대응해 추가적인 작업을 할 수 있도록 배려하는 정책을 구현함.
    - 반드시 인터럽트가 발생했을때 포기하고 중단할 필요는 없고, 끝까지 마친 다음에 InterruptedException을 던지거나 기타 다른 방법으로 대응도 가능하다.(이경우 데이터가 깨지거나 날아가는 오류 상황 예방 가능)
    - 가장 일반적인 방법은 InterruptedException을 던지는 것인데, 그렇게 하지 못한다 해도 Thread.currentThread().interrupt(); 코드를 실행해 스레드의 인터럽트 상태를 유지해야 한다.
    - 작업 취소 기능을 담당하는 코드 역시 각종 스레드에 대한 인터럽트 정책이 어떻다고 섣불리 가정하면 안된다.  스레드에는 해당 스레드를 소유하는 클래스에서만 인터럽트를 걸어야 한다. 
    - 자바에서 제공하는 인터럽트 기능과 관련해서 여러가지 비판적인 의견이 있다
        - 1. 선점형 인터럽트 기능을 제공 안함.
        - 2. 개발자로 하여금 직접 InterruptedException을 처리하도록 가요
    - 인터럽트에 대한 실제적인 중단 시점을 개발자가 임의로 늦출 수도 있도록 하는것은 프로그램의 응답성과 안정성을 능동적으로 관리할 수 있는 기회를 제공하는 것이다.
- 7.1.3 인터럽트에 대한 대응
    - Thread.sleep이나 BlockingQueue.put 메소드와 같이 인터럽트를 걸 수 있는 블로킹 메소드를 호출하는 경우에 InterruptedException이 발생시 처리할 수 있는 실질적인 방법 2가지
        - 1. 발생한 예외를 호출 스택의 상위 메소드로 전달. 이 방법을 사용하는 메소드 역시 인터럽트를 걸 수 있는 블로킹 메소드가 된다. 
        - 2. 호출 스택의 상다에 위치한 메소드가 직접 처리할 수 있도록 인터럽트 상태를 유지한다.
    - 예제 7.6 InterruptedException을 상위 메소로 전달
~~~java
public class Exapmle7_6 {
    public Task getNextTask() throws InterruptedException { // 이것만으로 충분
        return queue.take();
    }
}
~~~
-
    - InterruptedException을 상위 메소드에 전달할 수 없거나 전달하지 않고자 하는 상황이라면 인터럽트 요청이 들어왔따는 것을 유지할 수 있는 다른 방법을 찾아야 한다.
        - 일반적으로 interrupt 메소드를 다시 한번 호출
    - 반대로 catch(InterruptedException e) 블록에서 아무 행동을 취하지 않는건 하지 말아야 한다. 
    - 그러나 PrimeProducer 클래스처럼 인터럽트 요청을 삼켜도 종료될 예정이며 상위 메소드에서 해당 스레드가 인터럽트에 걸렸다는 사실을 알 필요가 없는 것과 같이 잘 구현되어 있다면 안해도 된다.
    - 대부분의 프로그램 코드는 자신이 어느 스레드에서 동작할지 모르기 때문에 인터럽트 상태를 최대한 그대로 유지해야 한다.     
      
     