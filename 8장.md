# 08 스레드 풀 활용
- 6장은 작업과 스레드 등의 라이프 사이클을 수비게 전반적으로 관리할 수 있으며 작업을 정의하는 부분과 작업을 실행하는 부분을 구조적으로 분리할 수 있도록 도와주는 작업 실행 프로엠워크 배움
- 7장은 실제 애플리케이션을 작성할 때 작업 실행 프레임워크를 사용하면서 쉽게 눈에 띄는 작업과 스레드 라이프 사이클 문제를 다룸
- 이번 장에서는 스레드 풀을 설정하고 튜닝하는데 사용할 수 있는 고급 옵션을 살펴보고, 작업 실행 프레임워크를 사용할 때 흔히 발생할 수 있는 난관을 헤쳐 나가는 방법과 함께 Executor를 사용하는 고급 예제도 소개

## 8.1 작업과 실행 정책 간의 보이지 않는 연결 관계
- Executor 프레임워크는 작업의 정의 부분과 실행 부분을 서로 분리시켜 준다.
- Executor 프레임워크가 나름대로 실행 정책을 정하거나 변경하는데 있어서 어느정도의 유연성을 갖고 있지만 특정 형태의 실행할 수 없는 작업이 있기도 하다.
    - 1. 의존성이 있는 작업 : 독립적일 경우 상관이 없지만 의존성을 갖는 작업을 스레드 풀에 올려 실행하려는 경우에는 실행 정책에 조건을 거는 셈이다. 스레드 풀이 동작하는 동안 활동성 문제가 발생하지 않도록 하려면 시행 정책에 대한 보이지 않는 조건을 면밀하게 조사하고 관리해야 하낟.
    - 2. 스레드 한정 기법을 사용하는 경우 : Executor 프레임워크가 마음대로 사용하려면 단일 스레드로 동작해야 한다는 조건이 생기기 때문에 작업과 실행 정책 간에 보이지 않는 연결고리가 걸려 있는 상황이다. 이런 경우 단일 스레드를 사용하는 풀 대신 여러 개의 스레드를 사용하는 풀로 변경하면 안정성을 쉽게 잃을 수 있다.
    - 3. 응답 시간이 민감한 작업 : 단일 스레드로 동작하는 Executor에 오랫동안 실행될 작업을 등록하거나, 서너개의 스레드로 동작하는 풀에 실행 시간이 긴 작업을 몇개만 등록하더라도 해당 Executor를 중심으로 움직이는 화면 관련 부분은 응답 성능이 크게 떨어질 수 있다.
    - 4. ThreadLocal을 사용하는 작업 : ThradLocal을 사용하면 각 스레드에서 같은 이름의 값을 각자의 버전으로 유지할 수 있다. 그런데 Executor는 상황이 되는대로 기존의 스레드를 재사용한다. 스레드 풀에 속한 스레드에서 ThreadLocal을 사용할 때에는 현재 실행 중인 작업이 끝나면 더 이상 사용하지 않을 값만 보관해야 한다.
- 스레드 풀은 동일하고 서로 독립적인 다수의 작업을 할 때 효과적이다. 다행스럽게도 일반적인 네트워크 기반의 서버 애플리케이션은 작업이 서로 동일하면서 독립적이어야 한다는 조건을 대부분 만족한다.
- 8.1.1 스레드 부족 데드락 
    - 스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높다. 
    - 단일 스레드로 동작하는 Executor에서 다른 작업을 큐에 등록하고 해당 작업이 실행된 결과를 가져다 사용하는 작업을 실행하면, 데드락이 제대로 걸린다.
    - 이전 작업이 추가한 두 번째 작업은 큐에 쌓인 상태로 이전 작업이 끝나길 기다릴 것이고, 이전 작업은 추가된 작업이 실행되어 그 결과를 알려주기를 기다릴 것이기 때문이다.
    - 이런 현상을 스레드 부족 데드락이라고 한다. 
    - 예제 8.1 단일 스레드 Executor에서 데드락이 발생하는 작업 구조, 이런 코드는 금물
~~~java
public class ThradDeadlock {
    ExecutorService exec = Executors.newSingleThreadExecutor();
    
    public class RendererPageTask implements Callable<String> { 
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html")); // 머리글과 
            footer = exec.submit(new LoadFileTask("footer.html")); // 꼬리글을 가져오는 작업을 Executor에 등록
            String page = renderBody(); //페이지 본물을 화면에 그려냄 
            //데드락 발생
            return header.get() + page + footer.get(); //머리글과 꼬리글을 가져오기를 기다렸다가 본문까지 합쳐서 최종 페이지를 만들어낸다.
        }
    }
}
~~~
-
    - 완전히 독립적이지 않은 작업을 Executor에 등록할 때는 항상 스레드 부족 데드락이 발생할 수 있다는 사실을 염두해 둬야 하며, 작업을 구현한 코드나 Executor를 설정하는 설정 파일 등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야 한다.
- 8.1.2 오래 실행되는 작업
    - 데드락이 발생하지 않는다 하더라도, 특정 작업이 예상보다 긴 시간동안 종료되지 않고 실행된다면 스레드 풀의 응답 속도에 문제점이 생긴다.
    - 자바 플랫폼 라이브러리에서 제공하는 대부분의 블로킹 메소드는 시간이 제한되지 않은것과 시간이 제한된 것이 함께 만들어져 있다.
        - Thread.join, BlockingQueue.put, CountDownLatch.await, Selector.select 등
    - 대기하는 도중에 지정한 시간이 지나면 해당 작업이 제대로 실행되지 못했다고 기록해두고 일단 종료시킨 다음 큐의 맨 뒤에 다시 추가하는 등의 대책을 세울 수 있다.
    - 스레드 풀을 사용하는 도중에 모든 스레드에서 실행 중인 작업이 대기 상태에 빠지는 경우가 자주 발생한다면, 스레드 풀의 크기가 작다는 것으로 이해할 수 있다.
 
 ## 8.2 스레드 풀 크기 조절
 - 스레드 풀의 크기는 설정 파일이나 Runtime.availableProcessors 등의 메소드 결과 값에 따라 동적으로 지정되도록 해야 한다.
 - 스레드 풀의 크기를 결정하는데 특별한 공식은 없다. CPu나 ram등의 하드웨어 성능이 중요하다.
 - CPU를 많이 사용하는 작업의 경우 N개의 CPU를 탑재하고 있다면 N+1이 최적의 성능을 발휘한다고 한다. 
 - Ncpu = CPU의 개수(Runtime.getRuntime().availableProcessors();)
 - Ucpu = 목표로 하는 CPU활용도 Ucpu값은 0 ~ 1 사이
 - W/C : 작업시간 대비 대기 시간의 비율
 - N thread = Ncpu * Ucpu * (1 + W/C)
 - CPU가 아닌 자원을 대상으로 크기를 정할 경우  자원의 전체 개수 / 실제로 필요한 자원의 장
 ## 8.3 ThreadPoolExecutor 설정
 - ThreadPoolExecutor는 Executors 클래스에 들어있는 newCachedThreadPool, newFixedThreadPool, newScheduledThreadPool과 같은 팩토리 메소드에서 생성해주는 Executor에 대한 기본적인 내용이 구현된 클래스
 - ThreadPoolExecutor는 유연하면서도 안정적이고 여러가지 설정을 통해 바꿔 사용할 수 있도록 되어있다.
 - 스레드 풀의 기본 실행 정책이 요구 사항에 잘 맞지 않는다면 ThreadPoolExecutor 클래스의 생성 메소드를 직접 호출해 스레드 풀을 생성할 수 있으며 생성 메소드에 넘겨주는 값을 통해 스레드 풀의 설정을 마음대로 조절할 수 있다. 
 - 예제 8.2 ThreadPoolExecutor의 범용 생성 메소드
~~~java
import java.util.concurrent.*;public class Example8_2 {
    public ThreadPoolExecutor (int corePollSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler ) {
        // ...
    }
    
}
~~~
- 8.3.1 스레드 생성과 과거
    - 풀의 코어 크기나 최대 크기, 스레드 유지 시간 등의 값을 통해 스레드가 생성되고 제거되는 과정을 조절할 수 있다.
    - 코어 크기 = 스레드 풀 사용시 원하는 스레드의 개수
    - 풀의 최대 크기는 동시에 얼마나 많은 개수의 스레드가 동작할 수 있는지 제한하는 값(넘치면 스레드 제거)
    - newFixedThreadPool 팩토리 메소드는 결과로 생성할 스레드 풀의 코어 크기와 최대 크기를 newFixedThreadPool 메소드에 지정한 값으로 동일하게 지정하며, 시간 제한은 무제한으로 설정하는 것
    - newCachedThreadPool 팩토리 메소드는 스레드 풀의 최대 크기를 Integer.MAX_VALUE 값으로 지정하고 코어크기를 0으로 스레드 유지 시간을 1분으로 지정
    - 하지만 생성메소드를 직접 호출해 코어 크기, 최대 크기, 스레드 유지 시간을 원하는 대로 지정하면 다양한 조합 가능
- 8.3.2 큐에 쌓인 작업 관리 
    - 크기가 제한된 스레드 풀에서는 동시에 실행될 수 있는 스레드의 개수가 제한되어 있다. 
    - 제한 없이 스레드를 계속 생성하면 안정적이지 못하므로 요청이 들어올 때마다 스레드를 매번 생성하기보다는 고정된 크기의 스레드 풀을 만들어 사용하는 것이 좋다.
    - 그러나 고정된 크기의 스레드 풀도 완벽한 해법은 아니다.(부하가 많이 걸리는 작업의 경우 자원을 모두 잡아먹음)
    - 큐를 사용하면 대량의 작업이 갑자기 들어오는 경우에 유연하게 대응할 수 있지만 계속해서 처리하는 속도보다 빠른 속도로 작업이 추가되면 메모리가 가득 차는 상황을 방지해야 한다.
    - ThreadPoolExecutor를 생성할 때 작업을 쌓아둘 큐로 BlockingQueue를 지정할 수 있다.
    - 스레드 풀에서 작업을 쌓아둘 큐에 적용할 수 있는 전략 세가지
        - 1. 큐에 크기제 제한을 두지 않음
        - 2. 큐의 크기를 제한하는 방법
        - 3. 작업을 스레드에 직접 넘겨줌
    - newFixedThreadPool 메소드나 newSingleThreadExecutor 메소드에서 생성하는 풀은 기본 설정으로 크기게 제한되지 않은 LinkedBlockingQueue 사용
    - 자원 관리 측면에서 ArrayBlockingQueue나 크기가 제한된 LinkedBlockingQueue, PriorityBlockingQueue를 사용하는 것이 훨씬 안정적이다.
    - 작업 큐의 크기를 제한한 상태에서는 큐의 크기와 스레드의 개수를 동시에 튜닝해야 한다. 
    - 스레드의 개수는 줄이면서 큐의 크기를 늘려주면 메모리와 CPu 사용량을 줄이면서 컨텍스트 스위칭 횟수를 줄일 수 있지만, 전체적인 성능에는 제한이 생길 수 있다.
    - 스레드의 개수가 굉장히 많거나 제한이 없는 경우는 작업을 큐에 쌓는 절차를 생략할 수 있는데, 이럴때는 SynchronousQueue를 사용해 프로듀서에서 생성한 작업을 컨슈머인 스레드에게 직접 전달할 수 있다.
    - 대기중인 스레드가 없는 상태에서 스레드의 개수가 최대 크기보다 작다면 ThreadPoolExecutor는 새로운 스레드를 생성해 동작시킨다.
    - 만약 최대 크기에 다다르면 작업을 거부
- 8.3.3 집중 대응 정책                