# 10 활동성을 최대로 높이기
- 안정성과 활동성의 사이에는 밀고 당기는 힘이 존재하는 경우가 많다. 스레드의 안정성을 확보하기 위해서 락을 사용하다가 우연찮게 일정한 순서로 동작 시 락 순서에 따라 데드락이 발생하기도 한다.
- 스레드 풀이나 세마포어가 동작하는 구조를 정확하게 이해하지 못하고 있다면 더 이상 자원을 할당받지 못하는 또 다른 형태의 데드락이 발생할 수 있다.
- 데드락과 같이 활동성에 문제가 되는 상황에는 어떤것이 있는지 살펴보고 그런 상황 방지하는 방법을 살펴본다.

## 10.1 데드락
- 데드락 = [식사하는 철학자 문제](https://namu.wiki/w/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94%20%EC%B2%A0%ED%95%99%EC%9E%90%20%EB%AC%B8%EC%A0%9C)
- 모두 자기의 왼쪽에 있는 젓가락을 집을 시 음식을 더 이상 먹지 못하는 상황 발생 = 모두가 서로 상대방이 자원을 놓기만을 기다림 = 데드락
- 데이터베이스 시스템은 데드락을 검출한 다음 데드락 상황을 복구하는 기능을 갖추고 있다. 
- 데이터베이스의 트랜잭션을 활용하다 보면 여러개의 락이 필요 할 수 있으며 락은 해당 트랜잭션이 커밋될 때까지 풀리지 않는다. 두 개 이상의 트랜잭션이 데드락 상태에 빠지는 일도 충분이 가능
    - 이 경우 데이터베이스 서버에서 데드락이 걸린 트랜잭션 하나를 강제로 종료시킨다.
- JVM은 데드락 상태를 추적하는 기능을 갖고 있지 않다. 
    - 데드락이 걸릴 시 애플리케이션이 멈추거나, 일부 모듈이 동작을 멈추거나 전체적인 성능이 떨어지는 정도의 영향을 미칠 수 있다.
- 데드락은 상용 서비스를 시작하고 나서 시스템에 부하가 걸리는 경우와 같이 항상 최악의 상황에서 그 모습을 드러낸다

### 10.1.1 락 순서에 의한 데드락
- 예제 10.1 락 순서에 의한 데드락. 이런 코드는 금물!
~~~java
public class LeftRightDeadlock {
    private final Object left = new Object();
    private final Object right = new Object();
    
    public void leftRight() {
        synchronized (left) {
            synchronized (right) {
                doSomething();
            }
        }
    }
    
    public void rigthLeft() {
        synchronized (right) {
            synchronized (left) {
                doSomethingElse();
            }
        }
    }
}
~~~
- A -> left 락 확보 -> right 락을 확보하려고 대기 -> 계속해서 대기
- B ----> right 락 확보 -> left 락을 확보하려고 대기 -> 계속해서 대기 
- 위와 같이 서로 엮일 경우 데드락이 발생
- 프로그램 내부의 모든 스레드에서 필요한 락을 모두 같은 순서로만 사용한다면, 락 순서에 의한 데드락은 발생하지 않는다.
- 락을 공유하는 상황에서 데드락을 방지하려면 오른손이 하는 일을 왼손이 알고 있어야 한다.

### 10.1.2 동적인 락 순서에 의한 데드락
- 예제 10.2 동적인 락 순서에 의한 데드락. 이런 코드는 금물
~~~java
public class Example10_2 {
    public void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException {
        // 해당 메소드를  한스레드에서 X계좌에서 Y로 계좌 자금 이체
        // 다른쪽 스레드에서 Y계좌에서 X계좌로 이체시 동시에 실행된다면 데드락 발생

        synchronized (fromAccount) {
            synchronized (toAccount) { // 자금을 이체하기 전에 양쪽 락 확보
                if(fromAccount.getBalance().compareTo(amount) < 0) {
                    throw new InsufficientFundsException();
                } else  {
                    fromAccount.debit(amount);
                    toAccount.credit(amount);
                }
            }
        }
    }
}
~~~
- 중첩된 구조에서 락을 가져가려고 하는 상황으로 찾아야 한다. 락 확보 순서는 내부적으로 제어할 수 없기 때문에 데드락을 방지하려면 락을 특정 순서에 맞춰 확보하도록 해야 하고 락을 확보하는 순서를 프로그램 전반적으로 동일하게 적용해야 한다.
- 객체에 순서를 부여하는 방법은 System.identityHashCode를 사용
    - identityHashCode 메소드는 해당 객체의 Object.hashCode메소드를 호출했을 때의 값을 알려준다.
- 예제 10.3에는 System.identityHashCode 메소드를 사용해 락 순서를 조절하도록 변경한 transferMody 메소드가 나타나 있다. 데드락의 위험은 없어진 상태
- 두개의 객체가 같은 hashCode 값을 갖고 있는 경우에는 또 다른 방법을 사용해 락 확보 순서를 조절해야 하며, 그렇지 않은 경우에는 데드락 발생 가능성이 있다.
- 예제 10.3 데드락을 방지하기 위해 락을 순서대로 확보하는 모습
- 락 순서가 일정하지 않을 수 있다는 문제점을 제거하려면 타이 브레이킹 락을 사용. 
- 두개의 락을 임의의 순서로 확보하는 위험한 작업을 특정 순간에 하나의 스레드에서만 할 수 있도록 막는다. 
    - hashCode가 동일한 경우가 자주 발생한다면 병목 가능성이 높음. 
- 그러나 System.identityHashCode값이 충돌하는 경우는 거의 없으므로 타이 브레이킹 방법을 쓰지 않더라도 최소한의 비용으로 최대의 결과를 얻을 수 있다.
~~~java
public class Example10_3 {
    private static final Object tieLock = new Object();

    public void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException {
        class Helper {
            public void transfer() throws InsufficientFundsException {
                if(fromAccount.getBalance().compareTo(amount) < 0) {
                    throw new InsufficientFundsException();
                } else {
                    fromAccount.debit(amount);
                    toAccount.credit(amount);
                }
            }
        }
        
        int fromHash = System.identityHashCode(fromAccount);
        int toHash = System.identityHashCode(toAccount);
        
        if(fromHash < toHash) {
            synchronized (fromAccount) {
                synchronized (toAccount) {
                    new Helper().transfer();
                }
            }
        } else if(fromHash > toHash) {
            synchronized (toAccount) {
                synchronized (fromAccount) {
                    new Helper().transfer();
                }
            }
        } else  {
            synchronized (tieLock) {
                synchronized (fromAccount) {
                    synchronized (toAccount) {
                        new Helper().transfer();
                    }
                }
            }
        }
    }
}
~~~ 
- Account 클래스 내부에 계좌번호와 같이 유일하면서 불변이고 비교도 가능한 값을 키로 갖고 있따면 한결 쉬운 방법으로 락 순서를 지정할 수 있다.
- Account 객체를 그 내부의 키를 기준으로 정렬한 다음 정렬한 순서대로 락을 확보한다면 타이 브레이킹을 쓰지 않고 락이 걸리는 순서을 일정하게 유지할 수 있다.
- 심도있는 부하 테스트를 진행해도 발생 가능한 데드락을 모두 찾을 수 없다.
- 예제 10.4 의 DemonstratedDeadlcok 클래스는 대부분의 시스템에서 아주 금방 데드락 상태에 빠지는 예를 보여준다.
- 예제 10.4 일반적으로 데드락에 빠지는 반복문
~~~java
public class DemonstratedDeadlock {
    private static final int NUM_THREADS = 20;
    private static final int NUM_ACCOUNTS = 5;
    private static final int NUM_ITERATORS = 1000000;

    public static void main(String[] args) {
        final Random rnd = new Random();
        final Account[] accounts = new Account(NUM_ACCOUNTS);
        
        for(int i = 0; i < accounts.length; i++) {
            accounts[i] = new Account();
        }
        
        class TransferThread extends Thread {
            @Override
            public void run() {
                for(int i = 0; i < NUM_ITERATORS; i++) {
                    int fromAcct = rnd.nextInt(NUM_ACCOUNTS);
                    int toAcct = rnd.nextInt(NUM_ACCOUNTS);
                    DollarAmount amount = new DollarAmount(rnd.nextInt(1000));
                    transferMoney(accounts[fromAcct], accounts[toAcct], amount);
                }
            }
        }
    }
}
~~~
        
  