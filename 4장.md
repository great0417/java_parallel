#객체 구성
- 안정성, 동기화 문제 -> 안정성을 확보한 개별 컴포넌트를 안전한 방법으로 연결해 사용하면 쉽다.
- 개발자가 실수를 해도 스레드 안정성을 해치지 않도록 하는 클래스가 주된내용

##4.1 스레드 안전한 클래스 설계
- 프로그램의 모든 값을 public static 변수에 저장 -> 안전 여부 확인 힘듦, 변경 매우 어려움.(구조적인 캡슐화 필요)
- 캡슐화를 통해 정보은닉된 객체 -> 객체 단위로 안정 여부 확인 가능
    > 스레드 안정성 확보 설계 3가지
    >  1. 객체의 상태를 보관하는 변수가 어떤 것인가?
    >  2. 객체의 상태를 보관하는 변수가 가질수 있는 값이 어떤 종류, 어떤 범우에 해당하는가?
    >  3. 객체 내부의 값 동시 사용시 어떻게 관리할 것인가?
  
- 예제 4.1 자바 모니터를 활용해 스레드 안정성을 확보한 카운터 클래스  
~~~java
    @ThreadSafe
    public final class Counter {
        @GuardedBy("this") private long value = 0; //0으로 지정
        
        public synchronized long getValue() {
            if(value == Long.MAX_VALUE) { // Long.MAX_VALUE보다 큰 값 불가
                throw new IllegalStateException("counter overflow");
            }
            return ++value; //0에서 증가하므로 음수 불가, 증가연산자이므로 1 다음 상태가 변할경우 무조건 2
        }

        //public void setValue(long value) {this.value= value}
    }
~~~
- 객체의 상태는 객체 내부의 변수가 기반
- Counter 클래스는 value만 보면 이해 가능
- 만약 객체가 객체 변수를 가지고 있다면 그 객체 변수 내부 변수까지 전체 상태범위에 포함시켜야 한다. 
- 동기화 정책 : 여러 변수가 계속 변화는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법
    - 불변객체, 스레드 한정, 락등 사용 
    - 동기화 정책 문서로 작성.
- 4.1.1 동기화 요구사항 정리
    - 상태 범위 : 객체와 변수가 가질 수 있는 가능한 값의 범위. 좁을수록 객체의 논리적인 상태를 파악하기 쉽다.(ex: final 지정, 그리고 확실한건 불변객체)    
    - 대부분의 클래스에는 상태를 확인할 수 있는 마지노선이 있다 (Counter 소스 주석 참고)
    - 클래스를 대상으로 하는 연산이 모두 이전 상태를 기반으로 이뤄질 필요는 없음(ex. 온도?)
    - 클래스 내부에 상태나 상태변화와 관련해 제약조건에는 캡슐화 방법을 사용해야 할 수도 있다.(할 수도..?)
    - 변수를 숨겨두지 않으면 올바르지 않다고 정으한 값을 지정할 수 있다(counter.setValue(-1L);) 
    - 특정 연산 실행 시 올바르지 않은 상태값을 가질 가능성이 있다면 해당 연산은 단일 연산으로 구현해야 한다.
    - 제약조건이 없다면 동기화나 캡슐화 기법을 사용하지 않아도 된다.
    - [예제 4.10](#example_4_10) <div id="back">바로가기</div>
    - 항상 최저는 최고보다 작거나 같다는 조건 만족해야 한다.
    - 여러개의 변수를 통해 클래스의 상태가 올바른지 여부를 정의한다면 단일연산으로 구현해야 한다.
    - 서로 연관된 값은 단일연산으로 한번에 읽거나 변경해야 한다.
    - 락 확보 -> 값변경 -> 락 해제 -> 락 확보 -> 다른 값 변경 -> 락 헤재시 올바른 제약조건을 만족하지 못하게 됨.
    - ex) 현재 (lower = 1,upper = 100) -> A thread setLower(50) -> 동시에 B thread setUpper(30); -> lower = 50, upper = 30
    - 락을 사용해서 동기화를 맞춰야 한다. 
- 4.1.2 상태의존연산
    - 현재 조건에 따라 동작 여부가 결정되는 연산(ex. 큐, 스택)
    - 단일스레드로 동작하는 프로그램은 올바른 상태가 아닌 상황에서 실행시 오류, 그러나 여러 스레드가 동시에 움직이는 경우라면 선행조건이 올바른 상태로 바뀔 수 있다.
    - java의 wait과 notify 함수 [wait notify](https://blog.cornsworld.co.kr/189)
        - 특정 상태가 원하는 조건까지 효율적으로 기다리지만 올바르게 사용하기 쉽지 않다.
        - BlockingQueue나 Semaphore와 같은 라이브러리를 사용하는 편이 간단하고 안전
- 4.1.3 상태 소유권
    - 객체의 상태는 객체에 포함하는 모든 객체와 변수가 가질 수 있는 전체 상태의 부분집합.
    - 변수를 통해 상태를 정의할 때에는 해당 객체가 실제로 '소유하는' 데이터만 기준으로 삼아야 한다.
    - 클래스 설계 시 소유권을 잘 고려해야 한다.(ex. HashMap 클래스 인스턴스 생성시 고려해야 하는건 단순히 HashMap만이 아니다)
    - 자바는 객체 소유권의 문제를 대부분 조절할 수 있지만 객체 공유하는데 있어 오류가 발생하기 쉬운 부분은 가비지 컬렉터가 알아서 조절해주므로 소유권 개념이 다른 언어에 비해 훨씬 불명확하다
    (가비지 컬렉터가 하는 부분 찾기)
    - 소유권과 캡슐화 정책은 함께 고려함
    - 캡슐화를 통해 정보를 숨기므로 객체 상태에 소유권을 갖는다.
    - 컬렉션 클래스의 경우 소유권 분리의 형태를 사용하는 경우도 많다. (ex: sevletContext의 setAttribute, getAttribute) 
    - 그러므로 이런 객체를 사용할 때에는 반드시 스레드 안정성을 충분히 확보하거나, 불변 객체의 형태를 갖거나 아니면 지정된 락을 사용해 동기화 작업을 거쳐야 한다.

##4.2 인스턴스 한정
- 객체가 스레드 안정성을 확보하지 못하고 있더라도 몇가지 기법을 활용하면 멀티스레드 프로그램에서 안전하세 사용할 수 있다.(스레드 한정기법,  락 사용, 적절한 객체의 캡슐화)
- 인스턴스 한정기법이란 객체를 적절하게 캡슐화해서 스레드 안정성을 확보하는것
- 객체 외부에서도 사용할 수 있는 상황보다 스레드 안정성을 분석해 볼 수 있다(왜? 그 객체의 상태는 그 객체만 가지고 있으므로)
- > 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악 가능
- 객체는 특정 클래스 인스턴스에 한정시킬수도 있고 문법적으로 블록 내부에 한정킬수도 있고 특정 스레드에 한정시킬 수도 있다. (중요한 것은 제한범위 안에 두기)
- 예제 4.2 한정 기법으로 스테드 안정성 확보
~~~java
    @ThreadSafe
    public class PersonSet {
        @GuardedBy("this") private final Set<Persion> mySet = new HashSet<Person>(); // HashSet은 스레드 안전 객체가 아님. 그러나 private로 외부 직접 유출 X
    
        public synchronized void addPersion(Person p) { //HashSet에 접근방법 첫번째, 락으로 스레드 안전
            mySet.add(p); 
        }   
    
        public synchronized boolean containPersion(Person p) { //HashSet에 접근방법 두번째, 락으로 스레드 안전
            return mySet.contains(p);
        }   

        //다른 락을 거는 방법 상태변수를 락하므로서 정밀도를 높임
        public boolean addPersion(Person p) {
            synchronized (mySet) {
                mySet.add(p);
            }
        }

    }
~~~

- Person 객체가 변경될 수 있다면 PersonSet 객체에서 Person객체를 사용하고자 할 때에는 적절한 동기화 기법을 적용해야 한다.(가장 좋은 방법은 Person객체도 스레드 안정성 확보)
- 인스턴스 한정 기법은 클래스를 구현할 때 스레드 안정성을 확보할 수 있는 가장 쉬운 방법
- 인스턴스 한정 기법을 사용하면 여러가지 데이터를 여러 개의 락으로 사용해 따로 동기화 시킬 수도 있다.
- 자바 플랫폼의 클래스 라이브러리에는 이런 인스턴스 한정 기법을 많이 사용(ex Collection.synchronizedlist 같은 팩토리 메소드)
- 팩토리 메소드는 컬렉션의 기본 클레스에 스레드 안정성을 확보하는 방법 대부분 [데코레이터 패턴](https://www.baeldung.com/java-decorator-pattern) 을 활용
- 팩토리 메소드의 결과로 만들어진 래퍼 클래스(기존에 정의된 Integer, Long이 아님, 아마 [래퍼 메소드](https://docs.oracle.com/javase/tutorial/collections/implementations/wrapper.html)  )는 기본 클래스를 호출하는 연동 역할만 하면서 그와 동시에 모든 메소드가 동기화되어있다.  
- ![synchronizedList 내부](/image/syncronizeList.PNG)
- 즉 래퍼 클래스를 거쳐야만 원래 컬렉션 클래스의 내용을 사용할 수 있기 때문에 래퍼 클래스는 스레드 안정성 확보.  
- 스레드 안정성을 제대로 확보하려면 래퍼 클래스를 통하지 않고 원래 객체에 접근해 사용하는 일은 없어야 한다.
- > 인스턴스 한정 기법을 사용하면 전체 프로그램을 다 뒤져보지 않고도 스레드 안정성을 확보하고 있는지 분석이 쉬우므로 스레드에 안전한 객체를 좀 더 쉽게 구현 가능
- 4.2.1 자바 모니터 패턴
    - 인스턴스 한정기법 = 자바 모니터 패턴
    - Vector, Hashtable 등 라이브러리 클래스에서 널리 사용함.
    - 장점 : 간결함.
    - 예제 4.3 private이면서 final인 변수를 사용해 동기화
~~~java 
    public class PrivateLock {
        private final Object myLock = new Object(); 
        @GuardedBy("myLock") Widget widget;

        void someMethod() {
            synchronized(myLock) {
                // widget 변수의 값을 읽거나 변경
            }
        }

    }
~~~    
   - 암묵적인 락이나 외부에서 사용할 수 있도록 공개된 락을 사용하기 보다 락으로 활용하기 위한 private 객체를 준비해두면 외부에서는 락을 건드릴수 없으므로 다른 객체도 락을 활용해 동기화 작업에 함께 참여할 수 없다.
   - 외부 공개시 문제점 : 올바르지 않게 사용시 원래 객체의 작동이 멈출수도 있다. 
   
- 4.2.2 예제: <div id="back_4_2_2">차량 위치추적</div>
   - 예제 4.1(Counter 클래스) 는 너무 작은 예제
   - 택시, 경찰차, 택배 트럭과 같은 차량의 위치 추적 프로그램 작성.
~~~java
    import java.util.Collections;import java.util.HashMap;@ThreadSafe
    public class MonitorVehicleTracker {
        @GuardedBy("this") private final Map<String, Point> locations;
        
        public MonitorVehicleTracker(Map<String, Point> locations) {
            this.locations = deepCopy(locations);
        }   
    
        public static Map<String, Point> deepCopy(Map<String, Point> m) {
            Map<String, Point> result = new Map<String, Point>();
            for(String id : m.keySet()) {
                result.put(id, new Point(m.get(id)));
            }
            return Collections.unmodifiableMap(result);
        }
    
        public synchronized Map<String, Point> getLocations() {
            return deepCopy(locations);
        }

        public synchronized Point getLocation(String id) {
            Point loc = locations.get(id);
            return loc == null ? null : new Point(loc);
        }   
    
        public synchronized  void setLocation(String id, int x, int y) {
            Point loc = locations.get(id);
            if(loc == null) {
                throw new IllegalArgumentException("No such ID: " + id);
            }
            loc.x = x;
            loc.y = y;
        }   

    }

    
    @NotThreadSafe
    public class Point {
        public int x, y;
        
        public Point() {x = 0; y = 0;}

        public Point(Point p) {
            this.x = p.x;
            this.y = p.y;
        }
    }   
~~~   
    - Point 클래스가 NotThreadSafe이지만 unmodifiableMap 로 변경 불가, Point 외부 공개 x
    - 반환시 복사본을 주거나, deepCopy를 통해 완전히 새로운 인스턴스 복사본을 넘겨준다.
    - 해당 소스의 문제점
        - 1. Point 클래스 : 변수가 public으로 공개되어서 스레드 안전하지 않다 (상태 범위가 넓음, 캡슐화 x 등)
        - 2. 복사본을 넘겨주므로 스레드 안전성을 부분적으로 확보하지만 추적하는 차량의 대수가 많아지면 성능에 문제 발생(getLocations 메소드를 호출할때마다 복사하므로)
        - 2-1. 특정 시점의 전체 차량 위치에 대한 고정값을 원하면 정확한 값을 볼 수 있지만 시시각각으로 변하는 차량의 위치를 알고자 하면 상태알고싶은 시점마다 복사하므로 단점이 된다.

- 4.3 스레드 안전성 위임
    - 스레드 안전성이 없는 객체를 조합해 만들면서 스레드 안전성을 확보하고자 하면 자바 모니터 패턴이 유용하다.
    - 조합하고자 하는 클래스들이 스레드 안전성을 확보했어도 상황에 따라 스레드 안전성을 확보할수도, 스레드 안전성을 확보해야 할 수도 있다.
    - 54쪽 예제 2.4 (final의 중요성 : 동기화되어 안전한지 파악하기 쉬움. 경쟁조건 고려 x)
~~~java
    import java.util.concurrent.atomic.AtomicLong;public class CountingFactorizer implements Servlet {
        private final AtomicLong count = new AtomicLong(0); // 해당 객체 제외하고 상태 없음. 하나만 쓰므로 스레드 안전. 스레드 안전성 문제를 AtomicLong class에 위임
        ...
    }
~~~
    - 4.3.1 예제 : 위임 기법을 활용한 차량 추적
        - 예제 4.6 값을 변경할 수 없는 Point 객체, 예제 4.7 스레드 안전성을 ConcurrentHashMap 클래스에 위임한 추적 프로그램
~~~java
    import java.util.Collections;import java.util.concurrent.ConcurrentHashMap;@Immutable
    public class Point {
        public final int x, y;
        
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    @ThreadSafe
    public class DelegatingVehicleTracker {
        private final ConcurrentHashMap<String, Point> locations; //동기화 작업 담당
        private final Map<String, Point> unmodifiableMap; //불변 상태
    
        public DelegatingVehicleTracker(Map<String, Point> points) {
            locations = new ConcurrentHashMap<String, Point>();
            unmodifiableMap = Collections.unmodifiableMap(locations);
        }
    
        public Map<String, Point> getLocations() {
            return unmodifiableMap;
        }   
    
        public Point getLocation(String id) {
            return locations.get(id);
        }
    
        public void setLocation(String id, int x, int y) {
            if(locations.replace(id, new Point(x, y)) == null) {
                throw new IllegalArgumentException("invalid vehicle name : " + id);
            }
        }
    }   
~~~
    - 만약 4.2.2의 Point 객체를 사용했다면 스레드 안전성이 개질 수 있음.
    - 언제든지 가장 최신의 차량 위치를 실시간으로 알려줄 수 있다.
    - 최신 정보를 계속해서 봐야 하는 경우라면 장점이지만 고정된 정보를 보고자 하는 경우에는 단점이다. 
    - 예제 4.8 위치 정보에 대한 고정 스냅샷을 만들어 내는 메소드
~~~
    public Map<String, Point> getLocations() {
        return Collections.unmodifiableMap(new HashMap<String,Point>(locations));
    }
~~~
- 4.3.2 독립상태변수
    - 위임하고자 하는 내부 변수가 두 개 이상이라 해도 두 개 이상의 변수가 서로 '독립적'(변수가 서로 상태값에 대한 연관성이 없음) 이라면 클래스의 스레드 안전성을 위임할 수 있다.
    - 예제 4.9 두 개 이상의 변수에게 스레드 안전성을 위임
~~~java
    public class VisualComponent {
        private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<KeyListener>(); // CopyOnWriteArrayList는 스레드 안전한 List클래스
        private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>(); //두 상태 변수는 서로 아무런 연관이 없다. 두 변수에 책임 위임 가능
    
        public void addKeyListner(KeyListener keyListener) {
            keyListeners.add(keyListener);
        }
        
        public void addMouseListner(MouseListener mouseListener) {
            mouseListeners.add(mouseListener);
        }
    }
~~~
- 4.3.3 위임할 때의 문제점 
            
- <div id="example_4_10">예제 4.10</div>
~~~java
    import java.util.concurrent.atomic.AtomicInteger;public class NumberRange {
        //의존성 조건 : lower <= upper
        private final AtomicInteger lower = new AtomicInteger(0);
        private final AtomicInteger upper = new AtomicInteger(0);
        
        public void setLower(int i) {
            //주의 - 안전하지 않은 비교문
            if(i > upper.get()) {
                throw new IllegalArgumentException("can't set lower to "+ i + "> upper");
            }
            lower.set(i);
        }

        public void setUpper(int i) {
            //주의 - 안전하지 않은 비교문
            if(i < lower.get()) {
                throw new IllegalArgumentException("can't set upper to "+ i + "< lower");
            }
            upper.set(i);
        }
        
        public boolean isInRange(int i) {
            return (i >= lower.get() && i <= upper.get());
        }
    }
~~~
   - [4.1.1 동기화 요구사항 정리로 돌아가기](#back)
