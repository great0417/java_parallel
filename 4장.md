#객체 구성
- 안정성, 동기화 문제 -> 안정성을 확보한 개별 컴포넌트를 안전한 방법으로 연결해 사용하면 쉽다.
- 개발자가 실수를 해도 스레드 안정성을 해치지 않도록 하는 클래스가 주된내용

##4.1 스레드 안전한 클래스 설계
- 프로그램의 모든 값을 public static 변수에 저장 -> 안전 여부 확인 힘듦, 변경 매우 어려움.(구조적인 캡슐화 필요)
- 캡슐화를 통해 정보은닉된 객체 -> 객체 단위로 안정 여부 확인 가능
    > 스레드 안정성 확보 설계 3가지
    >  1. 객체의 상태를 보관하는 변수가 어떤 것인가?
    >  2. 객체의 상태를 보관하는 변수가 가질수 있는 값이 어떤 종류, 어떤 범우에 해당하는가?
    >  3. 객체 내부의 값 동시 사용시 어떻게 관리할 것인가?
-  예제 4.1 자바 모니터를 활용해 스레드 안정성을 확보한 카운터 클래스
~~~java
    @ThreadSafe
    public final class Counter {
        @GuardedBy("this") private long value = 0; //0으로 지정
        
        public synchronized long getValue() {
            if(value == Long.MAX_VALUE) { // Long.MAX_VALUE보다 큰 값 불가
                throw new IllegalStateException("counter overflow");
            }
            return ++value; //0에서 증가하므로 음수 불가, 증가연산자이므로 1 다음 상태가 변할경우 무조건 2
        }

        //public void setValue(long value) {this.value= value}
    }
~~~
- 객체의 상태는 객체 내부의 변수가 기반
- Counter 클래스는 value만 보면 이해 가능
- 만약 객체가 객체 변수를 가지고 있다면 그 객체 변수 내부 변수까지 전체 상태범위에 포함시켜야 한다. 
- 동기화 정책 : 여러 변수가 계속 변화는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법
    - 불변객체, 스레드 한정, 락등 사용 
    - 동기화 정책 문서로 작성.
- 4.1.1 동기화 요구사항 정리
    - 상태 범위 : 객체와 변수가 가질 수 있는 가능한 값의 범위. 좁을수록 객체의 논리적인 상태를 파악하기 쉽다.(ex: final 지정, 그리고 확실한건 불변객체)    
    - 대부분의 클래스에는 상태를 확인할 수 있는 마지노선이 있다 (Counter 소스 주석 참고)
    - 클래스를 대상으로 하는 연산이 모두 이전 상태를 기반으로 이뤄질 필요는 없음(ex. 온도?)
    - 클래스 내부에 상태나 상태변화와 관련해 제약조건에는 캡슐화 방법을 사용해야 할 수도 있다.(할 수도..?)
    - 변수를 숨겨두지 않으면 올바르지 않다고 정으한 값을 지정할 수 있다(counter.setValue(-1L);) 
    - 특정 연산 실행 시 올바르지 않은 상태값을 가질 가능성이 있다면 해당 연산은 단일 연산으로 구현해야 한다.
    - 제약조건이 없다면 동기화나 캡슐화 기법을 사용하지 않아도 된다.
    - [예제 4.10](#example_4_10) <div id="back">바로가기</div>
    - 항상 최저는 최고보다 작거나 같다는 조건 만족해야 한다.
    - 여러개의 변수를 통해 클래스의 상태가 올바른지 여부를 정의한다면 단일연산으로 구현해야 한다.
    - 서로 연관된 값은 단일연산으로 한번에 읽거나 변경해야 한다.
    - 락 확보 -> 값변경 -> 락 해제 -> 락 확보 -> 다른 값 변경 -> 락 헤재시 올바른 제약조건을 만족하지 못하게 됨.
    - ex) 현재 (lower = 1,upper = 100) -> A thread setLower(50) -> 동시에 B thread setUpper(30); -> lower = 50, upper = 30
    - 락을 사용해서 동기화를 맞춰야 한다. 
- 4.1.2 상태의존연산
    - 현재 조건에 따라 동작 여부가 결정되는 연산(ex. 큐, 스택)
    - 단일스레드로 동작하는 프로그램은 올바른 상태가 아닌 상황에서 실행시 오류, 그러나 여러 스레드가 동시에 움직이는 경우라면 선행조건이 올바른 상태로 바뀔 수 있다.
    - java의 wait과 notify 함수 [wait notify](https://blog.cornsworld.co.kr/189)
        - 특정 상태가 원하는 조건까지 효율적으로 기다리지만 올바르게 사용하기 쉽지 않다.
        - BlockingQueue나 Semaphore와 같은 라이브러리를 사용하는 편이 간단하고 안전
- 4.1.3 상태 소유권
    - 객체의 상태는 객체에 포함하는 모든 객체와 변수가 가질 수 있는 전체 상태의 부분집합.
    - 변수를 통해 상태를 정의할 때에는 해당 객체가 실제로 '소유하는' 데이터만 기준으로 삼아야 한다.
    - 클래스 설계 시 소유권을 잘 고려해야 한다.(ex. HashMap 클래스 인스턴스 생성시 고려해야 하는건 단순히 HashMap만이 아니다)
    - 자바는 객체 소유권의 문제를 대부분 조절할 수 있지만 객체 공유하는데 있어 오류가 발생하기 쉬운 부분은 가비지 컬렉터가 알아서 조절해주므로 소유권 개념이 다른 언어에 비해 훨씬 불명확하다
    (가비지 컬렉터가 하는 부분 찾기)
    - 소유권과 캡슐화 정책은 함께 고려함
    - 캡슐화를 통해 정보를 숨기므로 객체 상태에 소유권을 갖는다.
    - 컬렉션 클래스의 경우 소유권 분리의 형태를 사용하는 경우도 많다. (ex: sevletContext의 setAttribute, getAttribute) 그러므로 이런 객체를 사용할 때에는 반드시 스레드 안정성을 충분히 확보하거나, 불변 객체의 형태를 갖거나 아니면 지정된 락을 사용해 동기화 작업을 거쳐야 한다.
    
    
            
- <div id="example_4_10">예제 4.10</div>
~~~java
    import java.util.concurrent.atomic.AtomicInteger;public class NumberRange {
        //의존성 조건 : lower <= upper
        private final AtomicInteger lower = new AtomicInteger(0);
        private final AtomicInteger upper = new AtomicInteger(0);
        
        public void setLower(int i) {
            //주의 - 안전하지 않은 비교문
            if(i > upper.get()) {
                throw new IllegalArgumentException("can't set lower to "+ i + "> upper");
            }
            lower.set(i);
        }

        public void setUpper(int i) {
            //주의 - 안전하지 않은 비교문
            if(i < lower.get()) {
                throw new IllegalArgumentException("can't set upper to "+ i + "< lower");
            }
            upper.set(i);
        }
        
        public boolean isInRange(int i) {
            return (i >= lower.get() && i <= upper.get());
        }
    }
~~~
   - [4.1.1 동기화 요구사항 정리로 돌아가기](#back)
