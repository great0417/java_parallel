# 14 동기화 클래스 구현
- FutureTask, Semaphore, BlockingQueue 등과 같이 JDK 라이브러리에는 상태 의존적으로 움직이는, 즉 상태 기반 선행 조건을 갖고 있는 클래스가 여럿 있다.
    - ex : 비어있는 큐에서는 항목을 끄집어 낼 수 없으며, 아직 실행이 끝나지 않은 작업의 결과를 얻어갈 수 없다.
- 상태 의존적인 클래스를 새로 구현하는 가장 간단한 방법은 이미 만들어져 있는 상태 의존적인 클래스를 활용해 필요한 기능을 구현하는 것
- ValueLatch 클래스를 구현할 대 CountDownLatch를 사용해 동기화 기능을 구현했었다.
- 원하는 기능을 제공하는 클래스가 JDK 라이브러리에 포함돼 있지 않다면 자바 언어와 JDK 라이브러리에서 제공하는 저수준의 기능을 활용해 원하는 기능을 만들어 사용할 수도 있다.
- 저수준의 기능이라 함은 암묵적인 조건 큐, 명시적인 Condition 객체, AbstractQueueSynchronizer 프레임 워크 등을 말한다.
- 14장에서는 상태 종속정을 만들어 낼 수 있는 다양한 방법에 대해서 알아보고, 자바 플랫폼에서 제공하는 상태 종속성에 적용되는 여러 가지 규칙에 대해 살펴본다.

## 14.1 상태 종속성 관리
- 단일 스레드로 동작하는 프로그램에서는 메소드를 호출했을 때 상태 기반의 조건이 만족되지 않는다면, 해당 조건은 앞으로도 절대로 만족될 가능성이 없다.
- 따라서 순차적으로 실행되는 프로그램은 원하는 상태를 만족시키지 못하는 부분이 있다면 반드시 오류가 발생하게 된다.
- 하지만 병렬프로그램에서는 상태 기반의 조건은 다른 스레드를 통해서 언제든지 마음대로 변경될 수 있다. 바로 직전에 실행할 때는 비어있던 풀에 다른 스레드가 사용하고 남은 객체가 반호나돼 풀에 항목이 들어오기도 한다.
- 병렬 객체의 상태 종속적인 메소드는 선행 조건이 반족하지 않았을때 오류가 발생하는 문제에서 비켜날 수도 있겠지만, 비켜나는 일보다는 선행 조건을 만족할때까지 대기하는 경우가 많아진다
- 상태 종속적인 기능을 구현할 때 원하는 선행 조건이 만족할때까지 작업을 멈추고 대기하도록 하면 조건이 맞지 않았을 때 프로그램이 멈춰버리는 방법보다 훨씬 간단하고 오류도 적게 발생한다.
- 자바에 내장된 조건 큐 메커니즘은 실행중인 스레드가 특정 객체가 원하는 상태에 진입할 때까지 대기할 수 있도록 도와주며, 원하는 상태에 도달해서 스레드가 계속해서 실행할 수 있게 되면 대기 상태에 들어가 있던 스레드를 깨워주는 역할도 담당한다.
- 조건 큐에 대한 내용은 14.2절에서 상세하게 다루지만, 원하는 상태에 다다를때까지 폴링하고 잠깐 기다리고 다시 폴링하고 다시 잠깐 기다리는 (고통스러운) 반복문을 사용하는 대신 조건 큐를 사용하면 많은 이득을 얻을 수 있다.
- 상태 종속적인 블로킹 작업은 예제 14.1과 같은 모양을 하고 있다.
- 락을 활용하는 형태가 일반적이지 않은데, 작업하고자 확보했던 락을 그 내부에서 다시 풀어주고 또 다시 확보하는 우스꽝스러운 모습
- 선행조건에 해당하는 클래스 내부에 상태 변수는 값을 확인하는 동안에도 적절한 락으로 반드시 동기화해야 올바는 값을 확인할 수 있다. 
- 하지만 선행조건을 만족하지 않았다면 락을 다시 풀어줘야 다른 스레드에서 상태 변수를 변경할 수 있다. 
- 만약 락을 풀어주지 않고 계속 잡고 있다면 다른 스레드에서 상태 변수의 값을 변경할 수 없기 때문에 선행 조건을 영원히 만족시키지 못한다. 
- 물론 다음 번에 선행 조건을 확인하기 직전에는 락을 다시 확보해야만 한다.
~~~java
public class Example14_1 {
    void blockingAction() throws InterruptedException {
        //상태 변수에 대한 락 확보
        while (/* 선행 조건이 만족하지 않음 */) {
            // 확보했던 락을 풀어줌
            // 선행 조건이 맍고할만한 시간만큼 대기
            // 인터럽트에 걸리거나 타임아웃이 걸리면 멈춤
            // 락을 다시 확보
        }
        //작업 실행
        //락 헤제
    }
}
~~~
- 프로듀서-컨슈머 패턴으로 구현된 애플리케이션에서는 ArrayBlockingQueue와 같이 크기가 제한된 큐를 많이 사용한다.
- 크기가 제한된 큐는 put과 take 메소드를 제공하며 put과 take메소드에는 다음과 같은 선행 족너이 있다.
    - 버퍼 내무가 비어있다면 값을 take할 수 없고, 버퍼가 가득 차 있다면 값을 put할 수 없다.
- 상태 종속적인 메소드에서 선행 조건과 관련된 오류가 발생하면 에외를 발생시키거나 오류 값을 리턴하기도 하고, 아니면 선행 조건이 원하는 상태에 도달할때까지 대기하기도 한다.
- 선행 조건에 오류가 발생했을 때 오류를 처리하는 여러 가지 방법을 적용해 서로 다른 버전의 크기가 제한된 버퍼를 만들어 볼 예쩡이다.
- 여기에서 만들 클래스는 모두 예제 14.2의 BaseBoundedBuffer 클래스를 상속받는다. 
- 예제 14.2 의 BaseBoundedBuffer 클래스는 전통적인 배열 기반의 원형 버퍼로 구성돼 있으며 버퍼 내부의 상태 변수는 synchronized 키워드를 사용해 동기화하고 있다.
- BaseBoundedBuffer 는 하위 클래스에서 put, take 메소드를 구현할 때 사용할 수 있도록 doPut, doTake 메소드를 제공하고 내부적으로 갖고 있는 상태 변수는 외부에 공개하지 않는다.
- 예제 14.2 크기가 제한된 버퍼의 기반 클래스
~~~java
@ThreadSafe
public abstract class BaseBoundedBuffer<V> {
    @GuardedBy("this")
    private final V[] buf;
    @GuardedBy("this")
    private int tail;
    @GuardedBy("this")
    private int head;
    @GuardedBy("this")
    private int count;

    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[]) new Object[capacity];
    }

    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length) {
            tail = 0;
        }
        ++count;
    }

    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if(++head == buf.length) {
            head = 0;
        }
        --count;
        return v;
    }
    
    public synchronized final boolean isFull() {
        return count == buf.length;
    }
    
    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}
~~~

### 14.1.1 예제 : 선행 조건 오류를 호출자에게 그대로 전달
- 예제 14.3 의 GrumpyBoundedBuffer 는 원하는 버퍼를 구현하고자 하는 첫 단계이며 섬세하지 못하고 굉장히 거친 모습을 갖고 있다.
- 예제 14.3 선행 조건이 맞지 않으면 그냥 넘춰버리는 버퍼 클래스
~~~java
public class GrumpyBoundedBuffer<V> extends BaseBoundedBuffer {
    public GrumpyBoundedBuffer(int capacity) {
        super(capacity);
    }
    
    public synchronized void put(V v) throws BufferFullException {
        if(isFull()) {
            throw new BufferFullException();
        }
        doPut(v);
    }
    
    public synchronized V take() throws BufferEmptyException {
        if(isEmpty()) {
            throw new BufferEmptyException();
        }
        return (V) doTake();
    }
}
~~~
- put 메소드와 take 메소드는 확인하고 동작하는 구조로 구현됐기 때문에 synchronized 키워드를 적용해 버퍼 내부의 상태 변수에 동기화된 상태로 접근하게 돼 있다.
- 이렇게 구현하면 만들기는 간단하고 편리하지만 사용할때는 여간 짜증나는게 아니다. 예외는 예외적인 상황에서만 사용하는게 정상이다.
- 버퍼가 가즉 찼다는 건 크기가 제한된 버퍼에서는 당연히 발생할 수 있는 일이기 때문에 그다지 예외적인 상황이라고 볼 수 없다.
- 버퍼를 구현할 때 아주 간단하게 구현하긴 헀지만 그걸 사용할때는 그다지 간단하지 않다.
- 즉 GrumpyBoundedBuffer 를 사용하는 외부의 클래스는 put이나 take 메소드를 호출할때마다 발생할 가능성이 있는 예외 상황을 매번 처리해줘야 한다.
- GrumpyBoundedBuffer 클래스의 take 메소드를 호출하는 일반적인 구조가 예제 14.4에 깔끔하게 소개돼 있다. 프로그램 여기저기에서 put 메소드와 take메소드를 사용한다면 그다지 깔끔하지 않으렉 분명하다.
- 예제 14.4 GrumpyBoundedBuffer를 호출하기 위한 호출자 측의 코드
~~~
while (true) {
    try {
        V item = grumpyBoundedBuffer.take();
    } catch (BufferEmptyException e) {
        Thread.sleep(SLEEP_GRANUALRITY);
    }
}
~~~
- 이와 유사한 또 다른 방법으로는 우너하는 상태가 아닐 때 오류 값을 리턴하는 방법이 있다.
- 오류 값을 리턴하는 방법은 예외 상황이 아님에도 불구하고 다시 시도하라는 의미로 예외를 던지지는 않으니 약간 나은 방법이라고 볼 수도 있겠다.
- 하지만 선행 조건이 맞지 않다고 해서 호출자가 오류를 맡아서 처리해야 하는 원론적인 방법상의 문제를 해결하지는 못한다.
- 재시도하는 논리를 구현하는 방법에 있어서 예제 14.4의 호출자 측 코드 말고 다른 방법도 있다.
- 호출자가 잠자는 대기 시간 없이 take 메소드를 즉시 다시 호출하는 방법인데, 흔히 스핀 대기 또는 busy wating 방법이라고 한다. 
- 이 방법을 사용했는데 버퍼의 상태가 원하는 값으로 얼른 돌아오지 않는다면 상당한 양의 CPU 자원을 소모하게 된다. 
- 반대로 CPU자원을 덜 소모하도록 하고자 일정 시간 동안 대기하게 할 수 있는데, 이렇게 하면 버퍼가 워하는 값으로 돌아왔음에도 불구하고 계속해서 대기 상태에 빠져있는 '과다대기' 문제가 생기기도 한다.
- 따라서 호출자는 CPU를 덜 사용하되 응답성에서 손해를 보거나 응답성은 좋지만 CPU를 엄청나게 소모하는 두가지 방법 가운에 어느 것을 사용할지 선택해야 한다.

### 14.1.2 예제 : 폴링과 대기를 반복하는 세련되지 못한 대기 상태
- 예제 14.5의 SleepyBoundedBuffer 클래스는 '폴링하고 대기하는' 재시도 반복문을 put,take 메소드 내부에 내장시켜서 외부의 호출 클래스가 매번 직접 재시도 반복문을 만들어 사용해야 하는 불편함을 줄여주고자 하고 있다.
- 만약 버퍼가 비어있다면 take 메소드는 다른 스레드가 버퍼에 값을 집어 넣을 때까지 대기하고, 버퍼가 가득 차 있다면 put 메소드는 다른 스레드가 값을 꺼내 버퍼에 빈 공간이 생길 때까지 대기한다.
- 이 방법은 선행 조건 관리하는 부분을 버퍼 내부에 내장했기 때문에 외부에서 버퍼를 훨씬 간편하게 사용할 수 있다.
- 외부에서 간단하게 사용할 수 있다는건 버퍼를 구현하는 입장에서 고이장히 중요하고 그래야만 하는 요건이다
- SleepyBoundedBuffer 클래스의 구현 내용을 보면 이전에 구현했던 방법보다 약간 더 복잡한 모양을 갖추고 있다. 버퍼 내부를 보면 상태 조건을 나타내는 변수가 버퍼 락으로 동기화돼 있기 때문에 버퍼의 락을 확보한 상태에서 상태 조건이 적절한지 먼저 확인한다.
- 만약 상태 조건이 적절하지 않다면 실행 중이던 스레드가 잠시 대기 상태에 들어가고, 대기 상태에 들어가기 직전에 락을 풀어서 다른 스레드가 버퍼의 상태 변수를 사용할 수 있도록 한다.
- 대기 상태에 있던 스레드가 꺠어나면 락을 다시 확보한 다음 상태 조거능ㄹ 다시 확인한다.
- 잠시 대기하고 상태 조건을 확인하는 반복문을 계속해서 실행하다 조건이 적절해지면 반복문을 빠져나와 작업을 처리한다.
- 기능을 호출하는 호출자의 입장에서 보면 일단 그럴듯하게 동작한다. 만약 상태 조건이 이미 적절하게 갖춰져 있었다면 작업 역시 즉시 실행할 수 있고, 그렇지 않다면 대기 상태에 들어간다.
- 물론 호출자의 반복문 내부의 구조를 알아야 할 필요도 없고 오류가 발생하는지 보다가 재시도해야 할 필요도 없다.
- 잠자기 대기 상태에 들어가는 시간을 길게 값거나 짧게 잡으면 응답 속도와 CPU 사용량 간의 트레이드 오프가 발생한다.
- 대기 시간을 짧게 잡으면 CPu 사용량은 줄어들지만 응답 속도가 떨어진다.
- 그림 14.1을 보면 대기 시간에 따라 응답 속도가 어떻게 변하는지를 그래프로 보여주고 있다.
- 버퍼에 공간이 생긴 이후에 스레드가 대기 상태에서 빠져나와 상태 조건을 확인하기까지 약간의 시간차이가 발생하기도 한다는 점을 주의하자.
- 예제 14.5 세련되지 못한 대기 방법을 사용하는 SleepyBoundedBuffer
~~~java
public class SleepyBoundedBuffer<V> extends BaseBoundedBuffer {
    public SleepyBoundedBuffer(int size ) {super(size);}
    
    public void put(V v) throws InterruptedException {
        while (true) {
            synchronized (this) {
                if(!isFull()) {
                    doPut(v);
                    return;
                }
            }
            Thread.sleep(SLEEP_GRANUALITY);
        }
    }
    
    public V take() throws InterruptedException {
        while (true) {
            synchronized (this) {
                if(!isEmpty()) {
                    return (V) doTake();
                }
            }
            Thread.sleep(SLEEP_GRANUALITY);
        }
    }
}
~~~
- SleepyBoundedBuffer를 사용하는 호출자는 InterruptedException이 발생하는 경우를 처리해야 한다.
- 메소드 내부에서 원하는 조건을 만족할때까지 대기해야 한다면 작업이 취할 수 있는 기능을 제공하는 편이 좋다.
- 대부분의 깔끔하게 만들어진 JDK 라이브러리 메소드처럼 SleepyBoundedBuffer 역시 인터럽트를 걸면 즉시 리턴되면서 InterruptedExepction을 던지는 작업 취소 방법을 적용하고 있다.
- 이와 같이 폴링하고 대기하는 반복 작업을 통해 블로킹 연산을 구현하는 일은 상당이 고생스럽다.
- 이런 고생스러움을 해결하는게 조건 큐다

### 14.1.3 조건 큐 - 문제 해결사
- 조건 큐는 주방에 놓여 있는 토스트 기계에서 "토스트가 다 됐습니다."라고 울리는 벨과 같다.
- 벨소리만 신경쓰면 되고, 벨소리를 놓쳐도 나중에 상태 확인하고 만족하면 꺼내고 아니면 다시 벨소리에 귀를 기울이는 대기 상태에 들어갈 수 있다.
- 조건 큐는 여러 스레드를 한 덩어리로 묶어 특정 조건이 만족할때까지 한꺼번에 대기할 수 있는 방법을 제공하기 때문에 '조건큐' 라는 이름으로 불린다.
- 데이터 값으로 일반적인 객체를 담아두는 보토으이 큐와 달리 조건 큐에는 특정 조건이 만족할때까지 대기해야 하는 스레드가 값으로 들어간다.
- 자바 언어에서 사용하는 모든 객체를 락으로 활용할 수 있는 것처럼 모든 객체는 스스로를 조건 큐로 사용할 수 있으며 모든 객체가 갖고 있는 wait, notify, notifyAll 메소드는 조건 큐의 암묵적인 API라고 봐도 좋다.
- 자바 객체의 암묵적인 락과 암묵적인 조건 큐는 서로 관련돼 있는 부분이 있는데 이를테면 X라는 객체의 조건 큐 API를 호출하고자 하면 반드시 객체 X의 암묵적인 락을 확보하고 있어야만 한다.
- 상태 기반의 조건이 만족하기를 기다리도록 구현된 부분이 객체 내부의 상태를 일관적으로 유지하도록 구현된 코드와 필연적으로 굉장히 밀접하게 관련돼 있기 때문이다.
- 객체 내부의 상태를 확인하기 전에는 조건이 만족할대까지 대기할 수가 없고, 객체 내부의 상태를 변경하지 못하는 한 해당 객체의 조건 큐에서 대기하고 이는 객체를 풀어줄 수가 없으니 당연하다.
- Object.wait 메소드는 현재 확보하고 있는 락을 자동으로 해제하면서 운영체제에게 현재 스레드를 멈춰달라고 요청하고, 따라서 다른 스레드가 락을 확보해 객체 내부의 상태를 변경할 수 없도록 해준다.
- 대기 상태에서 깨어나는 순간에는 해제했던 락을 다시 확보한다.
- 풀어서 말하자면 Object.wait 메소든느 "나는 대기상태에 들어갈 예정인데, 만약 뭔가 재미있는 일이 생기면 깨워주기 바랍니다."라는 뜻이다.
- notify, notifyAll은 "뭔가 재미잇는 일이 발생했습니다"
- 예제 14.6의 BoundedBuffer 클래스는 wait와 notifyAll메소드를 사용해 크기가 제한된 버퍼를 구현하고 있다. 예전에 sleep메소드로 대기 상태에 들어가던 메소드보다 구현하기도 훨씬 간편하고 훨씬 효율적이며 응답성도 훨씬 좋다.
- 이런 구조는 굉장히 많이 발전한 모습이라고 할 수 있지만, 조건 큐를 사용했다고 해서 잠자기 대기 상태에 들어가던 버전과 비교해봤을 때 그 작동하는 모습에는 변화가 없다는 점을 알아두자.
- 전에 비해 몇가지 최적화 작업을 한 것 뿐
- 그러나 조건 큐를 사용하면 상태 종속성을 관리하거나 표헌하는데 있어서 훨씬 효율적이며 간편한 방법이긴 하다.
- 예제 14.6 조건 큐를 사용해 구현한 BoundedBuffer
~~~java
@ThreadSafe
public class BoundedBuffer2<V> extends BaseBoundedBuffer  {
    
    //조건 서술어 : not-full (!isFull())
    //조건 서술어 : not-empty(!isEmpty())
    
    public BoundedBuffer2(int size) {
        super(size);
    }
    
    //만족할때까지 대기 : not-full
    public synchronized void put(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        doPut(v);
        notifyAll();
    }
    
    //만족할대까지 대기 : not-empty
    public synchronized V take() throws InterruptedException {
        while (isEmpty()) {
            wait();
        }
        
        V v = (V) doTake();
        notifyAll();
        return v;
    }
}
~~~
 - BoundedBuffer2는 이제 쓸만하게 구현됐다.
 - 사용 편리, 상태 종속정도 깔끔하게 관리.
 
 ## 14.2 조건 큐 활용