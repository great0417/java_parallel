# 14 동기화 클래스 구현
- FutureTask, Semaphore, BlockingQueue 등과 같이 JDK 라이브러리에는 상태 의존적으로 움직이는, 즉 상태 기반 선행 조건을 갖고 있는 클래스가 여럿 있다.
    - ex : 비어있는 큐에서는 항목을 끄집어 낼 수 없으며, 아직 실행이 끝나지 않은 작업의 결과를 얻어갈 수 없다.
- 상태 의존적인 클래스를 새로 구현하는 가장 간단한 방법은 이미 만들어져 있는 상태 의존적인 클래스를 활용해 필요한 기능을 구현하는 것
- ValueLatch 클래스를 구현할 대 CountDownLatch를 사용해 동기화 기능을 구현했었다.
- 원하는 기능을 제공하는 클래스가 JDK 라이브러리에 포함돼 있지 않다면 자바 언어와 JDK 라이브러리에서 제공하는 저수준의 기능을 활용해 원하는 기능을 만들어 사용할 수도 있다.
- 저수준의 기능이라 함은 암묵적인 조건 큐, 명시적인 Condition 객체, AbstractQueueSynchronizer 프레임 워크 등을 말한다.
- 14장에서는 상태 종속정을 만들어 낼 수 있는 다양한 방법에 대해서 알아보고, 자바 플랫폼에서 제공하는 상태 종속성에 적용되는 여러 가지 규칙에 대해 살펴본다.

## 14.1 상태 종속성 관리
- 단일 스레드로 동작하는 프로그램에서는 메소드를 호출했을 때 상태 기반의 조건이 만족되지 않는다면, 해당 조건은 앞으로도 절대로 만족될 가능성이 없다.
- 따라서 순차적으로 실행되는 프로그램은 원하는 상태를 만족시키지 못하는 부분이 있다면 반드시 오류가 발생하게 된다.
- 하지만 병렬프로그램에서는 상태 기반의 조건은 다른 스레드를 통해서 언제든지 마음대로 변경될 수 있다. 바로 직전에 실행할 때는 비어있던 풀에 다른 스레드가 사용하고 남은 객체가 반호나돼 풀에 항목이 들어오기도 한다.
- 병렬 객체의 상태 종속적인 메소드는 선행 조건이 반족하지 않았을때 오류가 발생하는 문제에서 비켜날 수도 있겠지만, 비켜나는 일보다는 선행 조건을 만족할때까지 대기하는 경우가 많아진다
- 상태 종속적인 기능을 구현할 때 원하는 선행 조건이 만족할때까지 작업을 멈추고 대기하도록 하면 조건이 맞지 않았을 때 프로그램이 멈춰버리는 방법보다 훨씬 간단하고 오류도 적게 발생한다.
- 자바에 내장된 조건 큐 메커니즘은 실행중인 스레드가 특정 객체가 원하는 상태에 진입할 때까지 대기할 수 있도록 도와주며, 원하는 상태에 도달해서 스레드가 계속해서 실행할 수 있게 되면 대기 상태에 들어가 있던 스레드를 깨워주는 역할도 담당한다.
- 조건 큐에 대한 내용은 14.2절에서 상세하게 다루지만, 원하는 상태에 다다를때까지 폴링하고 잠깐 기다리고 다시 폴링하고 다시 잠깐 기다리는 (고통스러운) 반복문을 사용하는 대신 조건 큐를 사용하면 많은 이득을 얻을 수 있다.
- 상태 종속적인 블로킹 작업은 예제 14.1과 같은 모양을 하고 있다.
- 락을 활용하는 형태가 일반적이지 않은데, 작업하고자 확보했던 락을 그 내부에서 다시 풀어주고 또 다시 확보하는 우스꽝스러운 모습
- 선행조건에 해당하는 클래스 내부에 상태 변수는 값을 확인하는 동안에도 적절한 락으로 반드시 동기화해야 올바는 값을 확인할 수 있다. 
- 하지만 선행조건을 만족하지 않았다면 락을 다시 풀어줘야 다른 스레드에서 상태 변수를 변경할 수 있다. 
- 만약 락을 풀어주지 않고 계속 잡고 있다면 다른 스레드에서 상태 변수의 값을 변경할 수 없기 때문에 선행 조건을 영원히 만족시키지 못한다. 
- 물론 다음 번에 선행 조건을 확인하기 직전에는 락을 다시 확보해야만 한다.
~~~java
public class Example14_1 {
    void blockingAction() throws InterruptedException {
        //상태 변수에 대한 락 확보
        while (/* 선행 조건이 만족하지 않음 */) {
            // 확보했던 락을 풀어줌
            // 선행 조건이 맍고할만한 시간만큼 대기
            // 인터럽트에 걸리거나 타임아웃이 걸리면 멈춤
            // 락을 다시 확보
        }
        //작업 실행
        //락 헤제
    }
}
~~~
- 프로듀서-컨슈머 패턴으로 구현된 애플리케이션에서는 ArrayBlockingQueue와 같이 크기가 제한된 큐를 많이 사용한다.
- 크기가 제한된 큐는 put과 take 메소드를 제공하며 put과 take메소드에는 다음과 같은 선행 족너이 있다.
    - 버퍼 내무가 비어있다면 값을 take할 수 없고, 버퍼가 가득 차 있다면 값을 put할 수 없다.
- 상태 종속적인 메소드에서 선행 조건과 관련된 오류가 발생하면 에외를 발생시키거나 오류 값을 리턴하기도 하고, 아니면 선행 조건이 원하는 상태에 도달할때까지 대기하기도 한다.
- 선행 조건에 오류가 발생했을 때 오류를 처리하는 여러 가지 방법을 적용해 서로 다른 버전의 크기가 제한된 버퍼를 만들어 볼 예쩡이다.
- 여기에서 만들 클래스는 모두 예제 14.2의 BaseBoundedBuffer 클래스를 상속받는다. 
- 예제 14.2 의 BaseBoundedBuffer 클래스는 전통적인 배열 기반의 원형 버퍼로 구성돼 있으며 버퍼 내부의 상태 변수는 synchronized 키워드를 사용해 동기화하고 있다.
- BaseBoundedBuffer 는 하위 클래스에서 put, take 메소드를 구현할 때 사용할 수 있도록 doPut, doTake 메소드를 제공하고 내부적으로 갖고 있는 상태 변수는 외부에 공개하지 않는다.
- 예제 14.2 크기가 제한된 버퍼의 기반 클래스
~~~java
@ThreadSafe
public abstract class BaseBoundedBuffer<V> {
    @GuardedBy("this")
    private final V[] buf;
    @GuardedBy("this")
    private int tail;
    @GuardedBy("this")
    private int head;
    @GuardedBy("this")
    private int count;

    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[]) new Object[capacity];
    }

    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length) {
            tail = 0;
        }
        ++count;
    }

    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if(++head == buf.length) {
            head = 0;
        }
        --count;
        return v;
    }
    
    public synchronized final boolean isFull() {
        return count == buf.length;
    }
    
    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}
~~~

### 14.1.1 예제 : 선행 조건 오류를 호출자에게 그대로 전달
- 예제 14.3 의 GrumpyBoundedBuffer 는 원하는 버퍼를 구현하고자 하는 첫 단계이며 섬세하지 못하고 굉장히 거친 모습을 갖고 있다.
- 예제 14.3 선행 조건이 맞지 않으면 그냥 넘춰버리는 버퍼 클래스
~~~java
public class GrumpyBoundedBuffer<V> extends BaseBoundedBuffer {
    public GrumpyBoundedBuffer(int capacity) {
        super(capacity);
    }
    
    public synchronized void put(V v) throws BufferFullException {
        if(isFull()) {
            throw new BufferFullException();
        }
        doPut(v);
    }
    
    public synchronized V take() throws BufferEmptyException {
        if(isEmpty()) {
            throw new BufferEmptyException();
        }
        return (V) doTake();
    }
}
~~~
- put 메소드와 take 메소드는 확인하고 동작하는 구조로 구현됐기 때문에 synchronized 키워드를 적용해 버퍼 내부의 상태 변수에 동기화된 상태로 접근하게 돼 있다.
- 이렇게 구현하면 만들기는 간단하고 편리하지만 사용할때는 여간 짜증나는게 아니다. 예외는 예외적인 상황에서만 사용하는게 정상이다.
- 버퍼가 가즉 찼다는 건 크기가 제한된 버퍼에서는 당연히 발생할 수 있는 일이기 때문에 그다지 예외적인 상황이라고 볼 수 없다.
- 버퍼를 구현할 때 아주 간단하게 구현하긴 헀지만 그걸 사용할때는 그다지 간단하지 않다.
- 즉 GrumpyBoundedBuffer 를 사용하는 외부의 클래스는 put이나 take 메소드를 호출할때마다 발생할 가능성이 있는 예외 상황을 매번 처리해줘야 한다.
- GrumpyBoundedBuffer 클래스의 take 메소드를 호출하는 일반적인 구조가 예제 14.4에 깔끔하게 소개돼 있다. 프로그램 여기저기에서 put 메소드와 take메소드를 사용한다면 그다지 깔끔하지 않으렉 분명하다.
- 예제 14.4 GrumpyBoundedBuffer를 호출하기 위한 호출자 측의 코드
~~~
while (true) {
    try {
        V item = grumpyBoundedBuffer.take();
    } catch (BufferEmptyException e) {
        Thread.sleep(SLEEP_GRANUALRITY);
    }
}
~~~
- 이와 유사한 또 다른 방법으로는 우너하는 상태가 아닐 때 오류 값을 리턴하는 방법이 있다.
- 오류 값을 리턴하는 방법은 예외 상황이 아님에도 불구하고 다시 시도하라는 의미로 예외를 던지지는 않으니 약간 나은 방법이라고 볼 수도 있겠다.
- 하지만 선행 조건이 맞지 않다고 해서 호출자가 오류를 맡아서 처리해야 하는 원론적인 방법상의 문제를 해결하지는 못한다.
- 재시도하는 논리를 구현하는 방법에 있어서 예제 14.4의 호출자 측 코드 말고 다른 방법도 있다.
- 호출자가 잠자는 대기 시간 없이 take 메소드를 즉시 다시 호출하는 방법인데, 흔히 스핀 대기 또는 busy wating 방법이라고 한다. 
- 이 방법을 사용했는데 버퍼의 상태가 원하는 값으로 얼른 돌아오지 않는다면 상당한 양의 CPU 자원을 소모하게 된다. 
- 반대로 CPU자원을 덜 소모하도록 하고자 일정 시간 동안 대기하게 할 수 있는데, 이렇게 하면 버퍼가 워하는 값으로 돌아왔음에도 불구하고 계속해서 대기 상태에 빠져있는 '과다대기' 문제가 생기기도 한다.
- 따라서 호출자는 CPU를 덜 사용하되 응답성에서 손해를 보거나 응답성은 좋지만 CPU를 엄청나게 소모하는 두가지 방법 가운에 어느 것을 사용할지 선택해야 한다.

### 14.1.2 예제 : 폴링과 대기를 반복하는 세련되지 못한 대기 상태
- 예제 14.5의 SleepyBoundedBuffer 클래스는 '폴링하고 대기하는' 재시도 반복문을 put,take 메소드 내부에 내장시켜서 외부의 호출 클래스가 매번 직접 재시도 반복문을 만들어 사용해야 하는 불편함을 줄여주고자 하고 있다.
- 만약 버퍼가 비어있다면 take 메소드는 다른 스레드가 버퍼에 값을 집어 넣을 때까지 대기하고, 버퍼가 가득 차 있다면 put 메소드는 다른 스레드가 값을 꺼내 버퍼에 빈 공간이 생길 때까지 대기한다.
- 이 방법은 선행 조건 관리하는 부분을 버퍼 내부에 내장했기 때문에 외부에서 버퍼를 훨씬 간편하게 사용할 수 있다.
- 외부에서 간단하게 사용할 수 있다는건 버퍼를 구현하는 입장에서 고이장히 중요하고 그래야만 하는 요건이다
- SleepyBoundedBuffer 클래스의 구현 내용을 보면 이전에 구현했던 방법보다 약간 더 복잡한 모양을 갖추고 있다. 버퍼 내부를 보면 상태 조건을 나타내는 변수가 버퍼 락으로 동기화돼 있기 때문에 버퍼의 락을 확보한 상태에서 상태 조건이 적절한지 먼저 확인한다.
- 만약 상태 조건이 적절하지 않다면 실행 중이던 스레드가 잠시 대기 상태에 들어가고, 대기 상태에 들어가기 직전에 락을 풀어서 다른 스레드가 버퍼의 상태 변수를 사용할 수 있도록 한다.
- 대기 상태에 있던 스레드가 꺠어나면 락을 다시 확보한 다음 상태 조거능ㄹ 다시 확인한다.
- 잠시 대기하고 상태 조건을 확인하는 반복문을 계속해서 실행하다 조건이 적절해지면 반복문을 빠져나와 작업을 처리한다.
- 기능을 호출하는 호출자의 입장에서 보면 일단 그럴듯하게 동작한다. 만약 상태 조건이 이미 적절하게 갖춰져 있었다면 작업 역시 즉시 실행할 수 있고, 그렇지 않다면 대기 상태에 들어간다.
- 물론 호출자의 반복문 내부의 구조를 알아야 할 필요도 없고 오류가 발생하는지 보다가 재시도해야 할 필요도 없다.
- 잠자기 대기 상태에 들어가는 시간을 길게 값거나 짧게 잡으면 응답 속도와 CPU 사용량 간의 트레이드 오프가 발생한다.
- 대기 시간을 짧게 잡으면 CPu 사용량은 줄어들지만 응답 속도가 떨어진다.
- 그림 14.1을 보면 대기 시간에 따라 응답 속도가 어떻게 변하는지를 그래프로 보여주고 있다.
- 버퍼에 공간이 생긴 이후에 스레드가 대기 상태에서 빠져나와 상태 조건을 확인하기까지 약간의 시간차이가 발생하기도 한다는 점을 주의하자.
- 예제 14.5 세련되지 못한 대기 방법을 사용하는 SleepyBoundedBuffer
~~~java
public class SleepyBoundedBuffer<V> extends BaseBoundedBuffer {
    public SleepyBoundedBuffer(int size ) {super(size);}
    
    public void put(V v) throws InterruptedException {
        while (true) {
            synchronized (this) {
                if(!isFull()) {
                    doPut(v);
                    return;
                }
            }
            Thread.sleep(SLEEP_GRANUALITY);
        }
    }
    
    public V take() throws InterruptedException {
        while (true) {
            synchronized (this) {
                if(!isEmpty()) {
                    return (V) doTake();
                }
            }
            Thread.sleep(SLEEP_GRANUALITY);
        }
    }
}
~~~
- SleepyBoundedBuffer를 사용하는 호출자는 InterruptedException이 발생하는 경우를 처리해야 한다.
- 메소드 내부에서 원하는 조건을 만족할때까지 대기해야 한다면 작업이 취할 수 있는 기능을 제공하는 편이 좋다.
- 대부분의 깔끔하게 만들어진 JDK 라이브러리 메소드처럼 SleepyBoundedBuffer 역시 인터럽트를 걸면 즉시 리턴되면서 InterruptedExepction을 던지는 작업 취소 방법을 적용하고 있다.
- 이와 같이 폴링하고 대기하는 반복 작업을 통해 블로킹 연산을 구현하는 일은 상당이 고생스럽다.
- 이런 고생스러움을 해결하는게 조건 큐다

### 14.1.3 조건 큐 - 문제 해결사
- 조건 큐는 주방에 놓여 있는 토스트 기계에서 "토스트가 다 됐습니다."라고 울리는 벨과 같다.
- 벨소리만 신경쓰면 되고, 벨소리를 놓쳐도 나중에 상태 확인하고 만족하면 꺼내고 아니면 다시 벨소리에 귀를 기울이는 대기 상태에 들어갈 수 있다.
- 조건 큐는 여러 스레드를 한 덩어리로 묶어 특정 조건이 만족할때까지 한꺼번에 대기할 수 있는 방법을 제공하기 때문에 '조건큐' 라는 이름으로 불린다.
- 데이터 값으로 일반적인 객체를 담아두는 보토으이 큐와 달리 조건 큐에는 특정 조건이 만족할때까지 대기해야 하는 스레드가 값으로 들어간다.
- 자바 언어에서 사용하는 모든 객체를 락으로 활용할 수 있는 것처럼 모든 객체는 스스로를 조건 큐로 사용할 수 있으며 모든 객체가 갖고 있는 wait, notify, notifyAll 메소드는 조건 큐의 암묵적인 API라고 봐도 좋다.
- 자바 객체의 암묵적인 락과 암묵적인 조건 큐는 서로 관련돼 있는 부분이 있는데 이를테면 X라는 객체의 조건 큐 API를 호출하고자 하면 반드시 객체 X의 암묵적인 락을 확보하고 있어야만 한다.
- 상태 기반의 조건이 만족하기를 기다리도록 구현된 부분이 객체 내부의 상태를 일관적으로 유지하도록 구현된 코드와 필연적으로 굉장히 밀접하게 관련돼 있기 때문이다.
- 객체 내부의 상태를 확인하기 전에는 조건이 만족할대까지 대기할 수가 없고, 객체 내부의 상태를 변경하지 못하는 한 해당 객체의 조건 큐에서 대기하고 이는 객체를 풀어줄 수가 없으니 당연하다.
- Object.wait 메소드는 현재 확보하고 있는 락을 자동으로 해제하면서 운영체제에게 현재 스레드를 멈춰달라고 요청하고, 따라서 다른 스레드가 락을 확보해 객체 내부의 상태를 변경할 수 없도록 해준다.
- 대기 상태에서 깨어나는 순간에는 해제했던 락을 다시 확보한다.
- 풀어서 말하자면 Object.wait 메소든느 "나는 대기상태에 들어갈 예정인데, 만약 뭔가 재미있는 일이 생기면 깨워주기 바랍니다."라는 뜻이다.
- notify, notifyAll은 "뭔가 재미잇는 일이 발생했습니다"
- 예제 14.6의 BoundedBuffer 클래스는 wait와 notifyAll메소드를 사용해 크기가 제한된 버퍼를 구현하고 있다. 예전에 sleep메소드로 대기 상태에 들어가던 메소드보다 구현하기도 훨씬 간편하고 훨씬 효율적이며 응답성도 훨씬 좋다.
- 이런 구조는 굉장히 많이 발전한 모습이라고 할 수 있지만, 조건 큐를 사용했다고 해서 잠자기 대기 상태에 들어가던 버전과 비교해봤을 때 그 작동하는 모습에는 변화가 없다는 점을 알아두자.
- 전에 비해 몇가지 최적화 작업을 한 것 뿐
- 그러나 조건 큐를 사용하면 상태 종속성을 관리하거나 표헌하는데 있어서 훨씬 효율적이며 간편한 방법이긴 하다.
- 예제 14.6 조건 큐를 사용해 구현한 BoundedBuffer
~~~java
@ThreadSafe
public class BoundedBuffer2<V> extends BaseBoundedBuffer  {
    
    //조건 서술어 : not-full (!isFull())
    //조건 서술어 : not-empty(!isEmpty())
    
    public BoundedBuffer2(int size) {
        super(size);
    }
    
    //만족할때까지 대기 : not-full
    public synchronized void put(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        doPut(v);
        notifyAll();
    }
    
    //만족할대까지 대기 : not-empty
    public synchronized V take() throws InterruptedException {
        while (isEmpty()) {
            wait();
        }
        
        V v = (V) doTake();
        notifyAll();
        return v;
    }
}
~~~
 - BoundedBuffer2는 이제 쓸만하게 구현됐다.
 - 사용 편리, 상태 종속정도 깔끔하게 관리.
 
 ## 14.2 조건 큐 활용
 - 조건 큐를 사용하면 효율적이면서 응답속도도 빠른 상태 종속적인 클래스를 구현할 수 있지만, 올바르지 않은 방법으로 사용할 가능성도 높음
 - 컴파일러나 자바 플랫폼에서 정의하고 있지는 않지만, 조건 큐를 제대로 활용하려면 꼭 지켜야 하는 몇 가지 규칙이 있다.
 
 ### 14.2.1 조건 서술어
 - 조건 큐를 올바로 사용하기 위한 가장 핵심적인 요소는 바로 해당 객체가 대기하게 될 조건 서술어를 명확하게 구분해내는 일이다.
 - wait과 notify를 사용함에 있어서 가장 많은 혼란을 줄 수 있는 요소가 바로 조건 서술어인데, JDK 라이브러리 API에도 전혀 언급되지 않고, 조건 서술어를 올바르게 사용하는데 꼭 필요한 내용이 자바 언어 명세나 JVM 구현 매뉴얼 어디에도 소개돼 있지 않다.
 - 실제로 자바 언어 명세나 API 문서에 조건 서술어라는 단어가 명시 X
 - 하지만 조건 서술어가 없으면 조건부 대기 기능이 동작할 수 없다.
 - 조건 서술어는 애초에 특정 기능이 상태 종속적이 되도록 만드는 선행 조건을 의미한다.
    - ex: 크기가 제한된 버퍼에서 take 메소드는 버퍼에 값이 들어있는 경우에만 작업을 진행할 수 있고, 버퍼가 비어 있다면 대기해야 한다.
    - take 메소드의 입장에서는 작업을 진행하기 전에 확인하는 "버퍼에 값이 있어야 한다"가 조건 서술어이다.
    - put은 버퍼에 빈 공간이 있다가 조건 서술어
- 조건 서술어는 클래스 내부의 상태 변수에서 유추할 수 있는 표현식이다.
- BaseBoundedBuffer 클래스는 "버퍼에 값이 있어야 한다"는 조건 서술어에 count 변수에 0보다 큰지 비교하고, "버퍼에 빈 공간이 있어야 한다"는 조건 서술어에 대해서는 count 변수의 값이 작은지를 확인
- 조건 큐와 연결된 조건 서술어를 할상 문서로 남겨야 하며, 그 조건 서술어에 영향을 받는 메소드가 어느 것인지도 명시해야 한다.
- 조건부 대기와 관련된 락와 wait 메소드와 조건 서술어는 중요한 삼각관계를 유지
- 조건 서술어는 상태 변수를 기반으로 하고, 상태 변수는 락으로 동기화돼 있으니 조건 서술어를 만족하려면 반드시 락을 확보해야만 한다.
- 또한 락 객체와 조건 큐 객체는 반드시 동일한 객체여야만 한다.
- BoundedBuffer 클래스는 버퍼 락으로 버퍼의 상태를 동기화하고 있으며 버퍼 객체 자체를 조건 큐로 사용하고 있다.
- take 메소드를 보면 먼저 버퍼 락을 확보한 다음 조건 서술어를 확인한다.
- 조건 서술어를 확인해봤을 때 만족하지 않았따면 take 메소드는 다른 스레드에서 put메소드를 통해 버퍼에 값을 추가할 때까지 대기한다.
- take 메소드는 이렇게 대기하는 방법으로 해당 버퍼의 객체의 wait 메소드를 호출해 암묵적인 조건 큐를 활용하며, 이 작업을 하는 고자ㅓㅇ에도 역시 조건 큐 객체에 대한 락을 확보한 상태여야 한다. 
- take 메소드는 이미 조건 서술어를 확인하는 시점에 필요한 락을 확보한 상태이다.
- wait 메소드는 먼저 락을 해제하고 현재 스레드를 대기 상태에 두고, 일정 시간 이후에 타임아웃이 발생하거나 스레드에 인터럽트가 걸리거나 notify 또는 notifyAll 을 통해 알림을 받을 때까지 대기한다.
- 대기 상태에 있던 스레드가 깨어나면 wait 메소드는 리턴되기 전에 락을 다시 확보한다.
- wait 메소드에서 깨어나는 스레드라고 해도 락을 다시 확보함에 있어서는 별다른 우선 순위를 갖지 않으며, 일반적인 다른 스레드와 같이 락을 확보하는 경쟁에 참여해 공정하거나 불공정한 방법을 거쳐 락을 확보한다.
- wait 메소드를 호출하는 모든 경우에는 항상 조건 서술어가 연결돼 있다. 특정 조건 서술어를 놓고 wait 메소드를 호출할 때, 호출자는 항상 해당하는 조건 큐에 대한 락을 이미 확보한 상태여야 한다. 또한 확보한 락은 조건 서술어를 호가인하는데 필요한 모든 상태 변수를 동기화하고 있어야 한다.

### 14.2.2 너무 일찍 깨어나기
- wait 메소드를 호출하고 리턴됐다고 해서 반드시 해당 스레드가 대기하고 있던 조건 서술어를 만족한다는 것은 아니다
- 하나의 암묵적인 조건 큐를 두 개 이상의 조건 서술어를 대상으로 사용할 수도 있다.
- 어디에선가 notifyAll을 호출해서 대기 상태에 있던 스레드가 깨어났다면, wait 메소드가 리턴됐다고 해서 wait 하기 직전에 확인했던 조건 서술어를 만족하게 됏따는 것으로 이해해서는 안된다.
- 게다가 wait 메소드는 누군가가 notify해주지 않아도 리턴되는 경우도 있다.
- wait 메소드를 호출했던 스레드가 대기 상태에서 깨어나 다시 실행된다고 보면, 조건 큐와 연결돼 있는 락을 다시 확보한 상태이다. 그렇다면 조건 서술어는 만족됐는가? 그럴수도 아닐 수도 있다.
- 스레드가 깨어난 이후 락을 다시 확보하기 직전까지 다른 스레드가 락을 미리 확보하고는 조건 서술어와 관련된 상태 변수의 값을 변경시킬 수도 있다.
- 아니면 아예 wait 메소드를 처음 호출한 이후에 한 번도 조건 서술어를 만족했던 적이 없었을 수도 있다.
- 다른 스레드가 notify 또는 notifyAll 메소드를 왜 호출했는지 알 방법이 없다.
- 동일한 조건 큐를 대상으로 하는 다른 조건 서술어가 만족돼 호출한것일 수도 있다.
- 하나의 조건 큐에 여러 개의 조건 서술어를 연결해 사용하는 일은 굉장히 흔한 방법이다.
- BoundedBuffer 역시 하나의 조건 큐를 놓고 "버퍼에 값이 있어야 한다"와 "버퍼에 빈 공간이 있다"는 두 개의 조건 서술어를 한꺼번에 연결해 사용하고 있다.
- 이런 모든 원인 때문에 wait 메소드가 깨어나 리턴되고 나면 조건 서술어를 한번 더 확인해야만 하며, 만약 이번에도 조건 서술어를 만족하지 않으면 다시 wait 메소드를 호출해 대기 상태에 들어가야 한다.
- 여러번 그럴 수 있으므로 wait 메소드를 반복문 안에 넣어야 하고 그때마다 조건 서술어를 확인해야 한다.
- 조건부 wait 메소들르 사용하는 표준적인 방법이 예제 14.7에 소개돼 있다.
- 예제 14.7 상태 종속적인 메소드의 표준적인 형태
~~~
void stateDependentMethod() throws InterruptedException {
    //조건 서술어는 반드시 락으로 동기화된 이후에 확인해야 한다.
    synchronized(lock) {
        while(!conditionPredicate()) {
            lock.wait();
        }
        // 객체가 원하는 상태에 맞춰졌다.
    }
}
~~~  
- 조건부 wait 메소드를 사용할 때
    - 1. 항상 조건 서술어를 명시해야 한다.
    - 2. wait 메소드를 호출하기 전에 조건 서술어를 확인하고, wait 에서 리턴된 이후에도 조건 서술어를 확인해야 한다.
    - 3. wait 메소드는 항상 반복문 내부에서 호출해야 한다.
    - 4. 조건 서술어를 확인하는데 관련된 모든 상태 변수는 해당 조건 큐의 락에 의해 동기화돼 있어야 한다.
    - 5. wait, notify, notifyAll 메소드를 호출할 땐느 조건 큐에 해당하는 락을 확보하고 있어야 한다.
    - 6. 조건 서술어를 확인한 이후 실제로 작업을 실행해 작업이 끝날 때까지 락을 해제해서는 안된다.
    
### 14.2.3 놓친 신호
- 데드락이나 라이브 락과 같은 또다른 활동성 문제는 놓친 신호
- 특정 스레드가 이미 참을 만족하는 조건을 놓고 조건 서술어를 제대로 확인하지 못해 대기 상태에 들어가는 상황을 놓친 신호라고 한다.
- 즉 놓친 신호 문제가 발생한 스레드는 이미 지나간 일에 대한 알림을 받으려 대기하게 된다. 
- 긴 시간을 대기하거나 영영 대기 상태에 빠질 수도 있다. 
- 원인은 스레드에 대한 알림이 일시적이라는데에 있다.
- 스레드 A가 조건 큐에 신호를 보내주고 신호가 지나간 이후에 스레드 B가 동일한 조건 큐에서 대기한다면 스레드 B는 대기 상태에서 깨어나지 못한다. 스레드 B가 대기 상태에서 빠져나오려면 신호가 한번 더 지나가야 한다.
- 놓친 신호는 프로그램을 작성할 때 앞에서 소개한 여러 가지 주의 사항을 지키지 않아서 발생한다.
    - ex : wait 메소드를 호출하기 전에 조건 서술어를 확인하지 못하는 경우 놓친 신호 문제가 발생할 가능성도 있다.
- wait 메소드를 호출하기 전에 조건을 확인하는 부분은 예제 14.7과 같은 형태로 작성하면 놓친 신호 문제에 대해서 걱정하지 않아도 된다.

### 14.2.4 알림
- 조건부 대기 관련 기능에서 대기가 아닌 다른 한쪽은 '알림'이다.
- 크기가 제한된 버퍼 클래스에 값이 전혀 들어 있지 않은 상태에서 take 메소드를 호출하면 대기 상태에 들어간다.
- take 메소드가 대기 상태에 들어간 이후 버퍼 클래스에 값이 들어왔을 때 대기 상태에서 다시 빠져나오게 하려면 버퍼 클래스에 값이 추가되는 모든 실행 경로의 코드에서 알림 조치를 취해야 한다.
- BoundedBuffer 클래스에는 값이 추가되는 코드가 딱 한군데 있는데, 바로 put 메소드이다. put 메소드의 코드를 보면 값을 성공적으로 추가한 이후에 notifyAll 메소드를 호출하게 돼 있다.
- 이와 비슷하게 take 메소드 역시 버퍼에서 값을 뽑아낸 직후에 notifyAll메소드를 호출하도록 돼 있느넫, 이는 take 에서 값을 제거해 공간이 남기 때문에 공간이 모자라 값을 추가하지 못하고 대기 상태에 들어가 있던 스레드에게 추가 작업을 다시 시도해보라는 의미이다.
- 특정 조건을 놓고 wait 메소드를 호출해 대기 상태에 들어간다면, 해당 조건을 만족하게 된 이후에 반드시 알림 메소드를 사용해 대기 상태에서 빠져나오도록 해야 한다.
- 조건 큐 API 에서 알림 기능을 제공하는 메소드에는 두 가지가 있다.
    - 1. notify
    - 2. notifyAll
- 어느 메소드를 호출하더라도 조건 큐 객체에 댛나 락을 확보한 상태에서만 호출할 수 있다.
- notify 메소드를 호출하면 JVM은 해당하는 조건 큐에서 대기 상태에 들어가 있는 다른 스레드 하나를 골라 대기 상태를 풀어준다.
- notifyAll 을 호출하면 해당하는 조건 큐에서 대기 상태에 들어가있는 모든 스레드를 풀어준다.
- notify나 notifyAll 을 호출할때는 반드시 해당하는 조건 큐 객체에 대한 락을 확보해야 하고 wait 메소드를 호출했던 스레드 역시 조건 큐에 대한 락을 확보하지 못하면 대기 상태에서 깨어날 수 없기 때문에 notify나 notifyAll을 호출한 이후에는 최대한 빨리 락을 풀어줘야 대기 상태에서 깨어난 스레드가 얼른 동작할 수 있다.
- 여러 개의 스레드가 하나의 조건 큐를 놓고 대기 상태에 들어갈 수 있는데, 대기 상태에 들어간 조건이 서로 다를 수 있기 때문에 notifyAll 대신 notify메소드를 사용해 대기 상태를 풀어주는 방법은 위험성이 높다.
- 단 한번만 알림 메시지를 전달하게 되면 앞서 소개했떤 '놓친 신호' 와 유사한 문제가 생길 가능성이 높다.
- BoundedBuffer 클래스를 보면 특별한 경우가 아닌 이상 notifyAll 메소드를 사용하는 편이 안전한 이유를 수비게 알 수 있다.
- A라는 스레드가 PA라는 조건을 놓고 조건 큐에서 대기중이고 스레드 B는 PB조건을 놓고 동일한 조건 큐에서 대기 중이라고 가정해보자.
- 그런데 조건 PB가 먼저 만족하게 되고 스레드 C가 notify메소드를 호출하면 JVM은 조건 큐에서 대기중인 스레드 하나를 골라 깨우는데, 만약 스레드 A를 꺠운다면 조건 PA를 확인하고 조건을 만족하지 않는다는 사실을 확인하고 다시 대기 상태에 들어가게 된다.
- 그러는 동안 실제로 작업을 진행할 수 있는 상태가 된 스레드 B는 깨지도 못한 상태에서 계쏙 대기해야 한다. 
- 이런 뺴앗긴 신호 결과 이미 발생해서 날아가버린 신호를 대기하느라 대기 상태에서 깨어나지 못한다는 문제는 동일하다.
- notifyAll 대신 notify 메소드를 사용하려면 다음과 같은 족너에 해당하는 경우만 사용하는 것이 좋다.
    - 단일 조건에 따른 대기 상태에서 깨우는 경우 : 해당하는 조건 큐에 단 하나의 조건만 사용하고 있는 경우이고, 따라서 각 스레드는 wait 메소드에서 리턴될 때 동일한 방법으로 실행된다.
    - 한번에 하나씩 처리하는 경우 : 조건 변수에 대한 알림 메소드를호추라면 하나의 스레드만 실행시킬 수 있는 경우
- BoundedBuffer 클래스는 한 번에 하나씩 처리하는 조건은 만족하지만 "공간이 없다", "비어있다"는 두가지 조건을 사용하기 때문에 단일 조건에 따라 대기 상태에 들어가는 경우라는 조건에 해당하지 않는다.
- 대부분의 클래스는 위의 두 가지 조건을 모두 만족하지 모산다.
- 일반적으로 notifyAll을 사용한다. 
- 그러나 notifyAll은 비효율적이라고 볼 수 있다. 컨텍스트 스위칭 빈번, 상당량의 락 확보 경쟁이 벌어진다.(계속 다 풀고 다 경쟁하기 때문) 안전성은 높이지만 성능을 낮추게 된다.
- BoudnedBuffer 클래스의 put과 take 메소드에서 실행되는 알림 기능은 보수적인 편이다. 즉 버퍼에 객체가 들어가거나 객체를 뽑아낼 대마다 무조건 알림 메소드를 호출한다.
- 버퍼가 비어있다가 값이 들어오거나 가득 찬 상태에서 값을 뽑아내는 경우에만 대기 상태에서 빠져나올 수 있다는 점을 활용해 take,put 메소드가 대기 상태에서 빠져나올 수 있는 상태를 만들어주는 경우에만 알림 메소드를 호출하도록 하면 이런 보수적인 측면을 최적화 할수 있다.
- 이런 최적화 방법을 조건부 알림이라고 한다.(성능을 향상시킬 수 있지만 복잡하다.)
- 예제 14.8에서 조건부 알림 방법을 적용한 모습을 볼 수 있다.
- 단일 알림 방법이나 조건부 알림 방법은 최적화된 방법이다. 최적화 방법을 적절치 못하게 적용하면 이상하게 발생하는 프로그램 오류를 만나게 될 수 있다.
- 예제 14.8 BoundedBuffer.put 메소드에 조건부 알림 방법을 적용한 모습
~~~
public synchronized void put(V v) throws InterruptedException {
    while(isFull()) {
        wait;
    }
    boolean wasEmpty = isEmpty();
    odPut(v);
    if(wasEmpty) {
        notifyAll();
    }
}
~~~

### 예제 14.2.5 예제 : 게이트 클래스
