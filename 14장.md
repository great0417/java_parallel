# 14 동기화 클래스 구현
- FutureTask, Semaphore, BlockingQueue 등과 같이 JDK 라이브러리에는 상태 의존적으로 움직이는, 즉 상태 기반 선행 조건을 갖고 있는 클래스가 여럿 있다.
    - ex : 비어있는 큐에서는 항목을 끄집어 낼 수 없으며, 아직 실행이 끝나지 않은 작업의 결과를 얻어갈 수 없다.
- 상태 의존적인 클래스를 새로 구현하는 가장 간단한 방법은 이미 만들어져 있는 상태 의존적인 클래스를 활용해 필요한 기능을 구현하는 것
- ValueLatch 클래스를 구현할 대 CountDownLatch를 사용해 동기화 기능을 구현했었다.
- 원하는 기능을 제공하는 클래스가 JDK 라이브러리에 포함돼 있지 않다면 자바 언어와 JDK 라이브러리에서 제공하는 저수준의 기능을 활용해 원하는 기능을 만들어 사용할 수도 있다.
- 저수준의 기능이라 함은 암묵적인 조건 큐, 명시적인 Condition 객체, AbstractQueueSynchronizer 프레임 워크 등을 말한다.
- 14장에서는 상태 종속정을 만들어 낼 수 있는 다양한 방법에 대해서 알아보고, 자바 플랫폼에서 제공하는 상태 종속성에 적용되는 여러 가지 규칙에 대해 살펴본다.

## 14.1 상태 종속성 관리
- 단일 스레드로 동작하는 프로그램에서는 메소드를 호출했을 때 상태 기반의 조건이 만족되지 않는다면, 해당 조건은 앞으로도 절대로 만족될 가능성이 없다.
- 따라서 순차적으로 실행되는 프로그램은 원하는 상태를 만족시키지 못하는 부분이 있다면 반드시 오류가 발생하게 된다.
- 하지만 병렬프로그램에서는 상태 기반의 조건은 다른 스레드를 통해서 언제든지 마음대로 변경될 수 있다. 바로 직전에 실행할 때는 비어있던 풀에 다른 스레드가 사용하고 남은 객체가 반호나돼 풀에 항목이 들어오기도 한다.
- 병렬 객체의 상태 종속적인 메소드는 선행 조건이 반족하지 않았을때 오류가 발생하는 문제에서 비켜날 수도 있겠지만, 비켜나는 일보다는 선행 조건을 만족할때까지 대기하는 경우가 많아진다
- 상태 종속적인 기능을 구현할 때 원하는 선행 조건이 만족할때까지 작업을 멈추고 대기하도록 하면 조건이 맞지 않았을 때 프로그램이 멈춰버리는 방법보다 훨씬 간단하고 오류도 적게 발생한다.
- 자바에 내장된 조건 큐 메커니즘은 실행중인 스레드가 특정 객체가 원하는 상태에 진입할 때까지 대기할 수 있도록 도와주며, 원하는 상태에 도달해서 스레드가 계속해서 실행할 수 있게 되면 대기 상태에 들어가 있던 스레드를 깨워주는 역할도 담당한다.
- 조건 큐에 대한 내용은 14.2절에서 상세하게 다루지만, 원하는 상태에 다다를때까지 폴링하고 잠깐 기다리고 다시 폴링하고 다시 잠깐 기다리는 (고통스러운) 반복문을 사용하는 대신 조건 큐를 사용하면 많은 이득을 얻을 수 있다.
- 상태 종속적인 블로킹 작업은 예제 14.1과 같은 모양을 하고 있다.
- 락을 활용하는 형태가 일반적이지 않은데, 작업하고자 확보했던 락을 그 내부에서 다시 풀어주고 또 다시 확보하는 우스꽝스러운 모습
- 선행조건에 해당하는 클래스 내부에 상태 변수는 값을 확인하는 동안에도 적절한 락으로 반드시 동기화해야 올바는 값을 확인할 수 있다. 
- 하지만 선행조건을 만족하지 않았다면 락을 다시 풀어줘야 다른 스레드에서 상태 변수를 변경할 수 있다. 
- 만약 락을 풀어주지 않고 계속 잡고 있다면 다른 스레드에서 상태 변수의 값을 변경할 수 없기 때문에 선행 조건을 영원히 만족시키지 못한다. 
- 물론 다음 번에 선행 조건을 확인하기 직전에는 락을 다시 확보해야만 한다.
~~~java
public class Example14_1 {
    void blockingAction() throws InterruptedException {
        //상태 변수에 대한 락 확보
        while (/* 선행 조건이 만족하지 않음 */) {
            // 확보했던 락을 풀어줌
            // 선행 조건이 맍고할만한 시간만큼 대기
            // 인터럽트에 걸리거나 타임아웃이 걸리면 멈춤
            // 락을 다시 확보
        }
        //작업 실행
        //락 헤제
    }
}
~~~
- 프로듀서-컨슈머 패턴으로 구현된 애플리케이션에서는 ArrayBlockingQueue와 같이 크기가 제한된 큐를 많이 사용한다.
- 크기가 제한된 큐는 put과 take 메소드를 제공하며 put과 take메소드에는 다음과 같은 선행 족너이 있다.
    - 버퍼 내무가 비어있다면 값을 take할 수 없고, 버퍼가 가득 차 있다면 값을 put할 수 없다.
- 상태 종속적인 메소드에서 선행 조건과 관련된 오류가 발생하면 에외를 발생시키거나 오류 값을 리턴하기도 하고, 아니면 선행 조건이 원하는 상태에 도달할때까지 대기하기도 한다.
- 선행 조건에 오류가 발생했을 때 오류를 처리하는 여러 가지 방법을 적용해 서로 다른 버전의 크기가 제한된 버퍼를 만들어 볼 예쩡이다.
- 여기에서 만들 클래스는 모두 예제 14.2의 BaseBoundedBuffer 클래스를 상속받는다. 
- 예제 14.2 의 BaseBoundedBuffer 클래스는 전통적인 배열 기반의 원형 버퍼로 구성돼 있으며 버퍼 내부의 상태 변수는 synchronized 키워드를 사용해 동기화하고 있다.
- BaseBoundedBuffer 는 하위 클래스에서 put, take 메소드를 구현할 때 사용할 수 있도록 doPut, doTake 메소드를 제공하고 내부적으로 갖고 있는 상태 변수는 외부에 공개하지 않는다.
- 예제 14.2 크기가 제한된 버퍼의 기반 클래스
~~~java
@ThreadSafe
public abstract class BaseBoundedBuffer<V> {
    @GuardedBy("this")
    private final V[] buf;
    @GuardedBy("this")
    private int tail;
    @GuardedBy("this")
    private int head;
    @GuardedBy("this")
    private int count;

    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[]) new Object[capacity];
    }

    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length) {
            tail = 0;
        }
        ++count;
    }

    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if(++head == buf.length) {
            head = 0;
        }
        --count;
        return v;
    }
    
    public synchronized final boolean isFull() {
        return count == buf.length;
    }
    
    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}
~~~

### 14.1.1 예제 : 선행 조건 오류를 호출자에게 그대로 전달
- 예제 14.3 의 GrumpyBoundedBuffer 는 원하는 버퍼를 구현하고자 하는 첫 단계이며 섬세하지 못하고 굉장히 거친 모습을 갖고 있다.
- 예제 14.3 선행 조건이 맞지 않으면 그냥 넘춰버리는 버퍼 클래스
~~~java
public class GrumpyBoundedBuffer<V> extends BaseBoundedBuffer {
    public GrumpyBoundedBuffer(int capacity) {
        super(capacity);
    }
    
    public synchronized void put(V v) throws BufferFullException {
        if(isFull()) {
            throw new BufferFullException();
        }
        doPut(v);
    }
    
    public synchronized V take() throws BufferEmptyException {
        if(isEmpty()) {
            throw new BufferEmptyException();
        }
        return (V) doTake();
    }
}
~~~
- put 메소드와 take 메소드는 확인하고 동작하는 구조로 구현됐기 때문에 synchronized 키워드를 적용해 버퍼 내부의 상태 변수에 동기화된 상태로 접근하게 돼 있다.
- 이렇게 구현하면 만들기는 간단하고 편리하지만 사용할때는 여간 짜증나는게 아니다. 예외는 예외적인 상황에서만 사용하는게 정상이다.
- 버퍼가 가즉 찼다는 건 크기가 제한된 버퍼에서는 당연히 발생할 수 있는 일이기 때문에 그다지 예외적인 상황이라고 볼 수 없다.
- 버퍼를 구현할 때 아주 간단하게 구현하긴 헀지만 그걸 사용할때는 그다지 간단하지 않다.
- 즉 GrumpyBoundedBuffer 를 사용하는 외부의 클래스는 put이나 take 메소드를 호출할때마다 발생할 가능성이 있는 예외 상황을 매번 처리해줘야 한다.
- GrumpyBoundedBuffer 클래스의 take 메소드를 호출하는 일반적인 구조가 예제 14.4에 깔끔하게 소개돼 있다. 프로그램 여기저기에서 put 메소드와 take메소드를 사용한다면 그다지 깔끔하지 않으렉 분명하다.
- 예제 14.4 GrumpyBoundedBuffer를 호출하기 위한 호출자 측의 코드
~~~
while (true) {
    try {
        V item = grumpyBoundedBuffer.take();
    } catch (BufferEmptyException e) {
        Thread.sleep(SLEEP_GRANUALRITY);
    }
}
~~~
- 이와 유사한 또 다른 방법으로는 우너하는 상태가 아닐 때 오류 값을 리턴하는 방법이 있다.
- 오류 값을 리턴하는 방법은 예외 상황이 아님에도 불구하고 다시 시도하라는 의미로 예외를 던지지는 않으니 약간 나은 방법이라고 볼 수도 있겠다.
- 하지만 선행 조건이 맞지 않다고 해서 호출자가 오류를 맡아서 처리해야 하는 원론적인 방법상의 문제를 해결하지는 못한다.
- 재시도하는 논리를 구현하는 방법에 있어서 예제 14.4의 호출자 측 코드 말고 다른 방법도 있다.
- 호출자가 잠자는 대기 시간 없이 take 메소드를 즉시 다시 호출하는 방법인데, 흔히 스핀 대기 또는 busy wating 방법이라고 한다. 
- 이 방법을 사용했는데 버퍼의 상태가 원하는 값으로 얼른 돌아오지 않는다면 상당한 양의 CPU 자원을 소모하게 된다. 
- 반대로 CPU자원을 덜 소모하도록 하고자 일정 시간 동안 대기하게 할 수 있는데, 이렇게 하면 버퍼가 워하는 값으로 돌아왔음에도 불구하고 계속해서 대기 상태에 빠져있는 '과다대기' 문제가 생기기도 한다.
- 따라서 호출자는 CPU를 덜 사용하되 응답성에서 손해를 보거나 응답성은 좋지만 CPU를 엄청나게 소모하는 두가지 방법 가운에 어느 것을 사용할지 선택해야 한다.

### 14.1.2 예제 : 폴링과 대기를 반복하는 세련되지 못한 대기 상태
- 예제 14.5의 SleepyBoundedBuffer 클래스는 '폴링하고 대기하는' 재시도 반복문을 put,take 메소드 내부에 내장시켜서 외부의 호출 클래스가 매번 직접 재시도 반복문을 만들어 사용해야 하는 불편함을 줄여주고자 하고 있다.
- 만약 버퍼가 비어있다면 take 메소드는 다른 스레드가 버퍼에 값을 집어 넣을 때까지 대기하고, 버퍼가 가득 차 있다면 put 메소드는 다른 스레드가 값을 꺼내 버퍼에 빈 공간이 생길 때까지 대기한다.
- 이 방법은 선행 조건 관리하는 부분을 버퍼 내부에 내장했기 때문에 외부에서 버퍼를 훨씬 간편하게 사용할 수 있다.
- 외부에서 간단하게 사용할 수 있다는건 버퍼를 구현하는 입장에서 고이장히 중요하고 그래야만 하는 요건이다
- SleepyBoundedBuffer 클래스의 구현 내용을 보면 이전에 구현했던 방법보다 약간 더 복잡한 모양을 갖추고 있다. 버퍼 내부를 보면 상태 조건을 나타내는 변수가 버퍼 락으로 동기화돼 있기 때문에 버퍼의 락을 확보한 상태에서 상태 조건이 적절한지 먼저 확인한다.
- 만약 상태 조건이 적절하지 않다면 실행 중이던 스레드가 잠시 대기 상태에 들어가고, 대기 상태에 들어가기 직전에 락을 풀어서 다른 스레드가 버퍼의 상태 변수를 사용할 수 있도록 한다.
- 대기 상태에 있던 스레드가 꺠어나면 락을 다시 확보한 다음 상태 조거능ㄹ 다시 확인한다.
- 잠시 대기하고 상태 조건을 확인하는 반복문을 계속해서 실행하다 조건이 적절해지면 반복문을 빠져나와 작업을 처리한다.
- 기능을 호출하는 호출자의 입장에서 보면 일단 그럴듯하게 동작한다. 만약 상태 조건이 이미 적절하게 갖춰져 있었다면 작업 역시 즉시 실행할 수 있고, 그렇지 않다면 대기 상태에 들어간다.
- 물론 호출자의 반복문 내부의 구조를 알아야 할 필요도 없고 오류가 발생하는지 보다가 재시도해야 할 필요도 없다.
- 잠자기 대기 상태에 들어가는 시간을 길게 값거나 짧게 잡으면 응답 속도와 CPU 사용량 간의 트레이드 오프가 발생한다.
- 대기 시간을 짧게 잡으면 CPu 사용량은 줄어들지만 응답 속도가 떨어진다.
- 그림 14.1을 보면 대기 시간에 따라 응답 속도가 어떻게 변하는지를 그래프로 보여주고 있다.
- 버퍼에 공간이 생긴 이후에 스레드가 대기 상태에서 빠져나와 상태 조건을 확인하기까지 약간의 시간차이가 발생하기도 한다는 점을 주의하자.
- 예제 14.5 세련되지 못한 대기 방법을 사용하는 SleepyBoundedBuffer
~~~java
public class SleepyBoundedBuffer<V> extends BaseBoundedBuffer {
    public SleepyBoundedBuffer(int size ) {super(size);}
    
    public void put(V v) throws InterruptedException {
        while (true) {
            synchronized (this) {
                if(!isFull()) {
                    doPut(v);
                    return;
                }
            }
            Thread.sleep(SLEEP_GRANUALITY);
        }
    }
    
    public V take() throws InterruptedException {
        while (true) {
            synchronized (this) {
                if(!isEmpty()) {
                    return (V) doTake();
                }
            }
            Thread.sleep(SLEEP_GRANUALITY);
        }
    }
}
~~~
- SleepyBoundedBuffer를 사용하는 호출자는 InterruptedException이 발생하는 경우를 처리해야 한다.
- 메소드 내부에서 원하는 조건을 만족할때까지 대기해야 한다면 작업이 취할 수 있는 기능을 제공하는 편이 좋다.
- 대부분의 깔끔하게 만들어진 JDK 라이브러리 메소드처럼 SleepyBoundedBuffer 역시 인터럽트를 걸면 즉시 리턴되면서 InterruptedExepction을 던지는 작업 취소 방법을 적용하고 있다.
- 이와 같이 폴링하고 대기하는 반복 작업을 통해 블로킹 연산을 구현하는 일은 상당이 고생스럽다.
- 이런 고생스러움을 해결하는게 조건 큐다

### 14.1.3 조건 큐 - 문제 해결사
- 조건 큐는 주방에 놓여 있는 토스트 기계에서 "토스트가 다 됐습니다."라고 울리는 벨과 같다.
- 벨소리만 신경쓰면 되고, 벨소리를 놓쳐도 나중에 상태 확인하고 만족하면 꺼내고 아니면 다시 벨소리에 귀를 기울이는 대기 상태에 들어갈 수 있다.
- 조건 큐는 여러 스레드를 한 덩어리로 묶어 특정 조건이 만족할때까지 한꺼번에 대기할 수 있는 방법을 제공하기 때문에 '조건큐' 라는 이름으로 불린다.
- 데이터 값으로 일반적인 객체를 담아두는 보토으이 큐와 달리 조건 큐에는 특정 조건이 만족할때까지 대기해야 하는 스레드가 값으로 들어간다.
- 자바 언어에서 사용하는 모든 객체를 락으로 활용할 수 있는 것처럼 모든 객체는 스스로를 조건 큐로 사용할 수 있으며 모든 객체가 갖고 있는 wait, notify, notifyAll 메소드는 조건 큐의 암묵적인 API라고 봐도 좋다.
- 자바 객체의 암묵적인 락과 암묵적인 조건 큐는 서로 관련돼 있는 부분이 있는데 이를테면 X라는 객체의 조건 큐 API를 호출하고자 하면 반드시 객체 X의 암묵적인 락을 확보하고 있어야만 한다.
- 상태 기반의 조건이 만족하기를 기다리도록 구현된 부분이 객체 내부의 상태를 일관적으로 유지하도록 구현된 코드와 필연적으로 굉장히 밀접하게 관련돼 있기 때문이다.
- 객체 내부의 상태를 확인하기 전에는 조건이 만족할대까지 대기할 수가 없고, 객체 내부의 상태를 변경하지 못하는 한 해당 객체의 조건 큐에서 대기하고 이는 객체를 풀어줄 수가 없으니 당연하다.
- Object.wait 메소드는 현재 확보하고 있는 락을 자동으로 해제하면서 운영체제에게 현재 스레드를 멈춰달라고 요청하고, 따라서 다른 스레드가 락을 확보해 객체 내부의 상태를 변경할 수 없도록 해준다.
- 대기 상태에서 깨어나는 순간에는 해제했던 락을 다시 확보한다.
- 풀어서 말하자면 Object.wait 메소든느 "나는 대기상태에 들어갈 예정인데, 만약 뭔가 재미있는 일이 생기면 깨워주기 바랍니다."라는 뜻이다.
- notify, notifyAll은 "뭔가 재미잇는 일이 발생했습니다"
- 예제 14.6의 BoundedBuffer 클래스는 wait와 notifyAll메소드를 사용해 크기가 제한된 버퍼를 구현하고 있다. 예전에 sleep메소드로 대기 상태에 들어가던 메소드보다 구현하기도 훨씬 간편하고 훨씬 효율적이며 응답성도 훨씬 좋다.
- 이런 구조는 굉장히 많이 발전한 모습이라고 할 수 있지만, 조건 큐를 사용했다고 해서 잠자기 대기 상태에 들어가던 버전과 비교해봤을 때 그 작동하는 모습에는 변화가 없다는 점을 알아두자.
- 전에 비해 몇가지 최적화 작업을 한 것 뿐
- 그러나 조건 큐를 사용하면 상태 종속성을 관리하거나 표헌하는데 있어서 훨씬 효율적이며 간편한 방법이긴 하다.
- 예제 14.6 조건 큐를 사용해 구현한 BoundedBuffer
~~~java
@ThreadSafe
public class BoundedBuffer2<V> extends BaseBoundedBuffer  {
    
    //조건 서술어 : not-full (!isFull())
    //조건 서술어 : not-empty(!isEmpty())
    
    public BoundedBuffer2(int size) {
        super(size);
    }
    
    //만족할때까지 대기 : not-full
    public synchronized void put(V v) throws InterruptedException {
        while (isFull()) {
            wait();
        }
        doPut(v);
        notifyAll();
    }
    
    //만족할대까지 대기 : not-empty
    public synchronized V take() throws InterruptedException {
        while (isEmpty()) {
            wait();
        }
        
        V v = (V) doTake();
        notifyAll();
        return v;
    }
}
~~~
 - BoundedBuffer2는 이제 쓸만하게 구현됐다.
 - 사용 편리, 상태 종속정도 깔끔하게 관리.
 
 ## 14.2 조건 큐 활용
 - 조건 큐를 사용하면 효율적이면서 응답속도도 빠른 상태 종속적인 클래스를 구현할 수 있지만, 올바르지 않은 방법으로 사용할 가능성도 높음
 - 컴파일러나 자바 플랫폼에서 정의하고 있지는 않지만, 조건 큐를 제대로 활용하려면 꼭 지켜야 하는 몇 가지 규칙이 있다.
 
 ### 14.2.1 조건 서술어
 - 조건 큐를 올바로 사용하기 위한 가장 핵심적인 요소는 바로 해당 객체가 대기하게 될 조건 서술어를 명확하게 구분해내는 일이다.
 - wait과 notify를 사용함에 있어서 가장 많은 혼란을 줄 수 있는 요소가 바로 조건 서술어인데, JDK 라이브러리 API에도 전혀 언급되지 않고, 조건 서술어를 올바르게 사용하는데 꼭 필요한 내용이 자바 언어 명세나 JVM 구현 매뉴얼 어디에도 소개돼 있지 않다.
 - 실제로 자바 언어 명세나 API 문서에 조건 서술어라는 단어가 명시 X
 - 하지만 조건 서술어가 없으면 조건부 대기 기능이 동작할 수 없다.
 - 조건 서술어는 애초에 특정 기능이 상태 종속적이 되도록 만드는 선행 조건을 의미한다.
    - ex: 크기가 제한된 버퍼에서 take 메소드는 버퍼에 값이 들어있는 경우에만 작업을 진행할 수 있고, 버퍼가 비어 있다면 대기해야 한다.
    - take 메소드의 입장에서는 작업을 진행하기 전에 확인하는 "버퍼에 값이 있어야 한다"가 조건 서술어이다.
    - put은 버퍼에 빈 공간이 있다가 조건 서술어
- 조건 서술어는 클래스 내부의 상태 변수에서 유추할 수 있는 표현식이다.
- BaseBoundedBuffer 클래스는 "버퍼에 값이 있어야 한다"는 조건 서술어에 count 변수에 0보다 큰지 비교하고, "버퍼에 빈 공간이 있어야 한다"는 조건 서술어에 대해서는 count 변수의 값이 작은지를 확인
- 조건 큐와 연결된 조건 서술어를 할상 문서로 남겨야 하며, 그 조건 서술어에 영향을 받는 메소드가 어느 것인지도 명시해야 한다.
- 조건부 대기와 관련된 락와 wait 메소드와 조건 서술어는 중요한 삼각관계를 유지
- 조건 서술어는 상태 변수를 기반으로 하고, 상태 변수는 락으로 동기화돼 있으니 조건 서술어를 만족하려면 반드시 락을 확보해야만 한다.
- 또한 락 객체와 조건 큐 객체는 반드시 동일한 객체여야만 한다.
- BoundedBuffer 클래스는 버퍼 락으로 버퍼의 상태를 동기화하고 있으며 버퍼 객체 자체를 조건 큐로 사용하고 있다.
- take 메소드를 보면 먼저 버퍼 락을 확보한 다음 조건 서술어를 확인한다.
- 조건 서술어를 확인해봤을 때 만족하지 않았따면 take 메소드는 다른 스레드에서 put메소드를 통해 버퍼에 값을 추가할 때까지 대기한다.
- take 메소드는 이렇게 대기하는 방법으로 해당 버퍼의 객체의 wait 메소드를 호출해 암묵적인 조건 큐를 활용하며, 이 작업을 하는 고자ㅓㅇ에도 역시 조건 큐 객체에 대한 락을 확보한 상태여야 한다. 
- take 메소드는 이미 조건 서술어를 확인하는 시점에 필요한 락을 확보한 상태이다.
- wait 메소드는 먼저 락을 해제하고 현재 스레드를 대기 상태에 두고, 일정 시간 이후에 타임아웃이 발생하거나 스레드에 인터럽트가 걸리거나 notify 또는 notifyAll 을 통해 알림을 받을 때까지 대기한다.
- 대기 상태에 있던 스레드가 깨어나면 wait 메소드는 리턴되기 전에 락을 다시 확보한다.
- wait 메소드에서 깨어나는 스레드라고 해도 락을 다시 확보함에 있어서는 별다른 우선 순위를 갖지 않으며, 일반적인 다른 스레드와 같이 락을 확보하는 경쟁에 참여해 공정하거나 불공정한 방법을 거쳐 락을 확보한다.
- wait 메소드를 호출하는 모든 경우에는 항상 조건 서술어가 연결돼 있다. 특정 조건 서술어를 놓고 wait 메소드를 호출할 때, 호출자는 항상 해당하는 조건 큐에 대한 락을 이미 확보한 상태여야 한다. 또한 확보한 락은 조건 서술어를 호가인하는데 필요한 모든 상태 변수를 동기화하고 있어야 한다.

### 14.2.2 너무 일찍 깨어나기
- wait 메소드를 호출하고 리턴됐다고 해서 반드시 해당 스레드가 대기하고 있던 조건 서술어를 만족한다는 것은 아니다
- 하나의 암묵적인 조건 큐를 두 개 이상의 조건 서술어를 대상으로 사용할 수도 있다.
- 어디에선가 notifyAll을 호출해서 대기 상태에 있던 스레드가 깨어났다면, wait 메소드가 리턴됐다고 해서 wait 하기 직전에 확인했던 조건 서술어를 만족하게 됏따는 것으로 이해해서는 안된다.
- 게다가 wait 메소드는 누군가가 notify해주지 않아도 리턴되는 경우도 있다.
- wait 메소드를 호출했던 스레드가 대기 상태에서 깨어나 다시 실행된다고 보면, 조건 큐와 연결돼 있는 락을 다시 확보한 상태이다. 그렇다면 조건 서술어는 만족됐는가? 그럴수도 아닐 수도 있다.
- 스레드가 깨어난 이후 락을 다시 확보하기 직전까지 다른 스레드가 락을 미리 확보하고는 조건 서술어와 관련된 상태 변수의 값을 변경시킬 수도 있다.
- 아니면 아예 wait 메소드를 처음 호출한 이후에 한 번도 조건 서술어를 만족했던 적이 없었을 수도 있다.
- 다른 스레드가 notify 또는 notifyAll 메소드를 왜 호출했는지 알 방법이 없다.
- 동일한 조건 큐를 대상으로 하는 다른 조건 서술어가 만족돼 호출한것일 수도 있다.
- 하나의 조건 큐에 여러 개의 조건 서술어를 연결해 사용하는 일은 굉장히 흔한 방법이다.
- BoundedBuffer 역시 하나의 조건 큐를 놓고 "버퍼에 값이 있어야 한다"와 "버퍼에 빈 공간이 있다"는 두 개의 조건 서술어를 한꺼번에 연결해 사용하고 있다.
- 이런 모든 원인 때문에 wait 메소드가 깨어나 리턴되고 나면 조건 서술어를 한번 더 확인해야만 하며, 만약 이번에도 조건 서술어를 만족하지 않으면 다시 wait 메소드를 호출해 대기 상태에 들어가야 한다.
- 여러번 그럴 수 있으므로 wait 메소드를 반복문 안에 넣어야 하고 그때마다 조건 서술어를 확인해야 한다.
- 조건부 wait 메소들르 사용하는 표준적인 방법이 예제 14.7에 소개돼 있다.
- 예제 14.7 상태 종속적인 메소드의 표준적인 형태
~~~
void stateDependentMethod() throws InterruptedException {
    //조건 서술어는 반드시 락으로 동기화된 이후에 확인해야 한다.
    synchronized(lock) {
        while(!conditionPredicate()) {
            lock.wait();
        }
        // 객체가 원하는 상태에 맞춰졌다.
    }
}
~~~  
- 조건부 wait 메소드를 사용할 때
    - 1. 항상 조건 서술어를 명시해야 한다.
    - 2. wait 메소드를 호출하기 전에 조건 서술어를 확인하고, wait 에서 리턴된 이후에도 조건 서술어를 확인해야 한다.
    - 3. wait 메소드는 항상 반복문 내부에서 호출해야 한다.
    - 4. 조건 서술어를 확인하는데 관련된 모든 상태 변수는 해당 조건 큐의 락에 의해 동기화돼 있어야 한다.
    - 5. wait, notify, notifyAll 메소드를 호출할 땐느 조건 큐에 해당하는 락을 확보하고 있어야 한다.
    - 6. 조건 서술어를 확인한 이후 실제로 작업을 실행해 작업이 끝날 때까지 락을 해제해서는 안된다.
    
### 14.2.3 놓친 신호
- 데드락이나 라이브 락과 같은 또다른 활동성 문제는 놓친 신호
- 특정 스레드가 이미 참을 만족하는 조건을 놓고 조건 서술어를 제대로 확인하지 못해 대기 상태에 들어가는 상황을 놓친 신호라고 한다.
- 즉 놓친 신호 문제가 발생한 스레드는 이미 지나간 일에 대한 알림을 받으려 대기하게 된다. 
- 긴 시간을 대기하거나 영영 대기 상태에 빠질 수도 있다. 
- 원인은 스레드에 대한 알림이 일시적이라는데에 있다.
- 스레드 A가 조건 큐에 신호를 보내주고 신호가 지나간 이후에 스레드 B가 동일한 조건 큐에서 대기한다면 스레드 B는 대기 상태에서 깨어나지 못한다. 스레드 B가 대기 상태에서 빠져나오려면 신호가 한번 더 지나가야 한다.
- 놓친 신호는 프로그램을 작성할 때 앞에서 소개한 여러 가지 주의 사항을 지키지 않아서 발생한다.
    - ex : wait 메소드를 호출하기 전에 조건 서술어를 확인하지 못하는 경우 놓친 신호 문제가 발생할 가능성도 있다.
- wait 메소드를 호출하기 전에 조건을 확인하는 부분은 예제 14.7과 같은 형태로 작성하면 놓친 신호 문제에 대해서 걱정하지 않아도 된다.

### 14.2.4 알림
- 조건부 대기 관련 기능에서 대기가 아닌 다른 한쪽은 '알림'이다.
- 크기가 제한된 버퍼 클래스에 값이 전혀 들어 있지 않은 상태에서 take 메소드를 호출하면 대기 상태에 들어간다.
- take 메소드가 대기 상태에 들어간 이후 버퍼 클래스에 값이 들어왔을 때 대기 상태에서 다시 빠져나오게 하려면 버퍼 클래스에 값이 추가되는 모든 실행 경로의 코드에서 알림 조치를 취해야 한다.
- BoundedBuffer 클래스에는 값이 추가되는 코드가 딱 한군데 있는데, 바로 put 메소드이다. put 메소드의 코드를 보면 값을 성공적으로 추가한 이후에 notifyAll 메소드를 호출하게 돼 있다.
- 이와 비슷하게 take 메소드 역시 버퍼에서 값을 뽑아낸 직후에 notifyAll메소드를 호출하도록 돼 있느넫, 이는 take 에서 값을 제거해 공간이 남기 때문에 공간이 모자라 값을 추가하지 못하고 대기 상태에 들어가 있던 스레드에게 추가 작업을 다시 시도해보라는 의미이다.
- 특정 조건을 놓고 wait 메소드를 호출해 대기 상태에 들어간다면, 해당 조건을 만족하게 된 이후에 반드시 알림 메소드를 사용해 대기 상태에서 빠져나오도록 해야 한다.
- 조건 큐 API 에서 알림 기능을 제공하는 메소드에는 두 가지가 있다.
    - 1. notify
    - 2. notifyAll
- 어느 메소드를 호출하더라도 조건 큐 객체에 댛나 락을 확보한 상태에서만 호출할 수 있다.
- notify 메소드를 호출하면 JVM은 해당하는 조건 큐에서 대기 상태에 들어가 있는 다른 스레드 하나를 골라 대기 상태를 풀어준다.
- notifyAll 을 호출하면 해당하는 조건 큐에서 대기 상태에 들어가있는 모든 스레드를 풀어준다.
- notify나 notifyAll 을 호출할때는 반드시 해당하는 조건 큐 객체에 대한 락을 확보해야 하고 wait 메소드를 호출했던 스레드 역시 조건 큐에 대한 락을 확보하지 못하면 대기 상태에서 깨어날 수 없기 때문에 notify나 notifyAll을 호출한 이후에는 최대한 빨리 락을 풀어줘야 대기 상태에서 깨어난 스레드가 얼른 동작할 수 있다.
- 여러 개의 스레드가 하나의 조건 큐를 놓고 대기 상태에 들어갈 수 있는데, 대기 상태에 들어간 조건이 서로 다를 수 있기 때문에 notifyAll 대신 notify메소드를 사용해 대기 상태를 풀어주는 방법은 위험성이 높다.
- 단 한번만 알림 메시지를 전달하게 되면 앞서 소개했떤 '놓친 신호' 와 유사한 문제가 생길 가능성이 높다.
- BoundedBuffer 클래스를 보면 특별한 경우가 아닌 이상 notifyAll 메소드를 사용하는 편이 안전한 이유를 수비게 알 수 있다.
- A라는 스레드가 PA라는 조건을 놓고 조건 큐에서 대기중이고 스레드 B는 PB조건을 놓고 동일한 조건 큐에서 대기 중이라고 가정해보자.
- 그런데 조건 PB가 먼저 만족하게 되고 스레드 C가 notify메소드를 호출하면 JVM은 조건 큐에서 대기중인 스레드 하나를 골라 깨우는데, 만약 스레드 A를 꺠운다면 조건 PA를 확인하고 조건을 만족하지 않는다는 사실을 확인하고 다시 대기 상태에 들어가게 된다.
- 그러는 동안 실제로 작업을 진행할 수 있는 상태가 된 스레드 B는 깨지도 못한 상태에서 계쏙 대기해야 한다. 
- 이런 뺴앗긴 신호 결과 이미 발생해서 날아가버린 신호를 대기하느라 대기 상태에서 깨어나지 못한다는 문제는 동일하다.
- notifyAll 대신 notify 메소드를 사용하려면 다음과 같은 족너에 해당하는 경우만 사용하는 것이 좋다.
    - 단일 조건에 따른 대기 상태에서 깨우는 경우 : 해당하는 조건 큐에 단 하나의 조건만 사용하고 있는 경우이고, 따라서 각 스레드는 wait 메소드에서 리턴될 때 동일한 방법으로 실행된다.
    - 한번에 하나씩 처리하는 경우 : 조건 변수에 대한 알림 메소드를호추라면 하나의 스레드만 실행시킬 수 있는 경우
- BoundedBuffer 클래스는 한 번에 하나씩 처리하는 조건은 만족하지만 "공간이 없다", "비어있다"는 두가지 조건을 사용하기 때문에 단일 조건에 따라 대기 상태에 들어가는 경우라는 조건에 해당하지 않는다.
- 대부분의 클래스는 위의 두 가지 조건을 모두 만족하지 모산다.
- 일반적으로 notifyAll을 사용한다. 
- 그러나 notifyAll은 비효율적이라고 볼 수 있다. 컨텍스트 스위칭 빈번, 상당량의 락 확보 경쟁이 벌어진다.(계속 다 풀고 다 경쟁하기 때문) 안전성은 높이지만 성능을 낮추게 된다.
- BoudnedBuffer 클래스의 put과 take 메소드에서 실행되는 알림 기능은 보수적인 편이다. 즉 버퍼에 객체가 들어가거나 객체를 뽑아낼 대마다 무조건 알림 메소드를 호출한다.
- 버퍼가 비어있다가 값이 들어오거나 가득 찬 상태에서 값을 뽑아내는 경우에만 대기 상태에서 빠져나올 수 있다는 점을 활용해 take,put 메소드가 대기 상태에서 빠져나올 수 있는 상태를 만들어주는 경우에만 알림 메소드를 호출하도록 하면 이런 보수적인 측면을 최적화 할수 있다.
- 이런 최적화 방법을 조건부 알림이라고 한다.(성능을 향상시킬 수 있지만 복잡하다.)
- 예제 14.8에서 조건부 알림 방법을 적용한 모습을 볼 수 있다.
- 단일 알림 방법이나 조건부 알림 방법은 최적화된 방법이다. 최적화 방법을 적절치 못하게 적용하면 이상하게 발생하는 프로그램 오류를 만나게 될 수 있다.
- 예제 14.8 BoundedBuffer.put 메소드에 조건부 알림 방법을 적용한 모습
~~~
public synchronized void put(V v) throws InterruptedException {
    while(isFull()) {
        wait;
    }
    boolean wasEmpty = isEmpty();
    odPut(v);
    if(wasEmpty) {
        notifyAll();
    }
}
~~~

### 예제 14.2.5 예제 : 게이트 클래스
- 예제 5.11의 시작 게이트 래치는 최초에 1이라는 값을 갖고 있으며 바이너리 래치로 동작하도록 설계돼 있다. 
- 바이너리 래치 = 초기와 종료의 두 가지 상태를 갖는다는 의미이다.
- 시작 게이트 래치는 문이 열리기 전까지는 모든 스레드가 통과하지 못하도록 막고 있다가 특정 조건이 만족하는 시점에 한꺼번에 통과하도록 몬을 열어준다.
- 이와 같은 형태의 래치는 한번 열리고 나면 다시는 문을 닫을 수 없다는 특정이 있다.
- 예제 14.9에서 보다시피 조건부 대기 기능을 활용하면 여러 번 닫을 수 있는 ThreadGate와 같은 클래스를 어렵지 않게 구현 가능
- ThreadGate는 문을 열었다 닫았다 할 수 있는 구조, 문이 열릴 때까지 await 메소드를 제공한다.
- open 메소드에서 스레드를 대기 상태에서 풀어줄 때까지 알림 방법으로 notifyAll 메소드를 사용하는데 앞서 설명했던 한 번에 하나씩 처리하는 조건이 해당되지 않기 때문에 notify 메소드를 사용할 수는 없다.
- await 메소드에서 사용하는 조건은 단순하게 isOpen 메소드를 사용해 문이 열렸는지를 확인하는 것보다 좀 더 복잡하게 돼 있다.
- 문이 열리는 시점에 N개의 스레드가 문이 열리기를 기다리고 있었다면 대기중이던 스레드 N개가 모두 대기 상태에서 빠져나오도록 해야 한다.
- 하지만 문이 열린 이후 짧은 시간 후에 다시 닫히는 상황이 발생하면 await 메소드에서 단순하게 isOpen 메소드만을 기준으로 대기 상태에서 깨어나도록 하는 방법이 충분하지 않을 수 있다.
- 대기 중이던 스레드가 알림을 받고는 대기 상태에서 깨어나 락을 확보하고 wait 메소드에서 리턴하고 나니 이미 isOpen 메소드의 값이 다시 '닫힘'으로 바뀔 수도 있다.
- ThreadGate 클래스는 문이 열릴 때까지 대기하는 기능만 갖고 있으므로 알림 기능은 open 메소드에서만 호출한다.
- '문이 열리기를 기다림', '문이 닫히기를 기다림' 두 가지를 지원하려면 open과 close  양쪽에서 알림 메소드를 호출해야 할 수도 있다. 유지보수가 쉽지 않다.
- 옞 14.9 wait과 notifyAll을 사용해 다시 닫을 수 잇도록 구현한 ThreadGate 클래스
~~~java
@ThreadSafe
public class ThreadGate {
    //조건 서술어 : opened-since(n) (isOpen || generation > n)
    @GuardedBy("this") private boolean isOpen;
    @GuardedBy("this") private int generation;
    
    public synchronized void close() {
        isOpen = false;
    }
    
    public synchronized void open() {
        ++generation;
        isOpen = true;
        notifyAll();
    }
    
    //만족할때까지 대기 : opened-since(generation on entry)
    public synchronized void await() throws InterruptedException {
        int arrivalGeneration = generation;
        while (!isOpen && arrivalGeneration == generation) {
            wait();
        }
    }
}
~~~

### 14.2.6 하위 클래스 안전성 문제
- 조건부 알림 기능이나 단일 알림 기능을 사용하고 나면 해당 클래스의 하위 클래스를 구현할 때 상당히 문제가 복잡해지는 문제가 생길 수 있다.
- 일단 하위 클래스를 구현할 수 있도록 상위 클래스를 구현할 때 상위 클래스에서 구현했던 조건부 또는 단일 알림 방법을 벗어나는 방법을 사용해야만 하는 경우가 있을 수 있으며, 이런 경우에 상위 클래스 대신 하위 클래스에서 적절한 알림 방법을 사용할 수 있도록 구조를 갖춰둬야 한다.
- 상태 기반으로 동작하는 클래스는 하위 클래스에게 대기와 알림 구조를 완전하게 공개하고 그 구조를 문서로 남기거나, 아니면 아예 하위 클래스에서 대기와 알림 구조에 전혀 접근할 수 없도록 깔끔하게 제한해야 한다. 
- 최소한 상태 기반으로 동작하면서 하위 클래스가 상속받을 가능성이 높은 클래스를 구현하려면 조건 큐와 락 객체 등을 하위 클래스에게 노출시켜 사용할 수 있도록 해야 하고, 그와 함꼐 조건과 동기화 정책 등을 문서로 남겨야 한다.
- 그러다보면 조건 큐와 락 객체 뿐만 아나리 상태 변수 자체를 하위 클래스에게 열어둬야 할 가능성도 있다.
- 클래스를 상속받는 과정에서 발생할 수 있는 오류를 막을 수 있는 간단한 방법 가운데 하나는 클래스를 final로 선언해 상속 자체를 금지하거나 조건 큐, 락, 상태 변수 등을 하위 클래스에서 접근할 수 없도록 막아두는 방법이 있다.
- 이런 조치를 취해두지 않으면 문제 발생 가능성이 높아진다.

### 14.2.7 조건 큐 캡슐화
- 일반적으로 조건 큐를 클래스 내부에 캡슐화해서 클래스 상속 구조의 외부에서는 해당 조건 큐를 사용할 수 없도록 막는게 좋다.
- 그렇지 않으면 클래스를 사용하는 외부 프로그램에서 조건 큐에 대한 대기와 알림 규칙을 추측한 상태에서 클래스를 처음 구현할 때 설계했던 방법과 다른 방법으로 호출할 가능성이 있다.
- 하지만 조건 큐로 사용하는 객체를 클래스 내부에 캡슐화하라는 방법은 스레드 안전한 클래스를 구현할 때 적용되는 일반적인 디자인 패턴과 비교해 볼 때 일관적이지 않은 부분이 있다.
- 조심해라

### 14.2.8 진입 규칙과 완료 규칙
- 웰링스는 wait과 notify를 적용하는 규칙을 진입 규칙과 완료 규칙으로 표현하고 있다. 
- 상태를 기반으로 하는 모든 연산과 상태에 의존성을 갖고 있는 또 다른 상태를 변경하는 연산을 수행하는 경우에는 항상 진입 규칙과 완료 규칙을 정의하고 문서화해야 한다.
- 진입규칙 : 연산의 조건
- 완료 규칙 : 해당 연산으로 인해 변경됐을 모든 상태 값이 변경되는 시점에 다른 연산의 조건도 함꼐 변경될 수 있으므로 다른 연산의 조건도 변경됐다면 해당 조건 큐에 알림 메시지를 보내야 한다는 규칙
- AbstractQueuedSynchronizer 클래스를 보면 완료 규칙의 개념을 좀 더 쉽게 이해할 수 이싿.
- 동기화 클래스에서 직접 스스로의 규칙에 따라서 알림 기능을 실행하도록 하는 대신 동기화 클래스의 메소드에서 기능을 실행한 결과로 하나 이상의 대기중인 스레드가 깨어났는지의 여부를 넘겨주도록 하고 있다. 
- API가 이와 같이 정의돼 있기 때문에 일부 상태 변화 과정에서 알림 메소드를 호출하는 일을 '까먹는'일이 훨씬 줄어든다.

## 14.3 명시적인 조건 객체 
- 명시적으로 Lock 객체를 사용하면 암묵적인 락이 활횽 형태가 지극히 제한돼 있어 처리할 수 없던 동기화 기능도 수행할 수 있다.
- 암묵적인 락을 일반화한 형태가 Lock클래스인 것처럼 암묵적인 조건 큐를 일반화한 형태는 바로 Condition 클래스이다.
- 암묵적인 조건 큐에는 여러 가지 단점이 있다.
    - 모든 암묵저인 락 하나는 조건 큐를 단 하나만 가질 수 있다.
    - 따라서 BoundedBuffer와 같은 클래스에서 여러 개의 스레드가 하나의 조건 큐를 놓고 여러 가지 조건을 기준으로 삼아 대기 상태에 들어갈 수 있다는 말이다.
- 위 두가지를 보면 notify를 사용할 수 있도록 해주는 조건 가운데 하나인 단일 대기 조건을 만족시키기가 불가능하다.
- 암묵적인 락이나 조건 큐 대신 Lock 클래스와 Condition 클래스를 활용하면 유연하게 대처 가능
- Condition 클래스도 내부적으로 하나의 Lock 클래스를 사용해 동기화를 맞춘다.
- Condition 인스턴스를 생성하려면 Lock.newCondtion 메소드를 호출한다.
- Condition 클래스 역시 하나의 락에 여러 조건으로 대기하게 할 수 있고, 또한 인터럽트에 반응하거나 반응하지 않는 대기상태, 데드라인을 정해둔 대기 상태, 공정하거나 공정하지 않은 큐처리 방법 등 암묵적인 조건 큐보다 훨씬 다양한 기능을 제공한다.
- 예제 14.10 Condition 인터페이스
~~~java
public interface Condition {

    void await() throws InterruptedException;

    void awaitUninterruptibly();

    long awaitNanos(long nanosTimeout) throws InterruptedException;

    boolean await(long time, TimeUnit unit) throws InterruptedException;

    boolean awaitUntil(Date deadline) throws InterruptedException;

    void signal();
    void signalAll();
}
~~~
- Condtion 객체는 암묵적인 조건 큐와 달리 Lock 하나를 대상으로 필요한 만큼 몇 개 라도 만들 수 있다.
- 공정한 Lock에서 생성된 Condition 객체는 Condition.await메소드에서 리턴될 때 정확하게 FIFO 순서를 따른다.
- 예제 14.11에는 크기가 제한된 버퍼를 또 다른 형태로 구현한 예가 있다.
- 여기에 구현된 내용을 보면 두 개의 Condition 객체에를 사용해 "버퍼가 가득 차지 않았다."는 notFull 조건과 "버퍼가 비어 있지 않다"는 notEmpty 조건을 처리한다.
- 버퍼의 take 메소드에서 버퍼의 큐가 비어서 대기해야 한다면 notEmpty 조건에서 대기한다.
- 그러면 put 메소드에서 notEmpty 조건에 신호를 보내서 대기중이던 take 메소드를 대기 상태에서 깨운다.
- ConditionBoundedBuffer가 동작하는 모습은 기존의 BoundedBuffer 클래스와 동일하지만, 내부적으로 조건 큐를 사용하는 모습은 훨씬 읽기 좋게 작성돼이싿.
- Condition 객체를 활용하면 대기 조건들을 각각의 조건 큐로 나눠 대기하도록 할 수 있기 때문에 단일 알림 조건을 간단하게 만족시킬 수 있다.
- 따라서 signalAll 대신 그보다 더 효율적인 signal 메소드를 사용해 동일한 기능을 처리할 숭 ㅣㅆ으므로, 컨텍스트 스위치 횟수도 줄일 수 있고, 버퍼의 기능이 동작하는 동안 각 스레드가 락을 확보하는 횟수 역시 줄일 수 있다.
- Condition객체를 사용할 것이냐 암묵적인 조건 큐를 사용할 것이냐는 ReentrantLock와 synchronized구문의 관계와 비슷
- 공정한 큐 관리 방법이나하나의 락에서 여러 개의 조건 큐를 사용할 필요가 있으면 Condition 객체를, 그럴 필요가 없다면 암묵적인 조건 큐를 사용하는 편이 더 낫다.
- 예제 14.11 명시적인 조건 큐를 활용해 작성한 크기가 제한된 버퍼
~~~java
@ThreadSafe
public class ConditionBoundedBuffer<T> {
    protected final Lock lock = new ReentrantLock();
    //조건 서술어 : notFull (count < items.length)
    private final Condition notFull = lock.newCondition();
    
    //조건 서술어 : notEmpty (count > 0)
    private final Condition notEmpty = lock.newCondition();
    
    @GuardedBy("lock")
    private final T[] items = (T[]) new Object[BUFFER_SIZE];
    
    @GuardedBy("lock")
    private int tail, head, count;
    
    //만족할떄까지 대기:notFull
    public void put(T x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await();
            }
            items[tail] = x;
            if(++tail == items.length) {
                tail = 0;
            }
            
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }
    
    //만족할때까지 대기 :notEmpty
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();
            }
            T x = items[head];
            if(++head == items.length) {
                head = 0;
            }
            -- count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
~~~
## 14.4 동기화 클래스의 내부 구조
- ReentratnLock과 Semaphore의 인터페이스는 비슷한 부분이 많다.
- 양쪽 클래스 모두 일종의 '문' 역할을 하며, 특정 시점에 제한된 개수의 스레드만이 문을 통과할 수 있다.
- 문 앞에 도착한 스레드는 문을 통과할 수도 있고, 문 앞에서 대기해야 할 수도 있고, 되돌아가야 할 수도 있다.
- 또한 양쪽 클래스 모두 인터럽트가 가능하거나 아니면 인터럽트를 걸 수 없는 조건 확인 기능을 제공하며, 조건 확인에 시간을 지정할 수도 있고, 큐 관리 방법의 공정성 역시 지정할 수 있다.
- 락을 사용해 카운팅 세마포어를 쉽게 만들 수 있다거나, 카운팅 세마포어를 사용해 락을 구현할 수도 있다
- 두 클래스 모두 AbstractQueuedSynchronizer(AQS) 를 상속받아 구현
    - AQS는 락이나 기타 동기화 클래스를 만들 수 있는 프레임워크 역할을 하며, AQS를 기반으로 하면 엄청나게 다양한 종류의 동기화 클래스를 간단하면서 효율적으로 구현할 수 있다.
- ReentrantLock이나 Semaphore 클래스 뿐만 아니라 CountDownLatch, ReentrantReadWriteLock, SynchronousQueue, FutureTask 클래스도 AQS 기반
- AQS를 사용해보면 동기화 클래스를 구현할 때 필요한 다양 잡무를 처리해준다.(대기 중인 스레드를 FIFO 쿠에서 관리하는 기능등)
- AQS를 기반으로 만들어진 개별 동기화 클래스는 스레드가 대기 상태에 들어가야 하는지 아니면 그냥 통과해야 하는지의 조건을 유연하게 정의할 수 있다.
- 동기화 클래스를 작성할 때 AQS 기반으로 작성하면 장점이 있다.
    - 구현시 필요한 노력 줄여줌
    - 동기화 클래스 하나를 기반으로 다른 동기화 클래스를 구현할 때 여러 면에서 신경 써야 하는 부분이 줄어든다.
- 예제 14.12 Lock을 사용해 구현한 카운팅 세마포어
~~~java
@ThreadSafe
public class SemaphoreOnLock {
    private final Lock lock = new ReentrantLock();
    // 조건 서술어 : permitsAvailable (permits > 0)
    private final Condition permitsAvailable = lock.newCondition();
    @GuardedBy("lock") private int permits;
    
    SemaphoreOnLock(int initialPermits) {
        lock.lock();
        try {
            permits = initialPermits;
        } finally {
            lock.unlock();
        }
    }
    
    // 만족할떄까지 대기 : permitsAvailable
    public void acquire() throws InterruptedException {
        lock.lock();
        try {
            while (permits <= 0) {
                permitsAvailable.await();
            }
            --permits;
        } finally {
            lock.unlock();
        }
    }
    
    public void release() {
        lock.lock();
        try {
            ++permits;
            permitsAvailable.signal();
        } finally {
            lock.unlock();
        }
    }
}
~~~

- SemaphoreOnLock 클래스를 보면 허가를 받을 때 대기 상태에 들어갈 수 있는 지점이 두 군데에 있다.
- 한곳은 락으로 세마포어를 동기화시키는 지점이고, 다른 쪽은 허가를 내주지 못하는 경우에 대기하는 지점을 말한다.
- AQS 기반으로 만들어진 동기화 클래스는 대기 상태에 들어갈 수 있는 지점이 단 한군데이기 때문에 컨텍스트 스위칭 부하를 줄일 수 있고, 결과적으로 성능을 높일 수 있다.

## 14.5 AQS
- 개발자가 AQS를 직접 사용할 일은 거의 없을 것이다. 그러나 어떻게 만들어져있는지는 살펴보자
- AQS 기반의 동기화 클래스가 담당하는 작업 가운데 가장 기본이 되는 연산은 바로 확보와 해제 이다.
- 확보 연산은 상태 기반으로 동작하며 항상 대기 상태에 들어갈 가능성이 있다.
- 락이나 세마포어 등의 입장에서는 확보하려는 락이나 퍼밋을 확보한다는 것으로 그 의미가 굉장히 명확하다.
- 이 연산을 사용하는 호출자는 항상 원하는 상태에 다다를 때까지 대기할 수 있다는 가능성을 염두에 둬야 한다.
- CountDownLatch 클래스를 놓고 보면 확보라는 연산은 "래치가 완료 상태에 다다를 때까지 대기하라"는 뜻이다.
- 해제 연산은 대기 상태에 들어가지 않으며 대신 확보 연산에서 대기중인 스레드를 풀어주는 역할을 한다.
- 특정 클래스가 상태 기반으로 동작하려면 반드시 상태 변수를 하나 이상 갖고 있어야 한다.
- AQS는 동기화 클래스의 상태 변수를 관리하는 작업도 어느 정도 담당하는데 getState, setState, compareAndSetState 등의 메소드를 통해 단일 int 변수 기반의 상태 정보를 관리해준다.
    - ex : ReentrantLock 클래스는 이 상태를 사용해 소속된 스레드에서 락을 몇 번이나 확보했었는지를 관리, Semaphore 클래스는 남아 있는 퍼밋의 개수 관리, FutureTask 클래스는 작업의 실행 상태 관리
- 동기화 클래스는 int 상태 변수 말고도 각자 필요한 상태 변수를 추가해 관리한다.
    - ex : ReentrantLock클래스는 락을 다시 확보하려는 것인지, 아니면 서로 다른 스레드가 경쟁하고 있는 상태인지 확인할 수 있도록 현재 락을 확보하고 있는 스레드의 목록을 관리한다
- AQS 내부의 확보와 해제 연산은 예제 14.13에 소개한 것과 같은 형태를 갖고 있다.
- AQS 를 구현한 동기화 클래스에 따라 다르지만 확보 연산은 ReentrantLock에서와 같이 배타적으로 동작할 수도 있고, Semaphore나 CoundDownLatch 클래스에서와 같이 배타적이지 않을 수도 있다.
- 확보 연산은 두가지 부분으로 나눠 볼 수 있다.
    - 1. 동기화 클래스에서 확보 연산을 허용할 수 있는 상태인지 확인하는 부분. 
        - 허용할 수 있는 상태면 해당 스레드는 작업을 꼐쏙 진행, 아니면 확보 연산에서 대기 상태에 들어가거나 실패
        - ex : 락이 풀려 있는 경우에는 락을 확보하는 연산 성공, 래치가 완료 상태에 도달해 있었다면 래치 확보 연산이 성공
    - 2. 동기화 클래스 내부의 상태를 업데이트 하는 부분
        - 특정 스레드 하나가 동기화 클래스의 확보 연산을 호출하면 다른 스레드가 해당 동기화 클래스의 학보 연산을 호출했을 때 성공할지의 여부가 달라질 수 있다.
        - ex : 락을 확보하면 락의 상태가 "해제됨" 에서 "확보됨"으로 변경, 또한 세마포어에서 퍼밋을 확보하면 남은 퍼밋의 개수가 줄어든다.
        - 반면 스레드 하나가 래치의 확보 연산을 호출했다는 것으로는 다른 스레드가 해당 래치의 확보 연산을 호출하는 결과에 영향을 주지 못하므로, 래치에 대한 확보 연산은 그 내부의 상태를 변경하지 않는다.
- 예제 14.13 AQS에서 확보와 해제 연산이 동작하는 구조
~~~
public class Example14_13 {
    boolean acquire() throws InterruptedException {
        while (확보 연산을 처리할 수 없는 상태이다) {
            if(확보 연산을 처리할 때까지 대기하길 원한다.) {
                현재 스레드가 큐에 들어 있지 않다면 스레드를 큐에 넣는다;
                대기 상태에 들어간다
            } else {
                return 실패;
            }
        }
        
        상황에 따라 동기화 상태 업데이트;
        스레드가 큐에 들어 있었다면 큐에서 제거한다;
        return 성공;
    }
    
    void release() {
        동기화 상태 업데이트;
        if(업데이트된 상태에서 대기 중인 스레드를 풀어줄 수 있다.) {
            큐에 쌓여 있는 하나 이상의 스레드를 풀어준다.
        }
    }
}
~~~
- 배타적인 확보 기능을 제공하는 동기화 클래스는 tryAcquire, tryRelease, isHeldExclusivley 등의 메소드를 지원해야 하며, 배타적이지 않은 확보 기능을 지원하는 클래스는 tryAcquireShared, tryReleaseShared 메소드를 제공해야 한다.
- AQS에 들어있는 acquire, acquireShared, release, releaseShared 메소드는 해당 연산을 실행할 수 있는지를 확인할 때 상속받은 클래스에 들어 있는 메소드 가운데 이름 앞에 try가 붙은 메소들르호출한다.
- 동기화 클래슨는 물론 getState, setState, compareAndSetState 등의 메소드를 사용해 자신의 확보와 해제 조건에 맞춰 상태 변수 값을 읽어가거나 변경할 수 있다. 
- 그리고 확보나 해제 작업이 끝난 후에는 시도했던 연산이 성공적이었는지를 리턴 값으로 알려준다.
- ex : tryAcquireShared 메소드에서 리턴 값으로 0보다 작은 값이 넘어오면 확보 연산 실패, 0을 리턴하면 배타적인 확보 연산이 성공했다는 의미, 0보다 큰값이면 배타적이지 않은 확보 연산이 성공했다는 의미
- tryRelease와 tryReleaseShared 메소드는 해제 연산을 통해 확보 연산을 하려던 스레드를 풀어줄 수 있는 상황이라면 true값을 리턴해야 한다.
- AQS 에서는 조건 큐 기능을 지우너하는 락을 간단하게 구현할 수 있도록 동기화 클래스와 연동된 조건 변수를 생성하는 방법을 제공한다.

### 14.5.1 간단한 래치
- 예제 14.14의 OneShotLatch 클래스는 AQS를 기반으로 구현한 바이너라 래치이다.
- OneShotLatch 클래스에는 두 개의 public 메소드가 있는데, 하나는 확보 연산을 실행하는 await이고 다른 하나는 해제 연산을 담당하는 signal이다.
- OneShotLatch는 초기에 닫힌 상태로 생성. await 메소드를 호출하는 모든 스레드는 래치가 열린 상태로 넘어가기 전까지 모두 대기 상태에 들어간다.
- 누군가가 signal을 호출해 해제 연산을 실행하면 그 동안 await에서 대기하던 스레드가 모두 해제되고 signal호출 이후에 await를 호출하는 스레드는 대기 상태에 들어가지 않고 바로 실행된다
~~~java
@ThreadSafe
public class OneShotLatch {
    private final Sync sync = new Sync();
    
    public void signal() {
        sync.releaseShared(0);
    }
    
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(0);
    }
    
    private class Sync extends AbstractQueuedSynchronizer {
        protected int tryAcquireShared(int ignored) {
            //래치가 열려 있는 상태(state == 1)라면 성공, 아니면 실패
            return (getState() == 1) ? 1 : -1;
        }      
        
        protected boolean tryReleaseShared(int ignored) {
            setState(1); //래치 열림
            return true; // 다른 스레드에서 호가보 연산에 성공할 가능성이 있다.
        }
    }
}
~~~
- OneShotLatch 클래스에서는 래치의 상태를 AQS 상태 변수로 표현하는데, 0이면 닫힌 상태이고 1이면 열린 상태이다.
- await 메소드는 내부에서 AQS의 acquireSharedInterruptibly 메소드를 호출하며, acquireSharedInterruptibly 메소드는 결국 OneShotLatch 클래스의 tryAcquireShared 메소드를 호출해 그 기능을 사용한다
- tryAcquireShared 메소드는 확보 연산을 진행할 수 있는 상태인지 확인해서 그 여부를 리턴해줘야 한다.
- 만약 래치가 이전에 열려 있던 상태였다면 확보 연산을 진행하도록 결과를 리턴해 스레드가 진행할 수 잇도록 하고 아니면 확보 연산이 실패했다는 결과를 리턴한다.
- 확보 연산이 실패한 경우는 acquireShared Interruptibly 메소드에서 현재 스레드가 대기 큐에 들어가야 하는 상황으로 해석한다.
- 이와 비슷하게 signal 메소드는 releaseShared 메솓를 호출 하고 releaseShared 메소드는 tryReleaseShared 메소들르 호출한다.
- tryReleaseShared 메소드는 래치의 상태를 무조건 '열림'으로 돌려놓고 래치 클래스가 완전히 열린 상태라는 결과를 리턴 값으로 알려준다.
- 그러면 AQS는 대기하던 모든 스레드에게 확보 연산을 실행하라는 신호를 보낼 것이고 이제부터는 tryReleaseShared 메소드에서 확보 연산이 성공했다는 결과를 리턴할 것이다.
- OneShotLatch 는 겨우 20줄이지만 정의된 기능을 모두 구현하며 충분한 동기화 클래스이다.
- OneShotLatch 는 AQS의 핵심 기능을 위임하는 형식으로 구현했는데, 대신 AQS를 직접 상속받는 방법으로 구현하는것도 가능하다.
    - 그러나 그러지 말고 내부클래스로 선언해 위임 기법을 사용하자

## 14.6 java.util.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습
- java.util.concurrent 패키지에 들어 있는 ReentrantLock, Semaphore, ReentrantReadWriteLock, CountDownLatch, SynchronousQueue, FutureTask등의 클래스와 같이 대기 상태에 들어갈 수 잇는 클래스는 AQS를 기반으로 구현되어 있다.
- 각 클래스가 AQS를 어떻게 활용하고 있는지 간단하게 훑어보자.

### 14.6.1 ReentrantLock
- ReentrantLock은 배타적인 확보 연산만 제공하기 때문에 tryAcquire, tryRelease, isHeldExclusively와 같은 메소드만 구현하고있다. 공정하지 않은 형태로 동작하는 tryAcquire메소드의 코드는 예제 14.15에서 볼 수 있다.
- ReentrantLock에서는 동기화 상태 값을 확보한 락의 개수를 확인하는데 사용하고, owner 라는 변수를 통해 락을 가져간 스레드가 어느 스레드인지도 관리한다.
- owner 변수에는 현재 스레드에서 락을 확보할 때 현재 스레드를 추가하고, 해제되는 시점에 owner 에서 현재 스레드를 제거하도록 돼 있다.
- tryRelease 메소드에는 unlock 메소들르 호출하기 전에 owner 변수에 들어 있는 내용을 들여다보고 해당 락을 확보하고 있는 스레드가 현재 스레드인지를 확인한다.
- tryAcquire 메소드에서는 락을 확보하려는 시도가 재진입 시도인지 아니면 최초로 락을 확보하려는 것인지 구분하기 위한 용도로 owner 변수의 내용을 사용한다.
- 스레드에서 락을 확보하려고 하면 tryAcquire 메소드는 먼저 락의 상태를 확ㅇ니하다.
- 락이 풀려있는 상태라면 락을 확보했다는 사실을 알릴 수 있도록 상태 값을 업데이트해본다.
- 락으 상태를 확인하고 값을 업데이트 하는 동안에 다른 스레드에서 락의 상태를 변경할 가능성이 있기 때문에 tryAcquire 메소드는 compareAndSetState 메소드를 사용해 상태 값을 단일 업데이트하며, 이런 방법을 사용하면 락 확보 여부를 확ㅇ니하고 값을 업데이트 하는 사이에 다른 스레드에서 값을 사용하는 경우를 방지할 수 잇다.
- 락의 상태를 확인햇는데 이미 호가보된 상태라고 판단되면, 락을 확보하고 있는 스레드가 현재 스레드인지를 확인하고 만약 그렇다면 락 확보 개수를 증가시킨다.
- 만약 락을 확보하고 있는 스레드가 현재 스레드가 아니라면 확보 시도가 실패한 것으로 처리한다.
- 예제 14.15 공정하지 않은 ReentrantLock 클래스의 tryAcquire 메소드 내부
~~~
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
~~~
- ReentrantLock은 AQS가 기본적으로 제공하는 기능이라고 할 수 있는 다중 조건 변수와 대기 큐도 그대로 사용하고 있다.
- Lock.newCondition메소드를 호출하면 AQS의 내부 클래스인 ConditionObject 객체를 받아서 사용할 수 있다.

### 14.6.2 Semaphore와 CountDownLatch
- Semaphore는 AQS의 동기화 상태를 사용해 현재 남아 있는 퍼밋의 개수를 관리한다.
- 예제 14.16에 소개돼 있는 tryAcquireShared 메소드는 현재 남아 있는 퍼밋의 개수르를 알아내고, 남아 있는 퍼밋의 개수가 모자란다면 확보에 실패했다는 결과를 리턴한다.
- 반대로 충분한 개수의 퍼밋이 남아 있었다면 compareAndSetState 메소드를 사용해 단일 연산으로 퍼밋의 개수를 필요한 만큼 줄인다.
- 퍼밋의 개수를 줄이는 작업이 성공하면 확보 연산이 성공했다는 결과를 리턴한다.
- 리턴되는 결과 값에는 성공여부와 함께 다른 스레드에서 실행하던 확보 연산을 처리할 수 있을지의 여부도 포함돼 있는데, 그렇다면 다른 스레드 역시 대기 상태에서 풀려날 수 있다.
- 메소드 내부의 while 반목문은 충분한 개수의 퍼밋이 없거나 tryAcquireShared 메소드가 확보 연산의 결과로 퍼밋 개수를 단일 연산으로 변경할 수 있을 떄까지 반복한다.
- compareAndSetState 메소드를 호출했을 때 다른 스레드와 경쟁하는 상태였다면 값을 변경하지 못하고 실패할 수도 있으며, 실패헀다면 계속해서 재시도하게 되고, 허용할만한 횟수 이내에서 재시도를 하다 보면 위의 두가지 조건 중 하나라도 만족하게 된다.
- 이와 비슷하게 tryReleaseShared 메소드는 퍼밋의 개수를 증가시키며, 따라서 현재 대기 상태에 들어가 있는 스레드를 풀어줄 가능성도 있고, 성공할 때까지 상태 값 변경 연산을재시도한다.
- tryReleaseShared 메소드의 리턴 결과를 보면 해제 연산에 따라 다른 스레드가 대기 상태에서 풀려났을 가능성 여부를 알 수 있다.
- 예제 14.16 Semaphre 클래스의 tryAcquire 메소드와 tryReleaseShared 메소드
~~~
protected int tryAcquireShared(int acquires) {
    for (;;) {
        if (hasQueuedPredecessors())
            return -1;
        int available = getState();
        int remaining = available - acquires;
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}

protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next < current) // overflow
            throw new Error("Maximum permit count exceeded");
        if (compareAndSetState(current, next))
            return true;
    }
}
~~~
- CountDownLatch 클래스도 동기화 상태 값을 현재 개수로 사용하는 세마포어와 비슷한 형태로 AQS 사용
- countDown 메소드는 release 메소드를 호출하고, release 메소드에서 개수 값을 줄이고 개수가 0에 이르렀다면 대기 중이던 스레드를 대기 상태에서 풀어준다.
- await 메소드는 acquire 메소드를 호출하며 클래스 내부의 개수가 0이라면 즉시 리턴하고 0보다 큰 값이라면 대기 상태에 들어간다.

### 14.6.3 FutureTask
- FutureTask.get 메소드는 래치 클래스와 굉장히 비슷한 기능
- 특정 이벤트가 발생하면 해당 스레드가 계쏙 진행할 수 있고, 아니면 원하는 이벤트가 발생할 때까지 스레드가 대기 상태에 들어간다.
- FutureTask 는 작업의 실행 상황, 즉 실행 중이거나 완료됐거나 취소되는 등의 상황을 관리하는데 AQS 내부의 동기화 상태를 활용한다.
- 그에 덧붙여 작업을 끝나면서 만들어낸 결과 값이나 작업에서 오류가 발생했을 때 해당하는 예외 객체를 담아둘 수 있는 추가적인 상태 변수조 갖고 이싿
- 게다가 실제 작업을 처리하고 있는 스레드에 대한 참조도 갖고 있으며, 그래야만 인터럽트 요청이 들어 왔을 때 해당 스레드에 인터럽트를 걸 수 있다.

### 14.6.4 ReentrantReadWriteLock
- AQS 기반으로 구현된 ReentrantReadWriteLock는 AQS 하위 클래스 하나로 읽기 작업과 쓰기 작업을 모두 담당한다.
- ReentrantReadWriteLock은 상태 변수의 32개 비트 가운데 16비트는 쓰기 락에 대한 개수를 관리하고 나머지는 읽기 락의 개수를 관리한다.
- 읽기 락에 대한 기능은 독점적이지 않은 확보와 해제 연산으로 구현돼 있고, 쓰기 락에 대한 기능은 독점적인 확보와 해제 연산을 사용한다.
- 내부적으로 AQS를 상속받은 클래스는 대기 중인 스레드의 큐를 관리하고, 스레드가 독점적인 연산을 요청했는지 아니면 독점적이지 않은 연산을 요청했는지도 관리한다.
- ReentrantReadWriteLock 은 락에 여유가 생겼을 때 대기 큐의 맨 앞에 들어있는 스레드가 쓰기 락을 요청한 상태였다면 해당 스레드가 락을 독점적으로 가져가고, 만약 맨 앞에 있는 스레드가 읽기 락을 요청한 상태였다면 쓰기 락을 요청한 다음 스레드가 나타나기 전까지 읽기 락을 요청하는 모든 스레드가 독점적이지 않은 락을 가져간다.

## 요약
- 상태 기반으로 동작하는 클래스, 즉 메소드 가운데 하나라도 상태 값에 따라 대기 상태에 들어갈 가능성이 있는 클래스를 작성해야 할 때 가장 좋은 방법은 Semaphore, BlockingQueue, CountDownLatch등읠 활용해 구현하는 방법
- 적절한 기능이 없다면 암묵적인 조건 큐나 명시적인 Condition클래스 또는 AQS 클래스등을 활용해 직접 우너하는 기느으이 동기화 클래스를 작성
- 상태 의존성을 관리하는 작업은 상태의 일관성을 유지하는 방법과 맞물려있기 때문에 암묵적인 조건 큐 역시 암묵적인 락과 굉장히 밀접하게 관련돼 있다. 
- 명시적인 조건 큐인 Condition 클래스도 명시적인 Lock 클래스와 밀접하게 관련돼 있으며, 락 하나에서 다수의 대기 큐를 활용하거나 대기 상태에서 인터럽트에 어떻게 반응하는지를 지정하는 기능, 스레드 대기 큐의 관리 방법에 대한 공정성 여부를 지정하는 기능, 대기 상태에서 머무르는 식나을 제한할 수 있는 기능 등과 같이 암묵적인 버전의 조건 큐나 락보다 훨씬 다양한 기능을 제공한다.


